<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Afwah — Misinformation Cascade Simulation</title>

  <!-- Fonts -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Space+Grotesk:wght@400;500;600;700&display=swap">
  <link rel="stylesheet" href="https://api.fontshare.com/v2/css?f[]=satoshi@400,500,700&display=swap">

  <!-- Phosphor Icons -->
  <link rel="stylesheet" href="https://unpkg.com/@phosphor-icons/web@2.0.3/src/regular/style.css">
  <link rel="stylesheet" href="https://unpkg.com/@phosphor-icons/web@2.0.3/src/bold/style.css">
  <link rel="stylesheet" href="https://unpkg.com/@phosphor-icons/web@2.0.3/src/fill/style.css">

  <!-- D3.js & Chart.js -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <style>
/* ============================================================
   CSS DESIGN SYSTEM — Dual Theme
   ============================================================ */

/* --- Theme: Light (default) --- */
[data-theme="light"] {
  --bg-body: #F6F1EB;
  --bg-card: #FFFFFF;
  --bg-card-alt: #FAF7F3;
  --bg-input: #FFFFFF;
  --bg-hover: rgba(0,0,0,0.04);
  --border-main: #E0D8CF;
  --border-subtle: #EDE7DF;
  --text-primary: #1A1A2E;
  --text-secondary: #5A5A72;
  --text-tertiary: #8A8A9A;
  --text-on-dark: #F0EDE8;
  --shadow-sm: 0 1px 3px rgba(0,0,0,0.06);
  --shadow-md: 0 4px 12px rgba(0,0,0,0.08);
  --shadow-lg: 0 8px 24px rgba(0,0,0,0.10);
}

/* --- Theme: Dark --- */
[data-theme="dark"] {
  --bg-body: #141418;
  --bg-card: #1E1E28;
  --bg-card-alt: #24242F;
  --bg-input: #1A1A24;
  --bg-hover: rgba(255,255,255,0.06);
  --border-main: #2E2E3A;
  --border-subtle: #252530;
  --text-primary: #E8E4DF;
  --text-secondary: #A0A0B2;
  --text-tertiary: #6A6A7E;
  --text-on-dark: #F0EDE8;
  --shadow-sm: none;
  --shadow-md: none;
  --shadow-lg: none;
}

/* --- Semantic Colors (same both themes) --- */
:root {
  /* Status */
  --status-unaware: #A0A0B0;
  --status-believing: #E05252;
  --status-silent: #D4A04A;
  --status-corrected: #5294CC;
  --status-immune: #52B788;
  --status-removed: #4A4A5A;

  /* Agent type rings */
  --agent-influencer: #F0C040;
  --agent-fc: #52B788;
  --agent-bot: #9B5DE5;
  --agent-lurker: #6A6A7E;
  --agent-regular: transparent;

  /* Edge pulse */
  --edge-rumor: #E05252;
  --edge-correction: #5294CC;
  --edge-hop: #C85294;

  /* Accents */
  --accent-primary: #E05252;
  --accent-secondary: #5294CC;
  --accent-tertiary: #52B788;

  /* Pastel cards */
  --card-pink: #FDE8E8;
  --card-green: #E2F5EC;
  --card-yellow: #FDF6E3;
  --card-lavender: #EDE4F7;
  --card-blue: #E4EFF9;

  /* Dark-theme pastel (muted) */
  --card-pink-dark: #3A2020;
  --card-green-dark: #1A3028;
  --card-yellow-dark: #332E1A;
  --card-lavender-dark: #2A2038;
  --card-blue-dark: #1A2838;

  /* Timeline markers */
  --marker-rumor-seed: #E05252;
  --marker-mutation: #D4A04A;
  --marker-correction: #5294CC;
  --marker-hop: #C85294;
  --marker-amp: #F0C040;
  --marker-sse: #FF6B35;
  --marker-crisis: #9B5DE5;
  --marker-bot-detect: #52B788;
  --marker-community-note: #00B4D8;
  --marker-termination: #4A4A5A;

  /* Sidebar (always dark) */
  --sidebar-bg: #1E1E28;
  --sidebar-bg-dark: #0E0E14;
  --sidebar-text: #C8C4BE;
  --sidebar-text-dim: #7A7A8E;
  --sidebar-border: #2E2E3A;
  --sidebar-input-bg: #14141E;
  --sidebar-hover: rgba(255,255,255,0.06);

  /* Graph canvas (always dark) */
  --graph-bg: #1A1A2E;
  --graph-bg-dark: #0E0E18;

  /* Spacing scale */
  --sp-1: 4px;
  --sp-2: 8px;
  --sp-3: 12px;
  --sp-4: 16px;
  --sp-5: 20px;
  --sp-6: 24px;
  --sp-8: 32px;
  --sp-10: 40px;
  --sp-12: 48px;

  /* Border radius (max 8px per spec) */
  --radius-sm: 4px;
  --radius-md: 6px;
  --radius-lg: 8px;

  /* Typography */
  --font-display: 'Space Grotesk', 'Arial Black', sans-serif;
  --font-body: 'Satoshi', 'Inter', -apple-system, sans-serif;
  --font-mono: 'JetBrains Mono', 'Fira Code', monospace;
}

/* --- Reset & Base --- */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

html, body {
  height: 100%;
  font-family: var(--font-body);
  font-size: 14px;
  line-height: 1.5;
  color: var(--text-primary);
  background: var(--bg-body);
  overflow: hidden;
  -webkit-font-smoothing: antialiased;
}

/* --- Layout Grid --- */
#app {
  display: grid;
  grid-template-columns: 280px 1fr;
  grid-template-rows: 48px 1fr 60px;
  grid-template-areas:
    "sidebar header"
    "sidebar main"
    "sidebar timeline";
  height: 100vh;
  width: 100vw;
}

/* --- Header Bar --- */
#header {
  grid-area: header;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 var(--sp-5);
  background: var(--bg-card);
  border-bottom: 1px solid var(--border-main);
  z-index: 20;
}

#header .logo {
  font-family: var(--font-display);
  font-size: 18px;
  font-weight: 600;
  letter-spacing: -0.02em;
  color: var(--text-primary);
}

#header .logo span {
  color: var(--accent-primary);
}

.header-center {
  display: flex;
  gap: var(--sp-2);
}

.mode-tab {
  font-family: var(--font-body);
  font-size: 12px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  padding: 6px 16px;
  border: 1px solid var(--border-main);
  border-radius: var(--radius-md);
  background: transparent;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s ease;
}

.mode-tab:hover {
  background: var(--bg-hover);
}

.mode-tab.active {
  background: var(--accent-primary);
  color: #FFF;
  border-color: var(--accent-primary);
}

.header-right {
  display: flex;
  align-items: center;
  gap: var(--sp-3);
}

#theme-toggle {
  width: 36px;
  height: 36px;
  border: 1px solid var(--border-main);
  border-radius: var(--radius-md);
  background: transparent;
  color: var(--text-secondary);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  transition: all 0.15s ease;
}

#theme-toggle:hover {
  background: var(--bg-hover);
  color: var(--text-primary);
}

/* --- Sidebar (always dark) --- */
#sidebar {
  grid-area: sidebar;
  background: var(--sidebar-bg);
  border-right: 1px solid var(--sidebar-border);
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  overflow-x: hidden;
  z-index: 30;
}

[data-theme="dark"] #sidebar {
  background: var(--sidebar-bg-dark);
}

.sidebar-brand {
  padding: var(--sp-4) var(--sp-5);
  border-bottom: 1px solid var(--sidebar-border);
}

.sidebar-brand h1 {
  font-family: var(--font-display);
  font-size: 20px;
  font-weight: 600;
  color: #F0EDE8;
  letter-spacing: -0.02em;
}

.sidebar-brand h1 span { color: var(--accent-primary); }

.sidebar-brand p {
  font-size: 11px;
  color: var(--sidebar-text-dim);
  margin-top: 2px;
}

.sidebar-section {
  padding: var(--sp-4) var(--sp-5);
  border-bottom: 1px solid var(--sidebar-border);
}

.sidebar-section-title {
  font-family: var(--font-body);
  font-size: 10px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--sidebar-text-dim);
  margin-bottom: var(--sp-3);
}

.sidebar-field { margin-bottom: var(--sp-3); }

.sidebar-field label {
  display: block;
  font-size: 12px;
  color: var(--sidebar-text);
  margin-bottom: var(--sp-1);
}

.sidebar-select,
.sidebar-input {
  width: 100%;
  padding: 6px 10px;
  font-family: var(--font-body);
  font-size: 12px;
  background: var(--sidebar-input-bg);
  color: var(--sidebar-text);
  border: 1px solid var(--sidebar-border);
  border-radius: var(--radius-sm);
  outline: none;
  transition: border-color 0.15s;
}

.sidebar-select:focus,
.sidebar-input:focus {
  border-color: var(--accent-primary);
}

.sidebar-select option {
  background: var(--sidebar-input-bg);
  color: var(--sidebar-text);
}

/* Slider */
.slider-row {
  display: flex;
  align-items: center;
  gap: var(--sp-2);
}
.emo-label {
  font-size: 11px;
  width: 56px;
  flex-shrink: 0;
  color: var(--sidebar-text);
}

.slider-row input[type="range"] {
  flex: 1;
  -webkit-appearance: none;
  height: 4px;
  background: var(--sidebar-border);
  border-radius: 2px;
  outline: none;
}

.slider-row input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: var(--accent-primary);
  cursor: pointer;
}

.slider-value {
  font-family: var(--font-mono);
  font-size: 11px;
  color: var(--accent-primary);
  min-width: 36px;
  text-align: right;
}

/* Sidebar buttons */
.sidebar-actions {
  display: flex;
  gap: var(--sp-2);
  padding: var(--sp-4) var(--sp-5);
}

.btn-run, .btn-reset {
  flex: 1;
  padding: 8px 0;
  font-family: var(--font-body);
  font-size: 12px;
  font-weight: 600;
  border: none;
  border-radius: var(--radius-md);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: var(--sp-2);
  transition: all 0.15s ease;
}

.btn-run {
  background: var(--accent-primary);
  color: #FFF;
}

.btn-run:hover { opacity: 0.9; }

.btn-run:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-reset {
  background: transparent;
  color: var(--sidebar-text);
  border: 1px solid var(--sidebar-border);
}

.btn-reset:hover { background: var(--sidebar-hover); }

/* --- Main Content Area --- */
#main {
  grid-area: main;
  display: grid;
  grid-template-columns: 1fr 320px;
  grid-template-rows: 1fr;
  gap: 0;
  overflow: hidden;
}

/* Graph panel */
#graph-panel {
  display: flex;
  flex-direction: column;
  background: var(--graph-bg);
  position: relative;
  overflow: hidden;
}

[data-theme="dark"] #graph-panel {
  background: var(--graph-bg-dark);
}

#main-graph {
  flex: 1;
  width: 100%;
  height: 100%;
}

/* Zoom controls */
.zoom-controls {
  position: absolute;
  bottom: 12px;
  right: 12px;
  display: flex;
  flex-direction: column;
  gap: 4px;
  z-index: 10;
}
.zoom-btn {
  width: 28px;
  height: 28px;
  border: none;
  border-radius: 6px;
  background: rgba(0,0,0,0.5);
  backdrop-filter: blur(4px);
  color: #FFF;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  transition: background 0.15s;
}
.zoom-btn:hover { background: rgba(0,0,0,0.7); }

/* Graph stats overlay */
.graph-stats {
  position: absolute;
  top: var(--sp-3);
  left: var(--sp-3);
  display: flex;
  gap: var(--sp-2);
  pointer-events: none;
}

.graph-stat-pill {
  padding: 3px 10px;
  border-radius: var(--radius-lg);
  font-family: var(--font-mono);
  font-size: 11px;
  font-weight: 500;
  color: #FFF;
  background: rgba(0,0,0,0.5);
  backdrop-filter: blur(4px);
}

/* --- Right Panel --- */
#right-panel {
  display: flex;
  flex-direction: column;
  border-left: 1px solid var(--border-main);
  background: var(--bg-body);
  overflow: hidden;
}

/* Right panel tabs */
.rp-tabs {
  display: flex;
  border-bottom: 1px solid var(--border-main);
  background: var(--bg-card);
  flex-shrink: 0;
}

.rp-tab {
  flex: 1;
  padding: 8px 0;
  font-family: var(--font-body);
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  text-align: center;
  color: var(--text-tertiary);
  border: none;
  background: transparent;
  cursor: pointer;
  border-bottom: 2px solid transparent;
  transition: all 0.15s;
}

.rp-tab:hover { color: var(--text-secondary); }

.rp-tab.active {
  color: var(--accent-primary);
  border-bottom-color: var(--accent-primary);
}

/* Right panel content sections */
.rp-content {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
}

.rp-section { display: none; padding: 0; }
.rp-section.active { display: block; padding: var(--sp-3); }

/* Feed panel */
#feed-container {
  padding: var(--sp-3);
  display: flex;
  flex-direction: column;
  gap: var(--sp-2);
}

.feed-event {
  padding: var(--sp-3);
  border-radius: var(--radius-md);
  font-size: 12px;
  line-height: 1.5;
  border: 1px solid var(--border-subtle);
}

.feed-event.major {
  background: var(--bg-card);
  box-shadow: var(--shadow-sm);
}

.feed-event.compact {
  padding: var(--sp-2) var(--sp-3);
  font-size: 11px;
  color: var(--text-secondary);
  background: transparent;
  border: none;
  border-bottom: 1px solid var(--border-subtle);
}

.feed-event .feed-icon {
  font-size: 14px;
  margin-right: var(--sp-2);
  vertical-align: middle;
}

.feed-event .feed-time {
  font-family: var(--font-mono);
  font-size: 10px;
  color: var(--text-tertiary);
  margin-right: var(--sp-2);
}

.feed-event.type-rumor { background: var(--card-pink); }
.feed-event.type-correction { background: var(--card-blue); }
.feed-event.type-mutation { background: var(--card-yellow); }
.feed-event.type-hop { background: var(--card-lavender); }
.feed-event.type-amp { background: var(--card-yellow); }
.feed-event.type-crisis { background: var(--card-lavender); }

[data-theme="dark"] .feed-event.type-rumor { background: var(--card-pink-dark); }
[data-theme="dark"] .feed-event.type-correction { background: var(--card-blue-dark); }
[data-theme="dark"] .feed-event.type-mutation { background: var(--card-yellow-dark); }
[data-theme="dark"] .feed-event.type-hop { background: var(--card-lavender-dark); }
[data-theme="dark"] .feed-event.type-amp { background: var(--card-yellow-dark); }
[data-theme="dark"] .feed-event.type-crisis { background: var(--card-lavender-dark); }

/* Jump to latest */
#feed-jump {
  display: none;
  position: sticky;
  bottom: var(--sp-2);
  align-self: center;
  padding: 4px 12px;
  font-size: 11px;
  font-weight: 600;
  border-radius: var(--radius-lg);
  background: var(--accent-primary);
  color: #FFF;
  border: none;
  cursor: pointer;
  z-index: 5;
}

/* Analytics section */
#analytics-container {
  padding: var(--sp-3);
}

.stats-bar {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--sp-2);
  margin-bottom: var(--sp-4);
}

.stat-card {
  padding: var(--sp-3);
  border-radius: var(--radius-md);
  text-align: center;
}

.stat-card.card-pink { background: var(--card-pink); }
.stat-card.card-blue { background: var(--card-blue); }
.stat-card.card-yellow { background: var(--card-yellow); }
.stat-card.card-lavender { background: var(--card-lavender); }
.stat-card.card-green { background: var(--card-green); }

[data-theme="dark"] .stat-card.card-pink, [data-theme="dark"] .mc-stat-card.card-pink { background: var(--card-pink-dark); }
[data-theme="dark"] .stat-card.card-blue, [data-theme="dark"] .mc-stat-card.card-blue { background: var(--card-blue-dark); }
[data-theme="dark"] .stat-card.card-yellow, [data-theme="dark"] .mc-stat-card.card-yellow { background: var(--card-yellow-dark); }
[data-theme="dark"] .stat-card.card-lavender, [data-theme="dark"] .mc-stat-card.card-lavender { background: var(--card-lavender-dark); }
[data-theme="dark"] .stat-card.card-green, [data-theme="dark"] .mc-stat-card.card-green { background: var(--card-green-dark); }

.stat-card .stat-value {
  font-family: var(--font-display);
  font-size: 24px;
  font-weight: 600;
  color: var(--text-primary);
}

.stat-card .stat-label {
  font-family: var(--font-body);
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-tertiary);
  margin-top: 2px;
}

.chart-container {
  background: var(--bg-card);
  border-radius: var(--radius-md);
  padding: var(--sp-3);
  margin-bottom: var(--sp-3);
  border: 1px solid var(--border-subtle);
}

.chart-container h3 {
  font-family: var(--font-body);
  font-size: 11px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--text-tertiary);
  margin-bottom: var(--sp-2);
}

.chart-canvas {
  width: 100% !important;
  height: 160px !important;
}

/* R0 display */
.r0-display {
  display: flex;
  align-items: baseline;
  gap: var(--sp-2);
  padding: var(--sp-3);
  background: var(--bg-card);
  border-radius: var(--radius-md);
  border: 1px solid var(--border-subtle);
  margin-bottom: var(--sp-3);
}

.r0-value {
  font-family: var(--font-display);
  font-size: 36px;
  font-weight: 700;
}

.r0-label {
  font-size: 11px;
  color: var(--text-tertiary);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.r0-value.high { color: var(--status-believing); }
.r0-value.low { color: var(--status-immune); }

/* Concepts panel */
#concepts-container {
  padding: var(--sp-3);
}

.concept-item {
  display: flex;
  align-items: center;
  gap: var(--sp-3);
  padding: var(--sp-2) var(--sp-3);
  border-bottom: 1px solid var(--border-subtle);
  transition: background 0.3s ease;
}

.concept-item.flash {
  background: var(--card-yellow);
}

[data-theme="dark"] .concept-item.flash {
  background: var(--card-yellow-dark);
}

.concept-item i {
  font-size: 16px;
  color: var(--text-tertiary);
  width: 20px;
  text-align: center;
}

.concept-label {
  flex: 1;
  font-size: 12px;
  color: var(--text-secondary);
}

.concept-value {
  font-family: var(--font-mono);
  font-size: 12px;
  font-weight: 500;
  color: var(--accent-primary);
  min-width: 48px;
  text-align: right;
}

/* --- Timeline Bar --- */
#timeline {
  grid-area: timeline;
  display: flex;
  align-items: center;
  gap: var(--sp-3);
  padding: 0 var(--sp-5);
  background: var(--bg-card);
  border-top: 1px solid var(--border-main);
  z-index: 20;
}

.transport-controls {
  display: flex;
  align-items: center;
  gap: var(--sp-1);
}

.transport-btn {
  width: 32px;
  height: 32px;
  border: none;
  border-radius: var(--radius-sm);
  background: transparent;
  color: var(--text-secondary);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  transition: all 0.15s;
}

.transport-btn:hover {
  background: var(--bg-hover);
  color: var(--text-primary);
}

.transport-btn.active {
  color: var(--accent-primary);
}

/* Scrubber track */
.scrubber-wrap {
  flex: 1;
  position: relative;
  height: 32px;
  display: flex;
  align-items: center;
}

#scrubber {
  width: 100%;
  -webkit-appearance: none;
  height: 4px;
  background: var(--border-main);
  border-radius: 2px;
  outline: none;
  position: relative;
  z-index: 2;
}

#scrubber::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: var(--accent-primary);
  cursor: pointer;
  box-shadow: 0 0 0 3px rgba(224, 82, 82, 0.2);
}

/* Timeline markers */
.timeline-markers {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 100%;
  pointer-events: none;
  z-index: 1;
}

.timeline-marker {
  position: absolute;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  pointer-events: all;
  cursor: pointer;
  z-index: 3;
}

.timeline-marker:hover::after {
  content: attr(data-tooltip);
  position: absolute;
  bottom: 16px;
  left: 50%;
  transform: translateX(-50%);
  padding: 4px 8px;
  font-family: var(--font-body);
  font-size: 10px;
  white-space: nowrap;
  background: #1A1A2E;
  color: #FFF;
  border-radius: var(--radius-sm);
}

/* Speed controls */
.speed-controls {
  display: flex;
  gap: 2px;
}

.speed-btn {
  padding: 4px 8px;
  font-family: var(--font-mono);
  font-size: 10px;
  font-weight: 600;
  border: 1px solid var(--border-main);
  border-radius: var(--radius-sm);
  background: transparent;
  color: var(--text-tertiary);
  cursor: pointer;
  transition: all 0.15s;
}

.speed-btn:hover {
  background: var(--bg-hover);
  color: var(--text-secondary);
}

.speed-btn.active {
  background: var(--accent-primary);
  color: #FFF;
  border-color: var(--accent-primary);
}

/* Time display */
.time-display {
  font-family: var(--font-mono);
  font-size: 12px;
  font-weight: 500;
  color: var(--text-secondary);
  min-width: 90px;
  text-align: right;
}

/* --- Monte Carlo Dashboard (hidden by default) --- */
#mc-dashboard {
  display: none;
  grid-area: main;
  overflow-y: auto;
  padding: var(--sp-5);
  background: var(--bg-body);
}

#mc-dashboard.active {
  display: block;
}

.mc-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: var(--sp-5);
}

.mc-header h2 {
  font-family: var(--font-display);
  font-size: 22px;
  font-weight: 600;
}

.mc-run-selector {
  display: flex;
  gap: var(--sp-2);
  align-items: center;
}

.mc-count-btn {
  padding: 6px 14px;
  font-family: var(--font-mono);
  font-size: 12px;
  font-weight: 600;
  border: 1px solid var(--border-main);
  border-radius: var(--radius-md);
  background: transparent;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all 0.15s;
}

.mc-count-btn:hover { background: var(--bg-hover); }
.mc-count-btn.active {
  background: var(--accent-primary);
  color: #FFF;
  border-color: var(--accent-primary);
}

.btn-mc-run {
  padding: 8px 20px;
  font-family: var(--font-body);
  font-size: 12px;
  font-weight: 600;
  border: none;
  border-radius: var(--radius-md);
  background: var(--accent-primary);
  color: #FFF;
  cursor: pointer;
}

.mc-progress {
  padding: var(--sp-4);
  background: var(--bg-card);
  border-radius: var(--radius-md);
  border: 1px solid var(--border-subtle);
  margin-bottom: var(--sp-5);
  font-family: var(--font-mono);
  font-size: 13px;
  color: var(--text-secondary);
  display: none;
}

.mc-charts {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: var(--sp-4);
}

.mc-chart-card {
  background: var(--bg-card);
  border-radius: var(--radius-md);
  padding: var(--sp-4);
  border: 1px solid var(--border-subtle);
  min-height: 260px;
  position: relative;
}

.mc-chart-card h3 {
  font-family: var(--font-body);
  font-size: 12px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  color: var(--text-tertiary);
  margin-bottom: var(--sp-3);
}

.mc-chart-desc {
  font-size: 11px;
  line-height: 1.55;
  margin-bottom: var(--sp-3);
  color: var(--text-tertiary);
  position: relative;
  z-index: 3;
}

.mc-chart-canvas {
  width: 100% !important;
  height: 220px !important;
}

.mc-stats {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: var(--sp-3);
  margin-bottom: var(--sp-5);
}

.mc-stat-card {
  padding: var(--sp-3);
  border-radius: var(--radius-md);
  text-align: center;
}

.mc-stat-card .stat-value {
  font-family: var(--font-display);
  font-size: 20px;
  font-weight: 600;
}

.mc-stat-card .stat-label {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.08em;
  color: var(--text-tertiary);
}

.mc-concepts {
  margin-top: var(--sp-5);
  padding: var(--sp-4);
  background: var(--card-yellow);
  border-radius: var(--radius-md);
}

[data-theme="dark"] .mc-concepts {
  background: var(--card-yellow-dark);
}

.mc-concepts h3 {
  font-family: var(--font-body);
  font-size: 12px;
  font-weight: 700;
  margin-bottom: var(--sp-2);
}

.mc-concepts p {
  font-size: 12px;
  color: var(--text-secondary);
  line-height: 1.6;
}

/* --- Retro CRT / Arcade MC Dashboard — shared base --- */
.retro-mc .mc-chart-card {
  position: relative;
  overflow: hidden;
}
.retro-mc .mc-chart-card h3 {
  font-family: var(--font-mono);
  letter-spacing: 0.12em;
  position: relative;
  z-index: 3;
}
.retro-mc .mc-chart-canvas { position: relative; z-index: 3; }
.retro-mc .mc-stat-card { border-left: 3px solid; }
.retro-mc .mc-stat-card .stat-value { font-family: var(--font-mono); }
.retro-mc .mc-stat-card .stat-label { font-family: var(--font-mono); }
.retro-mc .mc-concepts h3 { font-family: var(--font-mono); }

/* --- Retro MC: DARK theme (CRT/Arcade) --- */
[data-theme="dark"] .retro-mc { background: #0a0a12 !important; }
[data-theme="dark"] .retro-mc .mc-header h2 { color: #d1f7ff; text-shadow: 0 0 10px rgba(5,217,232,0.3); }
[data-theme="dark"] .retro-mc .mc-chart-card {
  background: #0f0f1a;
  border: 1px solid rgba(5,217,232,0.12);
}
[data-theme="dark"] .retro-mc .mc-chart-card::before {
  content: '';
  position: absolute;
  inset: 0;
  background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.12) 2px, rgba(0,0,0,0.12) 4px);
  pointer-events: none;
  z-index: 2;
}
[data-theme="dark"] .retro-mc .mc-chart-card::after {
  content: '';
  position: absolute;
  inset: 0;
  background: radial-gradient(ellipse at center, transparent 55%, rgba(0,0,0,0.35) 100%);
  pointer-events: none;
  z-index: 1;
}
[data-theme="dark"] .retro-mc .mc-chart-card h3 {
  color: #05d9e8;
  text-shadow: 0 0 8px rgba(5,217,232,0.4);
}
[data-theme="dark"] .retro-mc .mc-chart-desc {
  color: rgba(209,247,255,0.35);
}
[data-theme="dark"] .retro-mc .mc-stat-card {
  background: #0f0f1a !important;
  border: 1px solid rgba(5,217,232,0.1);
}
[data-theme="dark"] .retro-mc .mc-stat-card.card-pink { border-left-color: #ff2a6d; }
[data-theme="dark"] .retro-mc .mc-stat-card.card-blue { border-left-color: #05d9e8; }
[data-theme="dark"] .retro-mc .mc-stat-card.card-yellow { border-left-color: #ff9e00; }
[data-theme="dark"] .retro-mc .mc-stat-card.card-lavender { border-left-color: #01ff89; }
[data-theme="dark"] .retro-mc .mc-stat-card .stat-value {
  color: #d1f7ff;
  text-shadow: 0 0 6px rgba(209,247,255,0.3);
}
[data-theme="dark"] .retro-mc .mc-stat-card .stat-label { color: rgba(209,247,255,0.4); }
[data-theme="dark"] .retro-mc .mc-progress {
  background: #0a0a12;
  border: 1px solid rgba(1,255,137,0.2);
  color: #01ff89;
  text-shadow: 0 0 4px rgba(1,255,137,0.3);
}
[data-theme="dark"] .retro-mc .mc-count-btn {
  border-color: rgba(5,217,232,0.2);
  color: rgba(209,247,255,0.5);
}
[data-theme="dark"] .retro-mc .mc-count-btn:hover { background: rgba(5,217,232,0.1); }
[data-theme="dark"] .retro-mc .mc-count-btn.active {
  background: #ff2a6d;
  border-color: #ff2a6d;
  color: #fff;
  box-shadow: 0 0 12px rgba(255,42,109,0.4);
}
[data-theme="dark"] .retro-mc .btn-mc-run {
  background: #05d9e8;
  color: #0a0a12;
  font-weight: 700;
  box-shadow: 0 0 12px rgba(5,217,232,0.3);
}
[data-theme="dark"] .retro-mc .btn-mc-run:hover { box-shadow: 0 0 20px rgba(5,217,232,0.5); }
[data-theme="dark"] .retro-mc .mc-concepts {
  background: rgba(5,217,232,0.05);
  border: 1px solid rgba(5,217,232,0.1);
}
[data-theme="dark"] .retro-mc .mc-concepts h3 { color: #05d9e8; }
[data-theme="dark"] .retro-mc .mc-concepts p { color: rgba(209,247,255,0.5); }
[data-theme="dark"] .retro-mc .notable-runs { background: rgba(255,158,0,0.05); border: 1px solid rgba(255,158,0,0.15); }

/* --- Retro MC: LIGHT theme (warm terminal on paper) --- */
[data-theme="light"] .retro-mc { background: #f5f0e8 !important; }
[data-theme="light"] .retro-mc .mc-header h2 { color: #1a1a2e; text-shadow: none; }
[data-theme="light"] .retro-mc .mc-chart-card {
  background: #fffdf8;
  border: 1px solid rgba(180,140,100,0.18);
  box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}
[data-theme="light"] .retro-mc .mc-chart-card::before {
  content: '';
  position: absolute;
  inset: 0;
  background: repeating-linear-gradient(0deg, transparent, transparent 3px, rgba(180,140,100,0.04) 3px, rgba(180,140,100,0.04) 6px);
  pointer-events: none;
  z-index: 2;
}
[data-theme="light"] .retro-mc .mc-chart-card::after {
  content: '';
  position: absolute;
  inset: 0;
  background: radial-gradient(ellipse at center, transparent 65%, rgba(180,140,100,0.06) 100%);
  pointer-events: none;
  z-index: 1;
}
[data-theme="light"] .retro-mc .mc-chart-card h3 {
  color: #0a7c8c;
  text-shadow: none;
}
[data-theme="light"] .retro-mc .mc-chart-desc {
  color: #7a7a8e;
}
[data-theme="light"] .retro-mc .mc-stat-card {
  background: #fffdf8 !important;
  border: 1px solid rgba(180,140,100,0.12);
}
[data-theme="light"] .retro-mc .mc-stat-card.card-pink { border-left-color: #d42257; }
[data-theme="light"] .retro-mc .mc-stat-card.card-blue { border-left-color: #0a7c8c; }
[data-theme="light"] .retro-mc .mc-stat-card.card-yellow { border-left-color: #c47800; }
[data-theme="light"] .retro-mc .mc-stat-card.card-lavender { border-left-color: #0d8a50; }
[data-theme="light"] .retro-mc .mc-stat-card .stat-value {
  color: #1a1a2e;
  text-shadow: none;
}
[data-theme="light"] .retro-mc .mc-stat-card .stat-label { color: #6a6a7e; }
[data-theme="light"] .retro-mc .mc-progress {
  background: #eee9df;
  border: 1px solid rgba(13,138,80,0.25);
  color: #0d6a3f;
  text-shadow: none;
}
[data-theme="light"] .retro-mc .mc-count-btn {
  border-color: rgba(10,124,140,0.25);
  color: #5a5a72;
}
[data-theme="light"] .retro-mc .mc-count-btn:hover { background: rgba(10,124,140,0.08); }
[data-theme="light"] .retro-mc .mc-count-btn.active {
  background: #d42257;
  border-color: #d42257;
  color: #fff;
  box-shadow: 0 2px 8px rgba(212,34,87,0.25);
}
[data-theme="light"] .retro-mc .btn-mc-run {
  background: #0a7c8c;
  color: #fff;
  font-weight: 700;
  box-shadow: 0 2px 8px rgba(10,124,140,0.25);
}
[data-theme="light"] .retro-mc .btn-mc-run:hover { box-shadow: 0 4px 14px rgba(10,124,140,0.35); }
[data-theme="light"] .retro-mc .mc-concepts {
  background: rgba(10,124,140,0.04);
  border: 1px solid rgba(10,124,140,0.12);
}
[data-theme="light"] .retro-mc .mc-concepts h3 { color: #0a7c8c; }
[data-theme="light"] .retro-mc .mc-concepts p { color: #5a5a72; }
[data-theme="light"] .retro-mc .notable-runs { background: rgba(196,120,0,0.06); border: 1px solid rgba(196,120,0,0.18); }

/* --- Scrollbar styling --- */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb {
  background: var(--border-main);
  border-radius: 3px;
}
::-webkit-scrollbar-thumb:hover { background: var(--text-tertiary); }

/* --- Utility --- */
.hidden { display: none !important; }

/* Phosphor icon sizing within buttons/labels */
i[class^="ph-"] {
  display: inline-flex;
  align-items: center;
  line-height: 1;
}

/* --- Media Cards (Phase 5) --- */
.media-card {
  border-radius: 6px;
  padding: 10px 12px;
  margin-top: 8px;
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 11px;
}
.media-card-video::after {
  content: '';
}
.media-card-reel {
  max-height: 80px;
  aspect-ratio: 9/16;
  flex-direction: column;
  justify-content: center;
}
.media-card-screenshot {
  border: 1px solid var(--border);
  padding: 8px;
  background: var(--bg-card-alt);
  flex-direction: column;
  align-items: flex-start;
}
.media-card-screenshot .source-platform {
  font-size: 10px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  gap: 4px;
}

/* --- Feed card upgrades (Phase 5) --- */
.feed-card-message {
  font-size: 12px;
  line-height: 1.5;
  color: var(--text-primary);
  margin: 6px 0;
  white-space: pre-line;
}
.feed-card-meta {
  font-size: 10px;
  color: var(--text-muted);
  font-family: var(--font-mono);
}
.feed-platform-badge {
  font-size: 9px;
  padding: 1px 6px;
  border-radius: 3px;
  background: var(--bg-tertiary);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  font-weight: 600;
}

/* --- Node Popup (Phase 5) --- */
.node-popup {
  position: fixed;
  right: 324px;
  top: 80px;
  width: 360px;
  max-height: calc(100vh - 160px);
  overflow-y: auto;
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 8px;
  box-shadow: 0 8px 32px rgba(0,0,0,0.18);
  z-index: 100;
  font-family: var(--font-body);
}
.node-popup-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 16px;
  border-bottom: 1px solid var(--border);
  position: sticky;
  top: 0;
  background: var(--bg-card);
  z-index: 1;
}
.node-popup-title {
  display: flex;
  align-items: center;
  gap: 8px;
  font-weight: 600;
  font-size: 14px;
}
.node-popup-close {
  background: none;
  border: none;
  cursor: pointer;
  color: var(--text-muted);
  font-size: 16px;
  padding: 4px;
}
.node-popup-close:hover { color: var(--text-primary); }
.popup-section {
  padding: 10px 16px;
  border-bottom: 1px solid rgba(128,128,128,0.1);
}
.popup-section-title {
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-muted);
  margin-bottom: 6px;
}
.popup-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 3px 0;
  font-size: 12px;
}
.popup-label {
  color: var(--text-muted);
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}
.popup-value { color: var(--text-primary); }
.popup-value.mono { font-family: var(--font-mono); }
.popup-value.clickable { cursor: pointer; color: var(--accent-primary); text-decoration: underline; }
.popup-value.clickable:hover { opacity: 0.8; }
.worldview-bars .bar-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 2px 0;
}
.worldview-bars .bar-label {
  width: 80px;
  font-size: 10px;
  text-transform: uppercase;
  color: var(--text-muted);
}
.worldview-bars .bar-track {
  flex: 1;
  height: 6px;
  background: rgba(128,128,128,0.15);
  border-radius: 3px;
  position: relative;
  overflow: hidden;
}
.worldview-bars .bar-fill {
  height: 100%;
  border-radius: 3px;
  background: var(--accent-primary);
  transition: width 0.3s;
}
.worldview-bars .bar-val {
  width: 36px;
  text-align: right;
  font-size: 10px;
  font-family: var(--font-mono);
  color: var(--text-muted);
}
.attention-bar {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
}
.attention-track {
  flex: 1;
  height: 6px;
  background: rgba(128,128,128,0.15);
  border-radius: 3px;
  overflow: hidden;
}
.attention-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.3s;
}
.attention-value {
  font-size: 11px;
  font-family: var(--font-mono);
}
.agent-type-badge {
  font-size: 10px;
  padding: 2px 8px;
  border-radius: 4px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}
.badge-regular { background: var(--bg-tertiary); color: var(--text-secondary); }
.badge-influencer { background: rgba(232,197,71,0.15); color: #E8C547; }
.badge-fact_checker { background: rgba(82,183,136,0.15); color: #52B788; }
.badge-bot { background: rgba(155,93,229,0.15); color: #9B5DE5; }
.badge-lurker { background: rgba(128,128,128,0.1); color: var(--text-muted); }
.popup-inbox { max-height: 300px; overflow-y: auto; }
.inbox-msg {
  padding: 8px 10px;
  margin-bottom: 6px;
  border-radius: 6px;
  font-size: 11px;
  border-left: 3px solid var(--border);
}
.inbox-msg.believed { border-left-color: #E05252; background: rgba(224,82,82,0.05); }
.inbox-msg.rejected { border-left-color: #5294CC; background: rgba(82,148,204,0.05); }
.inbox-msg-header {
  display: flex;
  justify-content: space-between;
  font-size: 10px;
  color: var(--text-muted);
  margin-bottom: 4px;
}
.inbox-msg-text {
  color: var(--text-primary);
  line-height: 1.4;
  white-space: pre-line;
  margin-bottom: 4px;
}
.inbox-msg-outcome {
  font-size: 10px;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 4px;
}
.inbox-msg.believed .inbox-msg-outcome { color: #E05252; }
.inbox-msg.rejected .inbox-msg-outcome { color: #5294CC; }
.decision-math {
  padding: 10px 12px;
  border-radius: 6px;
  margin-top: 8px;
  font-size: 11px;
}
.math-row {
  display: flex;
  justify-content: space-between;
  padding: 2px 0;
}
.math-row.result {
  font-weight: 700;
  padding-top: 6px;
  color: var(--accent-primary);
}
.math-row .highlight { color: var(--accent-primary); font-weight: 600; }
.popup-loading {
  text-align: center;
  padding: 32px;
  color: var(--text-muted);
}
.emotion-row {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 2px 0;
  font-size: 11px;
}
.emotion-name { width: 60px; text-transform: uppercase; font-size: 10px; color: var(--text-muted); }
.emotion-vals { font-family: var(--font-mono); font-size: 11px; }
.emotion-annotation { font-size: 9px; color: var(--text-muted); font-style: italic; }
.status-indicator {
  font-size: 11px;
  font-weight: 600;
  padding: 2px 8px;
  border-radius: 4px;
}
.status-indicator.believing { background: rgba(224,82,82,0.12); color: #E05252; }
.status-indicator.corrected { background: rgba(82,148,204,0.12); color: #5294CC; }
.status-indicator.unaware { background: rgba(128,128,128,0.1); color: var(--text-muted); }
.status-indicator.silent_believer { background: rgba(212,160,74,0.12); color: #D4A04A; }
.status-indicator.immune { background: rgba(82,183,136,0.12); color: #52B788; }
.status-indicator.removed { background: rgba(74,74,90,0.15); color: #4A4A5A; }

/* --- Edge Tooltip (Phase 5) --- */
.edge-tooltip {
  position: fixed;
  padding: 10px 14px;
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 6px;
  box-shadow: 0 4px 16px rgba(0,0,0,0.2);
  z-index: 200;
  max-width: 320px;
  font-size: 12px;
  pointer-events: none;
}
.edge-tooltip.correction { border-left: 3px solid #5294CC; }
.edge-tooltip.rumor { border-left: 3px solid #E05252; }
.edge-tooltip-header {
  display: flex;
  align-items: center;
  gap: 6px;
  font-weight: 600;
  margin-bottom: 6px;
  font-size: 12px;
}
.edge-type-badge {
  font-size: 9px;
  padding: 1px 6px;
  border-radius: 3px;
  font-weight: 700;
  text-transform: uppercase;
}
.edge-type-badge.rumor-badge { background: rgba(224,82,82,0.15); color: #E05252; }
.edge-type-badge.corr-badge { background: rgba(82,148,204,0.15); color: #5294CC; }
.edge-tooltip-message {
  font-style: italic;
  color: var(--text-secondary);
  margin-bottom: 6px;
  line-height: 1.4;
}
.edge-tooltip-meta {
  display: flex;
  justify-content: space-between;
  font-size: 11px;
  color: var(--text-muted);
}
.edge-tooltip-details {
  font-size: 10px;
  color: var(--text-muted);
  margin-top: 4px;
}

/* --- Feed Filters (Phase 5) --- */
.feed-filters {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 8px 12px;
  border-bottom: 1px solid var(--border);
  flex-wrap: wrap;
}
.filter-btn {
  font-size: 10px;
  padding: 3px 8px;
  border-radius: 4px;
  border: 1px solid var(--border);
  background: var(--bg-card);
  color: var(--text-muted);
  cursor: pointer;
  font-family: var(--font-body);
  text-transform: uppercase;
  letter-spacing: 0.3px;
  display: flex;
  align-items: center;
  gap: 3px;
  transition: all 0.15s;
}
.filter-btn:hover { border-color: var(--accent-primary); color: var(--text-primary); }
.filter-btn.active { background: var(--accent-primary); color: white; border-color: var(--accent-primary); }
.filter-platform-select {
  font-size: 10px;
  padding: 3px 6px;
  border-radius: 4px;
  border: 1px solid var(--border);
  background: var(--bg-card);
  color: var(--text-secondary);
  font-family: var(--font-body);
  margin-left: auto;
}

/* --- Layout Toggle (Phase 5) --- */
.layout-toggle {
  display: flex;
  gap: 2px;
  background: var(--bg-tertiary);
  border-radius: 6px;
  padding: 2px;
}
.layout-btn {
  width: 32px;
  height: 28px;
  border: none;
  background: transparent;
  border-radius: 4px;
  cursor: pointer;
  color: var(--text-muted);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  transition: all 0.15s;
}
.layout-btn:hover { color: var(--text-primary); }
.layout-btn.active { background: var(--bg-card); color: var(--accent-primary); box-shadow: 0 1px 3px rgba(0,0,0,0.1); }

/* --- Compare Mode (Phase 5) --- */
.compare-container {
  display: flex;
  width: 100%;
  height: 100%;
}
.compare-panel {
  position: relative;
  background: #1A1A2E;
  border-radius: 6px;
  overflow: hidden;
  min-width: 0;
}
#compare-left { flex: 0 0 50%; }
#compare-right { flex: 1 1 0; }
.compare-divider {
  width: 6px;
  cursor: col-resize;
  background: transparent;
  position: relative;
  flex-shrink: 0;
  z-index: 10;
}
.compare-divider::after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 2px;
  height: 40px;
  background: rgba(255,255,255,0.15);
  border-radius: 2px;
  transition: height 0.15s, background 0.15s;
}
.compare-divider:hover::after,
.compare-divider.dragging::after {
  height: 60px;
  background: rgba(255,255,255,0.5);
}
.compare-panel-label {
  position: absolute;
  top: 8px;
  left: 12px;
  font-size: 11px;
  font-weight: 600;
  color: rgba(255,255,255,0.5);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  z-index: 5;
}
.compare-selectors {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 12px;
}
.compare-selectors select {
  font-size: 11px;
  padding: 2px 8px;
  border-radius: 4px;
  border: 1px solid var(--border);
  background: var(--bg-card);
  font-family: var(--font-body);
}
.compare-vs { font-weight: 600; color: var(--text-muted); font-size: 10px; text-transform: uppercase; }
#compare-chart { width: 100%; height: calc(100% - 30px); margin-top: 30px; }

/* --- Overview Mode (Phase 5) --- */
.overview-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  grid-template-rows: 1fr 1fr;
  gap: 2px;
  width: 100%;
  height: 100%;
}
.overview-cell {
  position: relative;
  background: #1A1A2E;
  border-radius: 4px;
  overflow: hidden;
  min-height: 0;
}
.overview-cell canvas {
  display: block;
  width: 100%;
  height: 100%;
}
.overview-label {
  position: absolute;
  top: 6px;
  left: 8px;
  font-size: 10px;
  font-weight: 600;
  color: rgba(255,255,255,0.4);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.overview-stats {
  position: absolute;
  bottom: 6px;
  left: 8px;
  font-size: 10px;
  font-family: var(--font-mono);
  color: rgba(255,255,255,0.6);
  display: flex;
  gap: 8px;
}
.overview-cell.hop-flash {
  animation: hopFlash 0.6s ease-out;
}
@keyframes hopFlash {
  0% { box-shadow: inset 0 0 20px rgba(200,82,148,0.5); }
  100% { box-shadow: none; }
}

/* --- Mutation Overlay (Phase 5) --- */
.mutation-overlay {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: var(--bg-card);
  border-top: 1px solid var(--border);
  border-radius: 8px 8px 0 0;
  z-index: 50;
  padding: 12px;
}
.mutation-overlay .close-overlay {
  position: absolute;
  top: 8px;
  right: 8px;
  background: none;
  border: none;
  cursor: pointer;
  color: var(--text-muted);
  font-size: 14px;
}

/* --- Autopsy Card (Phase 5) --- */
.autopsy-card {
  padding: 12px 16px;
  border-radius: 8px;
  margin: 12px;
}
.autopsy-row {
  display: flex;
  justify-content: space-between;
  padding: 3px 0;
  font-size: 12px;
}

/* --- Notable Runs (Phase 5) --- */
.notable-runs {
  padding: 12px 16px;
  border-radius: 8px;
  margin-top: 16px;
}
.notable-run-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0;
  border-bottom: 1px solid rgba(128,128,128,0.1);
  font-size: 12px;
}
.notable-run-item:last-child { border-bottom: none; }
.view-run-btn {
  font-size: 10px;
  padding: 3px 8px;
  border-radius: 4px;
  border: 1px solid var(--border);
  background: var(--bg-card);
  cursor: pointer;
  color: var(--accent-primary);
  display: flex;
  align-items: center;
  gap: 3px;
  font-family: var(--font-body);
}
.view-run-btn:hover { background: var(--accent-primary); color: white; }
  </style>
</head>
<body>
  <div id="app">

    <!-- ======== SIDEBAR ======== -->
    <aside id="sidebar">
      <div class="sidebar-brand">
        <h1>Af<span>wah</span></h1>
        <p>Misinformation Cascade Sim</p>
      </div>

      <!-- Scenario -->
      <div class="sidebar-section">
        <div class="sidebar-section-title">Scenario</div>
        <div class="sidebar-field">
          <label><i class="ph ph-globe-simple"></i> Rumor Topic</label>
          <select id="sel-scenario" class="sidebar-select">
            <option value="celebrity" selected>Celebrity Scandal</option>
            <option value="financial">Financial Crisis</option>
            <option value="health">Health Scare</option>
            <option value="campus">Campus Rumor</option>
            <option value="custom">Custom Rumor</option>
          </select>
        </div>
        <div id="custom-rumor-panel" class="sidebar-field" style="display:none;">
          <label><i class="ph ph-pencil-simple"></i> Rumor Text</label>
          <textarea id="in-custom-text" class="sidebar-input" rows="2" placeholder="My professor is secretly a vampire" style="resize:vertical;min-height:40px;"></textarea>
          <label style="margin-top:8px;"><i class="ph ph-tag"></i> Short Label</label>
          <input id="in-custom-short" class="sidebar-input" type="text" placeholder="the vampire professor" maxlength="40">
          <label style="margin-top:8px;"><i class="ph ph-hash"></i> Topic Tag</label>
          <select id="sel-custom-tag" class="sidebar-select">
            <option value="celebrity">Celebrity</option>
            <option value="financial">Financial</option>
            <option value="health">Health</option>
            <option value="campus" selected>Campus</option>
          </select>
          <label style="margin-top:10px;"><i class="ph ph-heart"></i> Emotions</label>
          <div class="slider-row"><span class="emo-label">Fear</span><input type="range" id="sl-emo-fear" min="0" max="1" step="0.05" value="0.3"><span class="slider-value" id="sv-emo-fear">0.30</span></div>
          <div class="slider-row"><span class="emo-label">Outrage</span><input type="range" id="sl-emo-outrage" min="0" max="1" step="0.05" value="0.2"><span class="slider-value" id="sv-emo-outrage">0.20</span></div>
          <div class="slider-row"><span class="emo-label">Humor</span><input type="range" id="sl-emo-humor" min="0" max="1" step="0.05" value="0.3"><span class="slider-value" id="sv-emo-humor">0.30</span></div>
          <div class="slider-row"><span class="emo-label">Curiosity</span><input type="range" id="sl-emo-curiosity" min="0" max="1" step="0.05" value="0.7"><span class="slider-value" id="sv-emo-curiosity">0.70</span></div>
          <div class="slider-row"><span class="emo-label">Urgency</span><input type="range" id="sl-emo-urgency" min="0" max="1" step="0.05" value="0.5"><span class="slider-value" id="sv-emo-urgency">0.50</span></div>
        </div>
        <div class="sidebar-field">
          <label><i class="ph ph-broadcast"></i> Seed Platform</label>
          <select id="sel-platform" class="sidebar-select">
            <option value="twitter" selected>Twitter</option>
            <option value="whatsapp">WhatsApp</option>
            <option value="instagram">Instagram</option>
            <option value="reddit">Reddit</option>
          </select>
        </div>
        <div class="sidebar-field">
          <label><i class="ph ph-image"></i> Media Type</label>
          <select id="sel-media" class="sidebar-select">
            <option value="text" selected>Text</option>
            <option value="image">Image</option>
            <option value="video">Video</option>
            <option value="reel">Reel / Story</option>
          </select>
        </div>
        <div class="sidebar-field">
          <label><i class="ph ph-user"></i> Seed Persona</label>
          <select id="sel-persona" class="sidebar-select">
            <option value="random_person" selected>Random Person</option>
            <option value="news_channel">News Channel</option>
            <option value="blogger">Blogger</option>
            <option value="celebrity">Celebrity</option>
            <option value="anonymous_tip">Anonymous Tip</option>
          </select>
        </div>
      </div>

      <!-- Parameters -->
      <div class="sidebar-section">
        <div class="sidebar-section-title">Parameters</div>
        <div class="sidebar-field">
          <label>Trust Decay Rate</label>
          <div class="slider-row">
            <input type="range" id="sl-decay" min="0.80" max="0.99" step="0.01" value="0.90">
            <span class="slider-value" id="sv-decay">0.90</span>
          </div>
        </div>
        <div class="sidebar-field">
          <label>Bot Percentage</label>
          <div class="slider-row">
            <input type="range" id="sl-bots" min="0" max="0.20" step="0.01" value="0.07">
            <span class="slider-value" id="sv-bots">7%</span>
          </div>
        </div>
        <div class="sidebar-field">
          <label>Correction Delay (min)</label>
          <div class="slider-row">
            <input type="range" id="sl-correction" min="1" max="60" step="1" value="15">
            <span class="slider-value" id="sv-correction">15m</span>
          </div>
        </div>
        <div class="sidebar-field">
          <label>Echo Chambers</label>
          <div class="slider-row">
            <input type="range" id="sl-chambers" min="2" max="8" step="1" value="4">
            <span class="slider-value" id="sv-chambers">4</span>
          </div>
        </div>
        <div class="sidebar-field">
          <label>Network Size</label>
          <div class="slider-row">
            <input type="range" id="sl-size" min="100" max="1000" step="50" value="500">
            <span class="slider-value" id="sv-size">500</span>
          </div>
        </div>
        <div class="sidebar-field">
          <label>Seed (0 = random)</label>
          <div class="slider-row">
            <input type="number" id="in-seed" class="sidebar-input" value="42" min="0" max="99999" style="width:100%">
          </div>
        </div>
      </div>

      <!-- Actions -->
      <div class="sidebar-actions">
        <button class="btn-run" id="btn-run">
          <i class="ph-bold ph-play"></i> Run
        </button>
        <button class="btn-reset" id="btn-reset">
          <i class="ph-bold ph-arrow-counter-clockwise"></i> Reset
        </button>
      </div>
    </aside>

    <!-- ======== HEADER ======== -->
    <header id="header">
      <div class="logo">Af<span>wah</span></div>
      <div class="header-center">
        <button class="mode-tab active" id="tab-visual" data-mode="visual">
          <i class="ph-bold ph-graph"></i> Visual Mode
        </button>
        <button class="mode-tab" id="tab-mc" data-mode="mc">
          <i class="ph-bold ph-chart-bar"></i> Monte Carlo
        </button>
      </div>
      <div class="header-right">
        <div class="layout-toggle" id="layout-toggle">
          <button class="layout-btn active" data-layout="focus" title="Focus Mode"><i class="ph ph-frame-corners"></i></button>
          <button class="layout-btn" data-layout="compare" title="Compare Mode"><i class="ph ph-columns"></i></button>
          <button class="layout-btn" data-layout="overview" title="Overview Mode"><i class="ph ph-grid-four"></i></button>
          <button class="layout-btn" data-layout="enhanced" title="Enhanced Mode"><i class="ph ph-graph"></i></button>
        </div>
        <button id="theme-toggle" title="Toggle theme">
          <i class="ph ph-sun" id="theme-icon"></i>
        </button>
      </div>
    </header>

    <!-- ======== MAIN (Visual Mode) ======== -->
    <div id="main">
      <!-- Graph Panel -->
      <div id="graph-panel">
        <div class="graph-stats">
          <span class="graph-stat-pill" id="gs-believing">0% believing</span>
          <span class="graph-stat-pill" id="gs-corrected">0% corrected</span>
          <span class="graph-stat-pill" id="gs-r0">R0: --</span>
        </div>
        <div class="zoom-controls" id="zoom-controls">
          <button class="zoom-btn" id="zoom-in" title="Zoom In"><i class="ph ph-plus"></i></button>
          <button class="zoom-btn" id="zoom-out" title="Zoom Out"><i class="ph ph-minus"></i></button>
          <button class="zoom-btn" id="zoom-reset" title="Reset Zoom"><i class="ph ph-arrows-in"></i></button>
        </div>
        <svg id="main-graph"></svg>
      </div>

      <!-- Node Popup (Phase 5) -->
      <div id="node-popup" class="node-popup hidden">
        <div class="node-popup-header">
          <div class="node-popup-title">
            <i class="ph ph-user" id="np-icon"></i>
            <span id="np-title">Node #0</span>
            <span class="agent-type-badge" id="np-badge">Regular</span>
          </div>
          <button class="node-popup-close" id="np-close"><i class="ph ph-x"></i></button>
        </div>
        <div class="node-popup-body" id="np-body">
        </div>
      </div>

      <!-- Edge Tooltip (Phase 5) -->
      <div id="edge-tooltip" class="edge-tooltip hidden">
        <div class="edge-tooltip-header">
          <span class="edge-source" id="et-source">Node #0</span>
          <i class="ph ph-arrow-right"></i>
          <span class="edge-target" id="et-target">Node #0</span>
          <span class="edge-type-badge" id="et-badge">RUMOR</span>
        </div>
        <div class="edge-tooltip-message" id="et-message"></div>
        <div class="edge-tooltip-meta" id="et-meta"></div>
        <div class="edge-tooltip-details" id="et-details"></div>
      </div>

      <!-- Mutation Overlay (Phase 5) -->
      <div id="mutation-overlay" class="mutation-overlay hidden">
        <button class="close-overlay" id="mutation-close"><i class="ph ph-x"></i></button>
      </div>

      <!-- Overview Grid (Phase 5, hidden by default) -->
      <div id="overview-grid" class="overview-grid hidden">
        <div class="overview-cell" id="ov-twitter"><div class="overview-label">Twitter</div><canvas id="overview-twitter"></canvas><div class="overview-stats" id="ovs-twitter"></div></div>
        <div class="overview-cell" id="ov-whatsapp"><div class="overview-label">WhatsApp</div><canvas id="overview-whatsapp"></canvas><div class="overview-stats" id="ovs-whatsapp"></div></div>
        <div class="overview-cell" id="ov-instagram"><div class="overview-label">Instagram</div><canvas id="overview-instagram"></canvas><div class="overview-stats" id="ovs-instagram"></div></div>
        <div class="overview-cell" id="ov-reddit"><div class="overview-label">Reddit</div><canvas id="overview-reddit"></canvas><div class="overview-stats" id="ovs-reddit"></div></div>
      </div>

      <!-- Compare Mode Container (Phase 5) -->
      <div id="compare-container" class="compare-container hidden">
        <div class="compare-panel" id="compare-left">
          <div class="compare-panel-label">Network Graph</div>
        </div>
        <div class="compare-divider" id="compare-divider"></div>
        <div class="compare-panel" id="compare-right">
          <div class="compare-panel-label">Platform Comparison</div>
          <canvas id="compare-chart"></canvas>
        </div>
      </div>

      <!-- Right Panel -->
      <div id="right-panel">
        <div class="rp-tabs">
          <button class="rp-tab active" data-tab="feed"><i class="ph ph-rss"></i> Feed</button>
          <button class="rp-tab" data-tab="analytics"><i class="ph ph-chart-line-up"></i> Analytics</button>
          <button class="rp-tab" data-tab="concepts"><i class="ph ph-lightbulb"></i> Concepts</button>
        </div>
        <div class="rp-content">
          <!-- Feed Section -->
          <div class="rp-section active" id="sec-feed">
            <!-- Feed Filters (Phase 5) -->
            <div class="feed-filters" id="feed-filters">
              <button class="filter-btn active" data-filter="all">All</button>
              <button class="filter-btn" data-filter="rumor"><i class="ph ph-broadcast"></i> Rumor</button>
              <button class="filter-btn" data-filter="correction"><i class="ph ph-shield-check"></i> Corr.</button>
              <button class="filter-btn" data-filter="mutation"><i class="ph ph-dna"></i> Mut.</button>
              <button class="filter-btn" data-filter="hop"><i class="ph ph-shuffle"></i> Hops</button>
              <select class="filter-platform-select" id="feed-platform-filter">
                <option value="all">All Platforms</option>
                <option value="twitter">Twitter</option>
                <option value="whatsapp">WhatsApp</option>
                <option value="instagram">Instagram</option>
                <option value="reddit">Reddit</option>
              </select>
            </div>
            <div id="feed-container">
              <div class="feed-event major type-rumor" style="opacity:0.4; text-align:center; padding:32px;">
                <i class="ph ph-play-circle" style="font-size:32px; display:block; margin-bottom:8px;"></i>
                Run a simulation to see events
              </div>
            </div>
            <button id="feed-jump"><i class="ph-bold ph-arrow-down"></i> Jump to latest</button>
          </div>

          <!-- Analytics Section -->
          <div class="rp-section" id="sec-analytics">
            <div id="analytics-container">
              <div class="stats-bar">
                <div class="stat-card card-pink">
                  <div class="stat-value" id="stat-believing">--</div>
                  <div class="stat-label">Believing</div>
                </div>
                <div class="stat-card card-blue">
                  <div class="stat-value" id="stat-corrected">--</div>
                  <div class="stat-label">Corrected</div>
                </div>
                <div class="stat-card card-yellow">
                  <div class="stat-value" id="stat-silent">--</div>
                  <div class="stat-label">Silent</div>
                </div>
                <div class="stat-card card-lavender">
                  <div class="stat-value" id="stat-bots">--</div>
                  <div class="stat-label">Bot Activity</div>
                </div>
              </div>

              <div class="r0-display">
                <div class="r0-value" id="r0-value">--</div>
                <div>
                  <div class="r0-label" id="r0-label-title">Effective R0</div>
                  <div style="font-size:11px; color:var(--text-tertiary);" id="r0-label-sub">Reproduction number</div>
                </div>
              </div>

              <div class="chart-container">
                <h3>Spread Curve</h3>
                <canvas class="chart-canvas" id="chart-spread"></canvas>
              </div>
            </div>
          </div>

          <!-- Concepts Section -->
          <div class="rp-section" id="sec-concepts">
            <div id="concepts-container">
              <div class="concept-item"><i class="ph ph-timer"></i><span class="concept-label">Poisson Arrivals (lambda)</span><span class="concept-value" id="cv-poisson">--</span></div>
              <div class="concept-item"><i class="ph ph-hourglass-medium"></i><span class="concept-label">Exponential Service (mu)</span><span class="concept-value" id="cv-service">--</span></div>
              <div class="concept-item"><i class="ph ph-coin"></i><span class="concept-label">Bernoulli Share P(believe)</span><span class="concept-value" id="cv-bernoulli">--</span></div>
              <div class="concept-item"><i class="ph ph-trend-down"></i><span class="concept-label">Trust Decay (per exposure)</span><span class="concept-value" id="cv-decay">--</span></div>
              <div class="concept-item"><i class="ph ph-heart"></i><span class="concept-label">Emotional Impact (dot prod)</span><span class="concept-value" id="cv-emotion">--</span></div>
              <div class="concept-item"><i class="ph ph-users-three"></i><span class="concept-label">Confirmation Bias (align)</span><span class="concept-value" id="cv-bias">--</span></div>
              <div class="concept-item"><i class="ph ph-queue"></i><span class="concept-label">Queue Utilization (rho)</span><span class="concept-value" id="cv-queue">--</span></div>
              <div class="concept-item"><i class="ph ph-virus"></i><span class="concept-label">R0 (reproduction number)</span><span class="concept-value" id="cv-r0">--</span></div>
              <div class="concept-item"><i class="ph ph-shield-check"></i><span class="concept-label">Source Credibility</span><span class="concept-value" id="cv-cred">--</span></div>
              <div class="concept-item"><i class="ph ph-frame-corners"></i><span class="concept-label">Framing Bonus</span><span class="concept-value" id="cv-framing">--</span></div>
              <div class="concept-item"><i class="ph ph-battery-medium"></i><span class="concept-label">Attention Budget (mean)</span><span class="concept-value" id="cv-attention">--</span></div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- ======== MONTE CARLO DASHBOARD ======== -->
    <div id="mc-dashboard" class="retro-mc">
      <div class="mc-header">
        <h2>Monte Carlo Analysis</h2>
        <div class="mc-run-selector">
          <button class="mc-count-btn active" data-count="100">100</button>
          <button class="mc-count-btn" data-count="500">500</button>
          <button class="mc-count-btn" data-count="1000">1000</button>
          <button class="mc-count-btn" data-count="2500">2500</button>
          <button class="btn-mc-run" id="btn-mc-run">
            <i class="ph-bold ph-play"></i> Run Batch
          </button>
        </div>
      </div>

      <div class="mc-progress" id="mc-progress"></div>

      <div class="mc-stats">
        <div class="mc-stat-card card-pink">
          <div class="stat-value" id="mc-mean">--</div>
          <div class="stat-label">Mean Infection %</div>
        </div>
        <div class="mc-stat-card card-blue">
          <div class="stat-value" id="mc-ci">--</div>
          <div class="stat-label">95% CI</div>
        </div>
        <div class="mc-stat-card card-yellow">
          <div class="stat-value" id="mc-median">--</div>
          <div class="stat-label">Median</div>
        </div>
        <div class="mc-stat-card card-lavender">
          <div class="stat-value" id="mc-r0">--</div>
          <div class="stat-label">Mean R0</div>
        </div>
      </div>

      <div class="mc-charts">
        <div class="mc-chart-card">
          <h3>Infection Rate Distribution</h3>
          <p class="mc-chart-desc">Shows how final infection percentages are distributed across all simulation runs. Each bar represents a range of infection rates and how many runs fell into that bucket. The cyan and amber vertical markers show the mean and median &mdash; if these diverge significantly, the distribution is skewed, suggesting some runs behave very differently from others.</p>
          <canvas class="mc-chart-canvas" id="mc-chart-hist"></canvas>
        </div>
        <div class="mc-chart-card">
          <h3>Convergence Plot</h3>
          <p class="mc-chart-desc">Tracks how the cumulative mean infection rate stabilizes as more simulations are added. The pink line is the running average, and the shaded band is the 95% confidence interval. Watch the CI band narrow as runs increase &mdash; this is the Central Limit Theorem in action. The estimate is reliable when the band stops visibly shrinking.</p>
          <canvas class="mc-chart-canvas" id="mc-chart-convergence"></canvas>
        </div>
        <div class="mc-chart-card">
          <h3>Death Type Distribution</h3>
          <p class="mc-chart-desc">Breaks down how rumors "die" across all runs. Starved means the rumor ran out of susceptible nodes to infect. Corrected means fact-checkers neutralized it. Saturated means everyone who could be reached was already reached. The balance between starved and corrected reveals whether network structure or active intervention was more effective at stopping spread.</p>
          <canvas class="mc-chart-canvas" id="mc-chart-death"></canvas>
        </div>
        <div class="mc-chart-card">
          <h3>R0 Distribution</h3>
          <p class="mc-chart-desc">Displays the basic reproduction number (R0) across all runs as a smooth density curve. R0 measures how many new believers each believing node creates on average. Values above 1.0 indicate exponential growth potential. The cyan marker shows the mean R0 &mdash; the further right it sits, the more contagious the rumor was under these network conditions.</p>
          <canvas class="mc-chart-canvas" id="mc-chart-r0"></canvas>
        </div>
      </div>

      <div id="notable-runs" class="notable-runs hidden"></div>

      <div class="mc-concepts">
        <h3><i class="ph ph-graduation-cap"></i> Course Concepts</h3>
        <p><strong>Monte Carlo Estimation:</strong> By running the simulation N times with different random seeds, we estimate the true distribution of outcomes. Each run is an independent sample from the simulation's probability space.</p>
        <p style="margin-top:8px;"><strong>Confidence Interval:</strong> The 95% CI narrows as 1/sqrt(N). After 100 runs, CI width is ~0.2*sigma; after 1000 runs, ~0.06*sigma. Watch the convergence plot to see this in action.</p>
        <p style="margin-top:8px;"><strong>Convergence:</strong> The batch stops early if |mean_last50 - mean_cumulative| / std &lt; 0.02, meaning additional runs won't meaningfully change the estimate.</p>
      </div>
    </div>

    <!-- ======== TIMELINE BAR ======== -->
    <div id="timeline">
      <div class="transport-controls">
        <button class="transport-btn" id="btn-step" title="Step forward">
          <i class="ph-bold ph-skip-forward"></i>
        </button>
        <button class="transport-btn" id="btn-play" title="Play / Pause">
          <i class="ph-bold ph-play" id="play-icon"></i>
        </button>
        <button class="transport-btn" id="btn-stop" title="Stop">
          <i class="ph-bold ph-stop"></i>
        </button>
      </div>

      <div class="scrubber-wrap">
        <div class="timeline-markers" id="timeline-markers"></div>
        <input type="range" id="scrubber" min="0" max="1000" value="0" step="1">
      </div>

      <div class="speed-controls">
        <button class="speed-btn" data-speed="0.5">0.5x</button>
        <button class="speed-btn active" data-speed="1">1x</button>
        <button class="speed-btn" data-speed="2">2x</button>
        <button class="speed-btn" data-speed="5">5x</button>
        <button class="speed-btn" data-speed="10">10x</button>
      </div>

      <div class="time-display" id="time-display">0:00 / 0:00</div>
    </div>

  </div><!-- /app -->

  <!-- ======== JS SIMULATION ENGINE (Web Worker source) ======== -->
  <script type="text/js-worker" id="worker-source">
// ============================================================
// AFWAH SIMULATION ENGINE — JavaScript Port (Web Worker)
// Ported from simulation.py (Phase 2 complete engine)
// ============================================================

// ---- 2a. Seedable PRNG (Mulberry32) ----

class RNG {
  constructor(seed) {
    this._state = seed >>> 0 || 1;
  }
  _next() {
    let t = (this._state += 0x6D2B79F5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
  random() { return this._next(); }
  uniform(a, b) { return a + (b - a) * this._next(); }
  exponential(mu) { return -mu * Math.log(1 - this._next() + 1e-15); }
  normal(mu, sigma) {
    // Box-Muller
    const u1 = this._next() || 1e-15;
    const u2 = this._next();
    return mu + sigma * Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
  }
  beta(a, b) {
    // Johnk's algorithm for a,b >= 1
    if (a < 1 || b < 1) { a = Math.max(a, 1); b = Math.max(b, 1); }
    for (let i = 0; i < 200; i++) {
      const u = Math.pow(this._next(), 1 / a);
      const v = Math.pow(this._next(), 1 / b);
      if (u + v <= 1) return u / (u + v);
    }
    // Fallback: use gamma ratio
    const ga = this._gamma(a);
    const gb = this._gamma(b);
    return ga / (ga + gb + 1e-15);
  }
  _gamma(shape) {
    // Marsaglia & Tsang for shape >= 1
    if (shape < 1) return this._gamma(shape + 1) * Math.pow(this._next(), 1 / shape);
    const d = shape - 1/3;
    const c = 1 / Math.sqrt(9 * d);
    for (let i = 0; i < 200; i++) {
      let x, v;
      do {
        x = this.normal(0, 1);
        v = 1 + c * x;
      } while (v <= 0);
      v = v * v * v;
      const u = this._next();
      if (u < 1 - 0.0331 * x * x * x * x) return d * v;
      if (Math.log(u) < 0.5 * x * x + d * (1 - v + Math.log(v))) return d * v;
    }
    return d; // fallback
  }
  poisson(lambda) {
    const L = Math.exp(-lambda);
    let k = 0, p = 1;
    do { k++; p *= this._next(); } while (p > L);
    return k - 1;
  }
  choice(arr, weights) {
    if (!weights) return arr[Math.floor(this._next() * arr.length)];
    let total = 0;
    for (let i = 0; i < weights.length; i++) total += weights[i];
    let r = this._next() * total;
    for (let i = 0; i < weights.length; i++) {
      r -= weights[i];
      if (r <= 0) return arr[i];
    }
    return arr[arr.length - 1];
  }
  choiceIndex(n, weights) {
    if (!weights) return Math.floor(this._next() * n);
    let total = 0;
    for (let i = 0; i < weights.length; i++) total += weights[i];
    let r = this._next() * total;
    for (let i = 0; i < weights.length; i++) {
      r -= weights[i];
      if (r <= 0) return i;
    }
    return n - 1;
  }
  bernoulli(p) { return this._next() < p; }
  shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(this._next() * (i + 1));
      const tmp = arr[i]; arr[i] = arr[j]; arr[j] = tmp;
    }
    return arr;
  }
  integers(low, high) { return low + Math.floor(this._next() * (high - low)); }
  sample(arr, k) {
    const copy = arr.slice();
    this.shuffle(copy);
    return copy.slice(0, k);
  }
}

// ---- 2b. Enums & Constants ----

const AgentType = Object.freeze({ REGULAR:'regular', INFLUENCER:'influencer', FACT_CHECKER:'fact_checker', BOT:'bot', LURKER:'lurker' });
const NodeStatus = Object.freeze({ UNAWARE:'unaware', BELIEVING:'believing', SILENT_BELIEVER:'silent_believer', CORRECTED:'corrected', IMMUNE:'immune', REMOVED:'removed' });
const Platform = Object.freeze({ WHATSAPP:'whatsapp', TWITTER:'twitter', INSTAGRAM:'instagram', REDDIT:'reddit' });
const EventType = Object.freeze({
  SHARE_RUMOR:'share_rumor', GENERATE_CORRECTION:'generate_correction', SHARE_CORRECTION:'share_correction',
  ATTENTION_RECOVERY:'attention_recovery', CHECK_TERMINATION:'check_termination',
  WHATSAPP_SELF_CORRECTION:'whatsapp_self_correction', REDDIT_MOD_ACTION:'reddit_mod_action',
  STORY_EXPIRY_CHECK:'story_expiry_check', PLATFORM_HOP:'platform_hop',
  TWITTER_COMMUNITY_NOTE:'twitter_community_note', EMERGENCY_CORRECTION:'emergency_correction',
  SUPER_SPREADER_CHECK:'super_spreader_check', CRISIS_START:'crisis_start', CRISIS_END:'crisis_end',
  BOT_WAVE:'bot_wave', BOT_CREDIBILITY_TICK:'bot_credibility_tick'
});
const DeathType = Object.freeze({ STARVED:'starved', CORRECTED:'corrected', SATURATED:'saturated', MUTATED_AWAY:'mutated_away', TIME_DECAYED:'time_decayed', STILL_ALIVE:'still_alive' });
const SeedPersona = Object.freeze({ RANDOM_PERSON:'random_person', NEWS_CHANNEL:'news_channel', BLOGGER:'blogger', CELEBRITY:'celebrity', ANONYMOUS_TIP:'anonymous_tip' });
const RumorShape = Object.freeze({ BARE_FORWARD:'bare_forward', REACTION:'reaction', PERSONAL_FRAME:'personal_frame', ELABORATOR:'elaborator', SKEPTIC_SHARER:'skeptic_sharer' });
const CorrectionShape = Object.freeze({ DEBUNK:'debunk', RELAY:'relay', TOLD_YOU_SO:'told_you_so', RELUCTANT_WALKBACK:'reluctant_walkback' });

const RUMOR_FRAMING_MODIFIERS = { bare_forward:0.00, reaction:0.05, personal_frame:0.15, elaborator:0.10, skeptic_sharer:0.20 };
const CORRECTION_FRAMING_MODIFIERS = { debunk:0.15, relay:0.05, told_you_so:0.00, reluctant_walkback:0.10 };

const AGENT_TYPE_CONFIG = {
  regular:      { population_pct:0.60, threshold_dist:['uniform',0.4,0.8], connections:[5,15], service_time_modifier:1.0 },
  influencer:   { population_pct:0.05, threshold_dist:['uniform',0.2,0.5], connections:[100,500], service_time_modifier:0.4 },
  fact_checker:  { population_pct:0.03, threshold_dist:['fixed',0.95], connections:[50,200], service_time_modifier:3.0 },
  bot:          { population_pct:0.07, threshold_dist:['fixed',0.01], connections:[30,100], service_time_modifier:0.02 },
  lurker:       { population_pct:0.25, threshold_dist:['uniform',0.8,0.99], connections:[3,8], service_time_modifier:6.0 },
};

const PLATFORM_CONFIG = {
  twitter:   { topology:'barabasi_albert', arrival_rate:15.0, base_service_time:30.0, threshold_modifier:1.15, base_credibility:0.4, correction_speed_modifier:1.5, algorithmic_amplification:true, engagement_threshold_pct:0.10, engagement_window_min:5, forward_limit:null, story_decay:false, story_ttl:null, bot_detection_multiplier:1.5, edge_bidirectional:false },
  whatsapp:  { topology:'watts_strogatz', arrival_rate:2.0, base_service_time:600.0, threshold_modifier:0.85, base_credibility:0.7, correction_speed_modifier:0.5, algorithmic_amplification:false, engagement_threshold_pct:null, engagement_window_min:null, forward_limit:5, story_decay:false, story_ttl:null, bot_detection_multiplier:0.3, edge_bidirectional:true },
  instagram: { topology:'ring_lattice', arrival_rate:5.0, base_service_time:300.0, threshold_modifier:1.0, base_credibility:0.5, correction_speed_modifier:0.8, algorithmic_amplification:true, engagement_threshold_pct:0.23, engagement_window_min:10, forward_limit:null, story_decay:true, story_ttl:86400.0, bot_detection_multiplier:1.0, edge_bidirectional:true },
  reddit:    { topology:'stochastic_block', arrival_rate:8.0, base_service_time:120.0, threshold_modifier:1.0, base_credibility:0.5, correction_speed_modifier:1.3, algorithmic_amplification:false, engagement_threshold_pct:null, engagement_window_min:null, forward_limit:null, story_decay:false, story_ttl:null, bot_detection_multiplier:1.3, edge_bidirectional:true },
};

const PLATFORM_PREFERENCE = {
  regular:     { whatsapp:0.25, twitter:0.25, instagram:0.25, reddit:0.25 },
  influencer:  { whatsapp:0.1, twitter:0.4, instagram:0.3, reddit:0.2 },
  fact_checker: { whatsapp:0.15, twitter:0.4, instagram:0.15, reddit:0.3 },
  bot:         { whatsapp:0.1, twitter:0.5, instagram:0.1, reddit:0.3 },
  lurker:      { whatsapp:0.2, twitter:0.2, instagram:0.3, reddit:0.3 },
};

const MULTI_PLATFORM_DISTRIBUTION = { 1:0.45, 2:0.40, 3:0.13, 4:0.02 };

const PLATFORM_FIT_MATRIX = {
  whatsapp: [0.9, 0.7, 0.5, 0.3],
  twitter:  [1.0, 0.8, 0.6, 0.4],
  instagram:[0.3, 0.9, 0.7, 1.0],
  reddit:   [0.9, 0.6, 0.4, 0.2],
};

const MEDIA_TYPES = ['text','image','video','reel'];
const PLATFORM_DEFAULT_MEDIA = { twitter:'text', whatsapp:'text', instagram:'reel', reddit:'text' };

const RUMOR_SCENARIOS = {
  celebrity: { topic_tag:'celebrity', text:'Breaking: Celebrity hospitalized after collapse', shortText:'the celebrity scandal', emotions:{fear:0.4,outrage:0.2,humor:0.1,curiosity:0.8,urgency:0.6}, platform_affinity:{whatsapp:0.5,twitter:0.9,instagram:0.8,reddit:0.4} },
  financial: { topic_tag:'financial', text:'Major bank freezing all accounts immediately', shortText:'the bank crisis', emotions:{fear:0.9,outrage:0.5,humor:0.0,curiosity:0.3,urgency:1.0}, platform_affinity:{whatsapp:0.9,twitter:0.7,instagram:0.2,reddit:0.6} },
  health:    { topic_tag:'health', text:'New study reveals common food causes serious illness', shortText:'the health scare', emotions:{fear:0.6,outrage:0.2,humor:0.1,curiosity:0.5,urgency:0.4}, platform_affinity:{whatsapp:0.8,twitter:0.5,instagram:0.4,reddit:0.7} },
  campus:    { topic_tag:'campus', text:'University to cancel entire semester unexpectedly', shortText:'the campus rumor', emotions:{fear:0.0,outrage:0.0,humor:0.3,curiosity:0.7,urgency:0.5}, platform_affinity:{whatsapp:0.7,twitter:0.4,instagram:0.6,reddit:0.5} },
};

const SEED_PERSONA_CONFIG = {
  random_person:  { maps_to:'regular', credibility_modifier:1.0 },
  news_channel:   { maps_to:'influencer', credibility_modifier:2.5 },
  blogger:        { maps_to:'regular', credibility_modifier:1.3 },
  celebrity:      { maps_to:'influencer', credibility_modifier:1.8 },
  anonymous_tip:  { maps_to:'bot', credibility_modifier:0.7 },
};

const BASE_ACTIVITY_CURVE = [0.05,0.05,0.06,0.07,0.08,0.10,0.30,0.45,0.60,0.40,0.45,0.50,0.65,0.75,0.35,0.40,0.45,0.70,0.80,0.85,0.90,0.80,0.50,0.30];

const SENDER_TRUST_MODIFIERS = { influencer:2.0, strong_tie:1.5, regular:1.0, stranger:0.6, bot_detected:0.3, fact_checker_shares_rumor:3.0 };

const AGE_GROUP_DISTRIBUTION = { young:0.40, middle:0.35, older:0.25 };
const AGE_GROUP_DIGITAL_NATIVITY = { young:[7,3], middle:[5,5], older:[3,7] };
const AGE_GROUP_PLATFORM_BIAS = {
  young:  { twitter:0.30, instagram:0.40, reddit:0.20, whatsapp:0.10 },
  middle: { twitter:0.25, instagram:0.20, reddit:0.15, whatsapp:0.40 },
  older:  { twitter:0.10, instagram:0.10, reddit:0.05, whatsapp:0.75 },
};

const BOT_DETECTION_PLATFORM_MULT = { twitter:1.5, reddit:1.3, instagram:1.0, whatsapp:0.3 };

const CHECKPOINT_TIMES = [300,600,900,1800,2700,3600,7200,14400,28800,43200,86400,172800];

const BASE_RUMOR_ALIGNMENTS = {
  celebrity: [0.0, 0.5, 0.5, 0.3],
  financial: [0.3, 0.4, 0.6, 0.2],
  health:    [0.1, 0.2, 0.3, 0.3],
  campus:    [0.0, 0.5, 0.5, 0.5],
};

const WORLDVIEW_CLUSTER_PRESETS = [
  [0.7, 0.3, 0.6, 0.4],
  [-0.5, 0.8, 0.4, 0.7],
  [0.1, 0.2, 0.2, 0.1],
  [-0.3, 0.6, 0.8, 0.5],
  [0.5, 0.1, 0.1, 0.2],
  [0.0, 0.5, 0.5, 0.9],
];

// ---- 2c. Data Structures ----

function createNode(id) {
  return {
    id, agent_type: AgentType.REGULAR,
    credibility_threshold: 0.5, effective_threshold: 0.5,
    platform_connections: {}, platform_edge_weights: {},
    worldview_vector: [0,0,0,0],
    susceptibility: [0,0,0,0,0], original_susceptibility: [0,0,0,0,0],
    emotional_priming: [0,0,0,0,0], emotional_fatigue: [0,0,0,0,0],
    messages_processed_per_emotion: [0,0,0,0,0],
    literacy: { health:0.5, financial:0.5, political:0.5, celebrity:0.5, campus:0.5, tech:0.5 },
    platforms: [], echo_chamber_idx: 0,
    hop_tendency: 0.2, attention_budget: 1.0,
    active_hours_profile: BASE_ACTIVITY_CURVE.slice(),
    age_group: 'middle', digital_nativity: 0.5, bot_detection_intuition: 0.15,
    rewiring_events: 0, rumor_sources: {},
    bot_cluster_id: null, apparent_credibility: 0.3, shares_this_hour: 0, detected: false,
    status: NodeStatus.UNAWARE, times_exposed: 0, times_correction_seen: 0,
    infected_by: null, infected_at: null, infected_on_platform: null,
    downstream_infections: 0, rumor_version: 0,
  };
}

function createRumor(id) {
  return {
    id, version: id, parent_version: null,
    scenario: 'celebrity', media_type: 'text', content_quality: 0.5,
    emotions: [0,0,0,0,0], alignment_vector: [0,0,0,0],
    origin_platform: Platform.TWITTER, origin_node: 0, origin_time: 0,
    forward_count: 0, total_infections: 0,
    forwarded_tag: false, expiry_time: null, karma_score: 1,
    quarantined: false, removed_by_mod: false,
    mutation_chain: [id], mutation_distance: 0, virality_score: 0,
    _community_note: false,
  };
}

// ---- MinHeap Priority Queue ----

class MinHeap {
  constructor() { this.data = []; }
  get size() { return this.data.length; }
  push(item) {
    this.data.push(item);
    this._bubbleUp(this.data.length - 1);
  }
  pop() {
    if (this.data.length === 0) return null;
    const top = this.data[0];
    const last = this.data.pop();
    if (this.data.length > 0) { this.data[0] = last; this._sinkDown(0); }
    return top;
  }
  peek() { return this.data.length > 0 ? this.data[0] : null; }
  clear() { this.data.length = 0; }
  _bubbleUp(i) {
    while (i > 0) {
      const parent = (i - 1) >> 1;
      if (this.data[i].time >= this.data[parent].time) break;
      [this.data[i], this.data[parent]] = [this.data[parent], this.data[i]];
      i = parent;
    }
  }
  _sinkDown(i) {
    const n = this.data.length;
    while (true) {
      let smallest = i;
      const l = 2 * i + 1, r = 2 * i + 2;
      if (l < n && this.data[l].time < this.data[smallest].time) smallest = l;
      if (r < n && this.data[r].time < this.data[smallest].time) smallest = r;
      if (smallest === i) break;
      [this.data[i], this.data[smallest]] = [this.data[smallest], this.data[i]];
      i = smallest;
    }
  }
}

// Emotion vector helpers (5D: fear, outrage, humor, curiosity, urgency)
function emotionDot(a, b) {
  let s = 0;
  for (let i = 0; i < 5; i++) s += a[i] * b[i];
  return s;
}
function emotionMean(a) {
  let s = 0;
  for (let i = 0; i < 5; i++) s += a[i];
  return s / 5;
}
function vec4dist(a, b) {
  let s = 0;
  for (let i = 0; i < 4; i++) s += (a[i] - b[i]) * (a[i] - b[i]);
  return Math.sqrt(s);
}
function clamp(v, lo, hi) { return v < lo ? lo : v > hi ? hi : v; }

// ---- 2d. Network Generators (pure JS, no networkx) ----

function generateBarabasiAlbert(nodeIds, m, rng) {
  // Preferential attachment
  const n = nodeIds.length;
  const adj = {};
  for (const id of nodeIds) adj[id] = new Set();
  if (n <= m + 1) {
    // Complete graph for small n
    for (let i = 0; i < n; i++)
      for (let j = i + 1; j < n; j++) {
        adj[nodeIds[i]].add(nodeIds[j]);
        adj[nodeIds[j]].add(nodeIds[i]);
      }
    return adj;
  }
  // Start with complete graph of m+1 nodes
  for (let i = 0; i <= m; i++)
    for (let j = i + 1; j <= m; j++) {
      adj[nodeIds[i]].add(nodeIds[j]);
      adj[nodeIds[j]].add(nodeIds[i]);
    }
  // Degree array for preferential attachment
  const degrees = new Array(n).fill(0);
  for (let i = 0; i <= m; i++) degrees[i] = m;

  for (let i = m + 1; i < n; i++) {
    const newId = nodeIds[i];
    let totalDeg = 0;
    for (let j = 0; j < i; j++) totalDeg += degrees[j];
    if (totalDeg === 0) totalDeg = i; // fallback
    const targets = new Set();
    let attempts = 0;
    while (targets.size < m && attempts < m * 20) {
      attempts++;
      let r = rng.random() * totalDeg;
      for (let j = 0; j < i; j++) {
        r -= degrees[j] || 1;
        if (r <= 0) {
          if (!targets.has(j)) targets.add(j);
          break;
        }
      }
    }
    for (const t of targets) {
      adj[newId].add(nodeIds[t]);
      adj[nodeIds[t]].add(newId);
      degrees[t]++;
    }
    degrees[i] = targets.size;
  }
  return adj;
}

function generateWattsStrogatz(nodeIds, k, pRewire, rng) {
  const n = nodeIds.length;
  const adj = {};
  for (const id of nodeIds) adj[id] = new Set();
  if (n <= k) {
    for (let i = 0; i < n; i++)
      for (let j = i + 1; j < n; j++) {
        adj[nodeIds[i]].add(nodeIds[j]);
        adj[nodeIds[j]].add(nodeIds[i]);
      }
    return adj;
  }
  const halfK = Math.max(1, Math.floor(k / 2));
  // Ring lattice
  for (let i = 0; i < n; i++) {
    for (let j = 1; j <= halfK; j++) {
      const nb = (i + j) % n;
      adj[nodeIds[i]].add(nodeIds[nb]);
      adj[nodeIds[nb]].add(nodeIds[i]);
    }
  }
  // Rewire
  for (let i = 0; i < n; i++) {
    for (let j = 1; j <= halfK; j++) {
      if (rng.random() < pRewire) {
        const nb = (i + j) % n;
        // Remove old edge
        adj[nodeIds[i]].delete(nodeIds[nb]);
        adj[nodeIds[nb]].delete(nodeIds[i]);
        // Pick random new target
        let newTarget;
        let att = 0;
        do {
          newTarget = rng.integers(0, n);
          att++;
        } while ((newTarget === i || adj[nodeIds[i]].has(nodeIds[newTarget])) && att < 100);
        if (att < 100) {
          adj[nodeIds[i]].add(nodeIds[newTarget]);
          adj[nodeIds[newTarget]].add(nodeIds[i]);
        } else {
          // Restore old edge
          adj[nodeIds[i]].add(nodeIds[nb]);
          adj[nodeIds[nb]].add(nodeIds[i]);
        }
      }
    }
  }
  return adj;
}

function generateRingLattice(nodeIds, chamberAssign, numChambers, rng) {
  const n = nodeIds.length;
  const adj = {};
  for (const id of nodeIds) adj[id] = new Set();
  // Group by chamber
  const groups = {};
  for (const gid of nodeIds) {
    const c = chamberAssign[gid] || 0;
    if (!groups[c]) groups[c] = [];
    groups[c].push(gid);
  }
  const kNearest = 4;
  const pIntra = 0.15;
  const pBridge = 0.02;
  // Ring lattice within each cluster
  for (const cidx in groups) {
    const members = groups[cidx];
    const m = members.length;
    if (m <= 1) continue;
    const halfK = Math.max(1, Math.min(Math.floor(kNearest / 2), Math.floor((m - 1) / 2)));
    for (let i = 0; i < m; i++) {
      for (let j = 1; j <= halfK; j++) {
        const nb = members[(i + j) % m];
        adj[members[i]].add(nb);
        adj[nb].add(members[i]);
      }
    }
    // Intra-cluster random edges
    for (let i = 0; i < m; i++) {
      for (let j = i + 1; j < m; j++) {
        if (!adj[members[i]].has(members[j]) && rng.random() < pIntra) {
          adj[members[i]].add(members[j]);
          adj[members[j]].add(members[i]);
        }
      }
    }
  }
  // Inter-cluster bridges
  for (let i = 0; i < nodeIds.length; i++) {
    for (let j = i + 1; j < nodeIds.length; j++) {
      const a = nodeIds[i], b = nodeIds[j];
      if (chamberAssign[a] === chamberAssign[b]) continue;
      if (adj[a].has(b)) continue;
      if (rng.random() < pBridge) {
        adj[a].add(b);
        adj[b].add(a);
      }
    }
  }
  return adj;
}

function generateStochasticBlock(nodeIds, chamberAssign, numChambers, rng) {
  const n = nodeIds.length;
  const adj = {};
  for (const id of nodeIds) adj[id] = new Set();
  const pWithin = 0.12;
  const pBetween = 0.005;
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      const a = nodeIds[i], b = nodeIds[j];
      const p = (chamberAssign[a] === chamberAssign[b]) ? pWithin : pBetween;
      if (rng.random() < p) {
        adj[a].add(b);
        adj[b].add(a);
      }
    }
  }
  return adj;
}

function resolvePartitions(adj, nodeIds, rng) {
  // BFS to find components, bridge disconnected ones
  const visited = new Set();
  const components = [];
  for (const id of nodeIds) {
    if (visited.has(id)) continue;
    const comp = [];
    const queue = [id];
    visited.add(id);
    while (queue.length) {
      const cur = queue.shift();
      comp.push(cur);
      for (const nb of adj[cur]) {
        if (!visited.has(nb)) { visited.add(nb); queue.push(nb); }
      }
    }
    components.push(comp);
  }
  if (components.length <= 1) return;
  // Find largest component
  let mainIdx = 0;
  for (let i = 1; i < components.length; i++) {
    if (components[i].length > components[mainIdx].length) mainIdx = i;
  }
  const main = components[mainIdx];
  for (let i = 0; i < components.length; i++) {
    if (i === mainIdx) continue;
    const a = main[rng.integers(0, main.length)];
    const b = components[i][rng.integers(0, components[i].length)];
    adj[a].add(b);
    adj[b].add(a);
  }
}

function enforceConnectionCounts(adj, nodeIds, nodes, rng) {
  const platformNodes = nodeIds.length;
  // Sample target degree per node
  const targetDeg = {};
  for (const gid of nodeIds) {
    const cfg = AGENT_TYPE_CONFIG[nodes[gid].agent_type];
    const minC = cfg.connections[0];
    const maxC = Math.min(cfg.connections[1], platformNodes - 1);
    const effMin = Math.min(minC, maxC);
    targetDeg[gid] = rng.integers(effMin, maxC + 1);
  }
  // Pass 1: Add edges for under-connected
  const priority = [AgentType.INFLUENCER, AgentType.FACT_CHECKER, AgentType.BOT, AgentType.REGULAR, AgentType.LURKER];
  const nodeSet = new Set(nodeIds);
  for (const atype of priority) {
    for (const gid of nodeIds) {
      if (nodes[gid].agent_type !== atype) continue;
      const target = targetDeg[gid];
      let currentDeg = adj[gid].size;
      if (currentDeg < target) {
        const candidates = [];
        for (const cid of nodeSet) {
          if (cid !== gid && !adj[gid].has(cid)) candidates.push(cid);
        }
        rng.shuffle(candidates);
        const needed = Math.min(target - currentDeg, candidates.length);
        for (let i = 0; i < needed; i++) {
          adj[gid].add(candidates[i]);
          adj[candidates[i]].add(gid);
        }
      }
    }
  }
  // Pass 2: Prune over-connected
  for (const gid of nodeIds) {
    const cfg = AGENT_TYPE_CONFIG[nodes[gid].agent_type];
    const hardMax = Math.min(targetDeg[gid], cfg.connections[1], platformNodes - 1);
    if (adj[gid].size > hardMax) {
      let neighbors = Array.from(adj[gid]);
      rng.shuffle(neighbors);
      // Sort by excess descending
      neighbors.sort((a, b) => (adj[b].size - targetDeg[b]) - (adj[a].size - targetDeg[a]));
      let excess = adj[gid].size - hardMax;
      for (const nbr of neighbors) {
        if (excess <= 0) break;
        const nbrMin = AGENT_TYPE_CONFIG[nodes[nbr].agent_type].connections[0];
        if (adj[nbr].size <= nbrMin) continue;
        adj[gid].delete(nbr);
        adj[nbr].delete(gid);
        excess--;
      }
    }
    // Lurker hard cap
    if (nodes[gid].agent_type === AgentType.LURKER && adj[gid].size > cfg.connections[1]) {
      let neighbors = Array.from(adj[gid]);
      rng.shuffle(neighbors);
      for (const nbr of neighbors) {
        if (adj[gid].size <= cfg.connections[1]) break;
        adj[gid].delete(nbr);
        adj[nbr].delete(gid);
      }
    }
  }
}

function generatePlatformNetwork(platform, nodeIds, nodes, chamberAssign, numChambers, rng) {
  const topo = PLATFORM_CONFIG[platform].topology;
  let adj;
  if (topo === 'barabasi_albert') {
    adj = generateBarabasiAlbert(nodeIds, 3, rng);
  } else if (topo === 'watts_strogatz') {
    adj = generateWattsStrogatz(nodeIds, 6, 0.15, rng);
  } else if (topo === 'ring_lattice') {
    adj = generateRingLattice(nodeIds, chamberAssign, numChambers, rng);
  } else {
    adj = generateStochasticBlock(nodeIds, chamberAssign, numChambers, rng);
  }
  enforceConnectionCounts(adj, nodeIds, nodes, rng);
  resolvePartitions(adj, nodeIds, rng);
  return adj;
}

// ---- 2e. SimulationEngine Class ----

class SimulationEngine {
  constructor(config) {
    this.config = Object.assign({
      network_size: 500, num_echo_chambers: 4,
      active_platforms: [Platform.TWITTER, Platform.WHATSAPP, Platform.INSTAGRAM, Platform.REDDIT],
      seed_platform: Platform.TWITTER,
      scenario: 'celebrity', media_type: 'text',
      seed_persona: SeedPersona.RANDOM_PERSON,
      max_time: 172800, start_hour: 10, termination_check_interval: 60,
      decay_rate: 0.90, mutation_probability: 0.05,
      silent_believer_probability: 0.60, correction_fatigue_rate: 0.70,
      bias_strength: 0.4, emotion_weight: 0.15,
      attention_cost: 0.08, attention_recovery_rate: 0.04,
      master_seed: null, crisis_enabled: false,
    }, config);
    const seed = this.config.master_seed !== null ? this.config.master_seed : Date.now();
    this.rng = new RNG(seed);
    this.nodes = [];
    this.platformAdj = {};
    this.rumorVersions = {};
    this.currentTime = 0;
    this.eventQueue = new MinHeap();
    this.nextRumorId = 1;
    // Tracking
    this.eventLog = [];
    this.infectionTimeline = [];
    this.r0Timeline = [];
    // Termination
    this.r0BelowSince = null;
    this.r0Peak = 0;
    this.lastInfectionTime = 0;
    // Correction
    this.correctionActive = false;
    this.correctionSentTo = new Set();
    // Counters
    this.totalShares = 0;
    this.totalMutations = 0;
    this.totalPlatformHops = 0;
    this.recentSharesPerPlatform = {};
    this.totalSharesPerPlatform = {};
    for (const p of Object.values(Platform)) {
      this.recentSharesPerPlatform[p] = [];
      this.totalSharesPerPlatform[p] = 0;
    }
    this.modActionsPerMod = {};
    this.botsDetected = 0;
    this.rewiringEvents = 0;
    this.superSpreaderEvents = 0;
    this.crisisActive = false;
    this.crisisPreThresholds = {};
    this.botClusters = {};
    this.botWaveActive = {};
    this._lastSseTime = -9999;
    this._currentShareAmplified = false;
    this._ampCooldownUntil = {};
    for (const p of Object.values(Platform)) this._ampCooldownUntil[p] = 0;
    this._terminationTime = null;
    this.chamberAssign = {};
    this.chamberCenters = [];
    // Snapshot state
    this._snapshotInterval = 33; // ~30fps
    this._lastSnapshotTime = -999;
    // Phase 5: per-node event log for popup inbox
    this.nodeEventLog = {};
    // Phase 5: checkpoint system for timeline scrub
    this._checkpoints = new Map();
    this._checkpointInterval = 0.05;
    this._nextCheckpointPct = 0.05;
  }

  // Phase 5 Step 6: Checkpoint system for timeline scrub
  _deepCloneNode(n) {
    return {
      id: n.id, agent_type: n.agent_type, echo_chamber_idx: n.echo_chamber_idx,
      worldview_vector: n.worldview_vector.slice(),
      susceptibility: n.susceptibility.slice(), original_susceptibility: n.original_susceptibility.slice(),
      emotional_priming: n.emotional_priming.slice(), emotional_fatigue: n.emotional_fatigue.slice(),
      credibility_threshold: n.credibility_threshold, effective_threshold: n.effective_threshold,
      attention_budget: n.attention_budget, max_attention: n.attention_budget,
      status: n.status, times_exposed: n.times_exposed, times_correction_seen: n.times_correction_seen,
      infected_by: n.infected_by, infected_at: n.infected_at, infected_on_platform: n.infected_on_platform,
      downstream_infections: n.downstream_infections, rumor_version: n.rumor_version,
      age_group: n.age_group, digital_nativity: n.digital_nativity,
      platforms: n.platforms.slice(),
      rewiring_events: n.rewiring_events,
      rumor_sources: Object.assign({}, n.rumor_sources),
      bot_detection_intuition: n.bot_detection_intuition,
      literacy: Object.assign({}, n.literacy),
      karma: n.karma || 0, hop_tendency: n.hop_tendency || 0.2,
      detected: n.detected || false, apparent_credibility: n.apparent_credibility || 0.3,
    };
  }

  maybeStoreCheckpoint() {
    if (this._terminationTime !== null) return;
    const pct = this.currentTime / this.config.max_time;
    if (pct >= this._nextCheckpointPct) {
      // Store checkpoint: deep clone essential state
      const checkpoint = {
        time: this.currentTime,
        rngState: this.rng._state,
        nodeStates: this.nodes.map(n => this._deepCloneNode(n)),
        rumorVersions: JSON.parse(JSON.stringify(this.rumorVersions)),
        currentTime: this.currentTime,
        nextRumorId: this.nextRumorId,
        totalShares: this.totalShares, totalMutations: this.totalMutations,
        totalPlatformHops: this.totalPlatformHops,
        correctionActive: this.correctionActive,
        correctionSentTo: new Set(this.correctionSentTo),
        eventLogLength: this.eventLog.length,
        infectionTimelineLength: this.infectionTimeline.length,
        r0TimelineLength: this.r0Timeline.length,
        lastInfectionTime: this.lastInfectionTime,
        r0BelowSince: this.r0BelowSince, r0Peak: this.r0Peak,
        botsDetected: this.botsDetected, rewiringEvents: this.rewiringEvents,
        superSpreaderEvents: this.superSpreaderEvents,
        crisisActive: this.crisisActive,
        _terminationTime: this._terminationTime,
        _lastSseTime: this._lastSseTime,
        _ampCooldownUntil: Object.assign({}, this._ampCooldownUntil),
        recentSharesPerPlatform: JSON.parse(JSON.stringify(this.recentSharesPerPlatform)),
        totalSharesPerPlatform: Object.assign({}, this.totalSharesPerPlatform),
        eventQueueData: JSON.parse(JSON.stringify(this.eventQueue.data)),
      };
      this._checkpoints.set(Math.round(pct * 100), checkpoint);
      this._nextCheckpointPct += this._checkpointInterval;
      // Cap at 20 checkpoints
      if (this._checkpoints.size > 20) {
        const oldest = this._checkpoints.keys().next().value;
        this._checkpoints.delete(oldest);
      }
    }
  }

  restoreCheckpoint(checkpoint) {
    this.currentTime = checkpoint.currentTime;
    this.rng._state = checkpoint.rngState;
    this.nextRumorId = checkpoint.nextRumorId;
    this.totalShares = checkpoint.totalShares;
    this.totalMutations = checkpoint.totalMutations;
    this.totalPlatformHops = checkpoint.totalPlatformHops;
    this.correctionActive = checkpoint.correctionActive;
    this.correctionSentTo = new Set(checkpoint.correctionSentTo);
    this.lastInfectionTime = checkpoint.lastInfectionTime;
    this.r0BelowSince = checkpoint.r0BelowSince;
    this.r0Peak = checkpoint.r0Peak;
    this.botsDetected = checkpoint.botsDetected;
    this.rewiringEvents = checkpoint.rewiringEvents;
    this.superSpreaderEvents = checkpoint.superSpreaderEvents;
    this.crisisActive = checkpoint.crisisActive;
    this._terminationTime = checkpoint._terminationTime;
    this._lastSseTime = checkpoint._lastSseTime;
    this._ampCooldownUntil = Object.assign({}, checkpoint._ampCooldownUntil);
    this.recentSharesPerPlatform = JSON.parse(JSON.stringify(checkpoint.recentSharesPerPlatform));
    this.totalSharesPerPlatform = Object.assign({}, checkpoint.totalSharesPerPlatform);
    this.rumorVersions = JSON.parse(JSON.stringify(checkpoint.rumorVersions));
    // Restore node states
    for (let i = 0; i < this.nodes.length && i < checkpoint.nodeStates.length; i++) {
      const src = checkpoint.nodeStates[i];
      const dst = this.nodes[i];
      dst.status = src.status;
      dst.susceptibility = src.susceptibility.slice();
      dst.emotional_priming = src.emotional_priming.slice();
      dst.emotional_fatigue = src.emotional_fatigue.slice();
      dst.credibility_threshold = src.credibility_threshold;
      dst.effective_threshold = src.effective_threshold;
      dst.attention_budget = src.attention_budget;
      dst.times_exposed = src.times_exposed;
      dst.times_correction_seen = src.times_correction_seen;
      dst.infected_by = src.infected_by;
      dst.infected_at = src.infected_at;
      dst.infected_on_platform = src.infected_on_platform;
      dst.downstream_infections = src.downstream_infections;
      dst.rumor_version = src.rumor_version;
      dst.rewiring_events = src.rewiring_events;
      dst.rumor_sources = Object.assign({}, src.rumor_sources);
      dst.karma = src.karma || 0;
      dst.detected = src.detected || false;
      dst.hop_tendency = src.hop_tendency || 0.2;
    }
    // Restore event queue from checkpoint
    this.eventQueue.data = JSON.parse(JSON.stringify(checkpoint.eventQueueData));
    // Truncate logs to checkpoint length
    this.eventLog.length = checkpoint.eventLogLength;
    this.infectionTimeline.length = checkpoint.infectionTimelineLength;
    this.r0Timeline.length = checkpoint.r0TimelineLength;
    this.nodeEventLog = {};
  }

  setup() {
    this._generateAllNodes();
    this._generateAllNetworks();
    this._setupBotClusters();
    // Create seed rumor
    const seedRumor = this._createSeedRumor();
    this.rumorVersions[0] = seedRumor;
    if (this.config.seed_platform === Platform.REDDIT) seedRumor.karma_score = 3;
    // Select patient zero
    const p0 = this._selectPatientZero();
    seedRumor.origin_node = p0.id;
    p0.status = NodeStatus.BELIEVING;
    p0.infected_at = 0;
    p0.infected_on_platform = this.config.seed_platform;
    p0.rumor_version = 0;
    this.lastInfectionTime = 0;
    this._logEvent(0, 'rumor_seeded', p0.id, null, this.config.seed_platform, { scenario: this.config.scenario });
    // Schedule patient zero shares
    this._scheduleShares(p0, seedRumor, this.config.seed_platform, true, 0, 0);
    // Periodic events
    this._scheduleEvent(this.config.termination_check_interval, EventType.CHECK_TERMINATION, 0, {});
    this._scheduleEvent(3600, EventType.ATTENTION_RECOVERY, 0, {});
    this._scheduleEvent(60, EventType.SUPER_SPREADER_CHECK, 0, {});
    if (this.config.crisis_enabled) {
      const crisisTime = Math.min(this.rng.uniform(6*3600, 36*3600), this.config.max_time - 3600);
      const intensity = this.rng.uniform(0.3, 0.8);
      const duration = this.rng.exponential(4*3600);
      this._scheduleEvent(crisisTime, EventType.CRISIS_START, 0, { intensity, duration, crisis_topic: this.config.scenario });
    }
    this._scheduleEvent(3600, EventType.BOT_CREDIBILITY_TICK, 0, {});
  }

  _generateAllNodes() {
    const n = this.config.network_size;
    const nc = this.config.num_echo_chambers;
    // Chamber centers
    this.chamberCenters = [];
    for (let i = 0; i < nc; i++) {
      if (i < WORLDVIEW_CLUSTER_PRESETS.length) {
        this.chamberCenters.push(WORLDVIEW_CLUSTER_PRESETS[i].slice());
      } else {
        this.chamberCenters.push([this.rng.uniform(-1,1), this.rng.uniform(0,1), this.rng.uniform(0,1), this.rng.uniform(0,1)]);
      }
    }
    // Agent types — override bot pct from config if provided
    const overridePcts = {};
    if (this.config.bot_percentage !== undefined && this.config.bot_percentage !== null) {
      const botP = this.config.bot_percentage;
      overridePcts[AgentType.BOT] = botP;
      const origBot = AGENT_TYPE_CONFIG.bot.population_pct;
      const delta = origBot - botP;
      overridePcts[AgentType.REGULAR] = AGENT_TYPE_CONFIG.regular.population_pct + delta;
    }
    const types = [];
    for (const [atype, cfg] of Object.entries(AGENT_TYPE_CONFIG)) {
      const pct = overridePcts[atype] !== undefined ? overridePcts[atype] : cfg.population_pct;
      const count = Math.max(0, Math.floor(n * pct));
      for (let i = 0; i < count; i++) types.push(atype);
    }
    while (types.length < n) types.push(AgentType.REGULAR);
    this.rng.shuffle(types);
    // Age groups
    const agePool = [];
    for (const [ag, pct] of Object.entries(AGE_GROUP_DISTRIBUTION)) {
      const count = Math.floor(n * pct);
      for (let i = 0; i < count; i++) agePool.push(ag);
    }
    while (agePool.length < n) agePool.push('middle');
    this.rng.shuffle(agePool);
    // Create nodes
    this.nodes = [];
    for (let i = 0; i < n; i++) {
      const node = createNode(i);
      node.agent_type = types[i];
      const chamberIdx = this.rng.integers(0, nc);
      node.echo_chamber_idx = chamberIdx;
      this.chamberAssign[i] = chamberIdx;
      // Worldview near chamber center
      const center = this.chamberCenters[chamberIdx];
      node.worldview_vector = [
        clamp(this.rng.normal(center[0], 0.3), -1, 1),
        clamp(this.rng.normal(center[1], 0.3), 0, 1),
        clamp(this.rng.normal(center[2], 0.3), 0, 1),
        clamp(this.rng.normal(center[3], 0.3), 0, 1),
      ];
      // Threshold
      const cfg = AGENT_TYPE_CONFIG[node.agent_type];
      const dist = cfg.threshold_dist;
      node.credibility_threshold = dist[0] === 'fixed' ? dist[1] : this.rng.uniform(dist[1], dist[2]);
      node.effective_threshold = node.credibility_threshold;
      // Susceptibility (Beta(2,5) for each dim)
      for (let d = 0; d < 5; d++) {
        const v = this.rng.beta(2, 5);
        node.susceptibility[d] = v;
        node.original_susceptibility[d] = v;
      }
      // Literacy
      for (const topic of ['health','financial','political','tech']) node.literacy[topic] = this.rng.uniform(0.2, 0.9);
      for (const topic of ['celebrity','campus']) node.literacy[topic] = this.rng.uniform(0.3, 0.95);
      // Activity profile
      const shift = this.rng.integers(-3, 4);
      const profile = BASE_ACTIVITY_CURVE.slice();
      const shifted = profile.slice(shift).concat(profile.slice(0, shift));
      node.active_hours_profile = shifted.map(p => clamp(p + this.rng.normal(0, 0.05), 0.01, 1.0));
      // Demographics
      node.age_group = agePool[i];
      const [aDN, bDN] = AGE_GROUP_DIGITAL_NATIVITY[node.age_group];
      node.digital_nativity = this.rng.beta(aDN, bDN);
      node.bot_detection_intuition = node.digital_nativity * 0.3;
      // Topic susceptibility
      if (node.age_group === 'young' && node.digital_nativity > 0.6) {
        node.literacy.celebrity = Math.min(1, node.literacy.celebrity * 1.2);
        node.literacy.campus = Math.min(1, node.literacy.campus * 1.2);
      }
      if (node.age_group === 'older' && node.digital_nativity < 0.4) {
        node.literacy.health = Math.max(0, node.literacy.health * 0.8);
      }
      node.hop_tendency = this.rng.beta(2, 5);
      this.nodes.push(node);
    }
    // Multi-platform memberships
    this._assignPlatforms();
  }

  _assignPlatforms() {
    const ap = this.config.active_platforms;
    if (ap.length === 1) {
      for (const node of this.nodes) { node.platforms = [ap[0]]; }
      return;
    }
    const maxP = ap.length;
    const countProbs = [];
    let total = 0;
    for (let k = 1; k <= maxP; k++) {
      const p = MULTI_PLATFORM_DISTRIBUTION[k] || 0;
      countProbs.push(p);
      total += p;
    }
    for (let i = 0; i < countProbs.length; i++) countProbs[i] /= total;

    for (const node of this.nodes) {
      const numPlatforms = this.rng.choiceIndex(maxP, countProbs) + 1;
      const prefs = PLATFORM_PREFERENCE[node.agent_type] || PLATFORM_PREFERENCE.regular;
      const ageBias = AGE_GROUP_PLATFORM_BIAS[node.age_group] || AGE_GROUP_PLATFORM_BIAS.middle;
      const weights = ap.map(p => 0.5 * (prefs[p] || 0.25) + 0.5 * (ageBias[p] || 0.25));
      const wTotal = weights.reduce((s, w) => s + w, 0);
      for (let i = 0; i < weights.length; i++) weights[i] /= wTotal;
      // Sample without replacement
      const chosen = [];
      const available = ap.slice();
      const avWeights = weights.slice();
      for (let k = 0; k < Math.min(numPlatforms, ap.length); k++) {
        const idx = this.rng.choiceIndex(available.length, avWeights);
        chosen.push(available[idx]);
        available.splice(idx, 1);
        avWeights.splice(idx, 1);
        const wt = avWeights.reduce((s, w) => s + w, 0);
        if (wt > 0) for (let i = 0; i < avWeights.length; i++) avWeights[i] /= wt;
      }
      node.platforms = chosen;
    }
  }

  _generateAllNetworks() {
    for (const platform of this.config.active_platforms) {
      const nodeIds = this.nodes.filter(n => n.platforms.includes(platform)).map(n => n.id);
      if (nodeIds.length === 0) { this.platformAdj[platform] = {}; continue; }
      const platSeed = (this.config.master_seed || 42) + Object.values(Platform).indexOf(platform) + 1;
      const platRng = new RNG(platSeed);
      const adj = generatePlatformNetwork(platform, nodeIds, this.nodes, this.chamberAssign, this.config.num_echo_chambers, platRng);
      this.platformAdj[platform] = adj;
      // Wire connections into nodes
      for (const gid of nodeIds) {
        const neighbors = Array.from(adj[gid] || []);
        this.nodes[gid].platform_connections[platform] = neighbors;
        // Edge weights from worldview
        const weights = {};
        for (const nid of neighbors) {
          const wvDist = vec4dist(this.nodes[gid].worldview_vector, this.nodes[nid].worldview_vector);
          let strength = Math.max(0.1, 1.0 - wvDist / 4.0);
          if (this.chamberAssign[gid] === this.chamberAssign[nid]) strength = Math.min(0.99, strength * 1.3);
          strength = clamp(strength + this.rng.normal(0, 0.15), 0.05, 0.99);
          weights[nid] = strength;
        }
        this.nodes[gid].platform_edge_weights[platform] = weights;
      }
    }
  }

  _setupBotClusters() {
    const bots = this.nodes.filter(n => n.agent_type === AgentType.BOT);
    if (!bots.length) return;
    const numClusters = this.rng.integers(1, 4);
    for (const bot of bots) bot.bot_cluster_id = this.rng.integers(0, numClusters);
    this.botClusters = {};
    for (const bot of bots) {
      const c = bot.bot_cluster_id;
      if (!this.botClusters[c]) this.botClusters[c] = [];
      this.botClusters[c].push(bot.id);
    }
    for (const c in this.botClusters) this.botWaveActive[c] = false;
  }

  _createSeedRumor() {
    const sc = this.config.scenario === 'custom' && this.config.custom_rumor
      ? this.config.custom_rumor
      : RUMOR_SCENARIOS[this.config.scenario];
    const rumor = createRumor(0);
    rumor.scenario = this.config.scenario;
    rumor.media_type = this.config.media_type;
    rumor.content_quality = this.rng.uniform(0.3, 0.9);
    const emo = sc.emotions;
    rumor.emotions = [emo.fear, emo.outrage, emo.humor, emo.curiosity, emo.urgency];
    // Alignment
    const base = (BASE_RUMOR_ALIGNMENTS[this.config.scenario] || [0,0.5,0.5,0.5]).slice();
    for (let i = 0; i < 4; i++) base[i] = clamp(base[i] + this.rng.normal(0, 0.1), i === 0 ? -1 : 0, 1);
    rumor.alignment_vector = base;
    rumor.origin_platform = this.config.seed_platform;
    // Virality
    const mediaIdx = MEDIA_TYPES.indexOf(this.config.media_type);
    const pf = PLATFORM_FIT_MATRIX[this.config.seed_platform][mediaIdx];
    const ei = emotionMean(rumor.emotions);
    rumor.virality_score = clamp(rumor.content_quality * pf * (1 + ei * 0.3), 0, 5);
    rumor.mutation_chain = [0];
    return rumor;
  }

  _selectPatientZero() {
    const personaCfg = SEED_PERSONA_CONFIG[this.config.seed_persona];
    const targetType = personaCfg.maps_to;
    const sp = this.config.seed_platform;
    let pool = this.nodes.filter(n => n.agent_type === targetType && n.platforms.includes(sp) && n.agent_type !== AgentType.FACT_CHECKER);
    if (!pool.length) pool = this.nodes.filter(n => n.platforms.includes(sp) && n.agent_type !== AgentType.FACT_CHECKER);
    if (!pool.length) pool = this.nodes.filter(n => n.platforms.includes(sp));
    if (!pool.length) pool = this.nodes;
    // Filter to connected
    let connected = pool.filter(n => (n.platform_connections[sp] || []).length >= 3);
    if (!connected.length) connected = pool.filter(n => (n.platform_connections[sp] || []).length > 0);
    if (connected.length) pool = connected;
    // FC neighbor ratio filter
    if (pool.length > 1) {
      const good = pool.filter(n => {
        const nbrs = n.platform_connections[sp] || [];
        if (!nbrs.length) return false;
        const fcCount = nbrs.filter(nid => this.nodes[nid].agent_type === AgentType.FACT_CHECKER).length;
        return fcCount / nbrs.length < 0.3;
      });
      if (good.length) pool = good;
    }
    // Deterministic selection using persona seed
    const personaOffset = this.config.seed_persona.split('').reduce((s, c) => s + c.charCodeAt(0), 0);
    const pRng = new RNG((this.config.master_seed || 0) + personaOffset);
    return pool[pRng.integers(0, pool.length)];
  }

  // ---- Event scheduling ----

  _scheduleEvent(time, type, nodeId, data, platform) {
    this.eventQueue.push({ time, type, nodeId, data: data || {}, platform: platform || null });
  }

  _scheduleShares(sender, rumor, platform, isSeed, backfire, forwardDepth) {
    if (!platform) platform = this.config.seed_platform;
    const pCfg = PLATFORM_CONFIG[platform];
    const baseMu = pCfg.base_service_time;
    const agentMod = AGENT_TYPE_CONFIG[sender.agent_type].service_time_modifier;
    const effMu = baseMu * agentMod;
    const connections = sender.platform_connections[platform] || [];
    let credMod = 1.0;
    if (isSeed) credMod = SEED_PERSONA_CONFIG[this.config.seed_persona].credibility_modifier;
    for (const targetId of connections) {
      if (this.nodes[targetId].status === NodeStatus.REMOVED) continue;
      const edgeWeight = (sender.platform_edge_weights[platform] || {})[targetId] || 0.5;
      // Selective sharing: virality > (1 - edge_weight)
      if (rumor.virality_score < (1 - edgeWeight)) continue;
      const delay = this.rng.exponential(effMu);
      this._scheduleEvent(this.currentTime + delay, EventType.SHARE_RUMOR, targetId, {
        sender_id: sender.id, rumor_version: rumor.version,
        edge_weight: edgeWeight, credibility_modifier: credMod,
        backfire: backfire || 0, forward_depth: forwardDepth || 0,
        _retries: 0, _amplified: false,
      }, platform);
    }
  }

  // ---- Main event loop ----

  processEvents(batchSize) {
    let processed = 0;
    while (processed < batchSize && this.eventQueue.size > 0) {
      const event = this.eventQueue.peek();
      if (event.time > this.config.max_time) break;
      this.eventQueue.pop();
      this.currentTime = event.time;
      this._processEvent(event);
      processed++;
      // Phase 5: periodic checkpoint for timeline scrub
      this.maybeStoreCheckpoint();
    }
    return processed;
  }

  _processEvent(event) {
    switch (event.type) {
      case EventType.SHARE_RUMOR: this._handleShareRumor(event); break;
      case EventType.GENERATE_CORRECTION: this._handleGenerateCorrection(event); break;
      case EventType.SHARE_CORRECTION: this._handleShareCorrection(event); break;
      case EventType.ATTENTION_RECOVERY: this._handleAttentionRecovery(event); break;
      case EventType.CHECK_TERMINATION: this._handleCheckTermination(event); break;
      case EventType.WHATSAPP_SELF_CORRECTION: this._handleWhatsappSelfCorrection(event); break;
      case EventType.REDDIT_MOD_ACTION: this._handleRedditModAction(event); break;
      case EventType.PLATFORM_HOP: this._handlePlatformHop(event); break;
      case EventType.TWITTER_COMMUNITY_NOTE: this._handleCommunityNote(event); break;
      case EventType.SUPER_SPREADER_CHECK: this._handleSuperSpreaderCheck(event); break;
      case EventType.CRISIS_START: this._handleCrisisStart(event); break;
      case EventType.CRISIS_END: this._handleCrisisEnd(event); break;
      case EventType.BOT_WAVE: this._handleBotWave(event); break;
      case EventType.BOT_CREDIBILITY_TICK: this._handleBotCredTick(event); break;
    }
  }

  // ---- Core: Share Rumor Handler ----

  _handleShareRumor(event) {
    const target = this.nodes[event.nodeId];
    const data = event.data;
    const sender = this.nodes[data.sender_id];
    const rumorVersion = data.rumor_version;
    const edgeWeight = data.edge_weight;
    const credMod = data.credibility_modifier || 1.0;
    const backfire = data.backfire || 0;
    const forwardDepth = data.forward_depth || 0;
    const platform = event.platform || this.config.seed_platform;
    const rumor = this.rumorVersions[rumorVersion];
    if (!rumor) return;

    // Instagram story expiry
    if (platform === Platform.INSTAGRAM && rumor.expiry_time !== null) {
      if (this.currentTime > rumor.expiry_time) return;
      const storyTtl = PLATFORM_CONFIG.instagram.story_ttl;
      const remainingLife = (rumor.expiry_time - this.currentTime) / storyTtl;
      if (remainingLife < 0.25) {
        if (this.rng.random() > remainingLife / 0.25) return;
      }
    }
    // Reddit quarantine
    if (platform === Platform.REDDIT) {
      if (rumor.quarantined || rumor.removed_by_mod) return;
      if (rumor.karma_score < 0 && this.rng.random() > 0.1) return;
      if (rumor.karma_score >= 50) this._checkAlgoAmp(sender, rumor, Platform.REDDIT);
    }
    // Community note auto-correction
    if (platform === Platform.TWITTER && this.correctionActive && rumor._community_note) {
      if (this.rng.random() < 0.5) {
        if (target.status === NodeStatus.UNAWARE) {
          target.effective_threshold *= 1.2;
          target.credibility_threshold *= 1.2;
        }
        return;
      }
    }
    // Already processed
    if (target.status !== NodeStatus.UNAWARE) {
      this._updateEmotionalState(target, rumor);
      return;
    }
    // Time-of-day check
    const curHour = Math.floor((this.config.start_hour + this.currentTime / 3600) % 24);
    if (this.rng.random() > target.active_hours_profile[curHour]) {
      const retries = data._retries || 0;
      if (retries < 3) {
        const retryData = Object.assign({}, data, { _retries: retries + 1 });
        this._scheduleEvent(this.currentTime + this.rng.exponential(1800), EventType.SHARE_RUMOR, event.nodeId, retryData, platform);
      }
      return;
    }
    // Attention budget
    if (target.attention_budget < 0.5) {
      const pSkip = 1 - target.attention_budget / 0.5;
      if (this.rng.random() < pSkip) return;
    }
    target.attention_budget = Math.max(0, target.attention_budget - this.config.attention_cost);
    target.times_exposed++;
    this._updateEmotionalState(target, rumor);
    this._degradeLiteracy(target, rumor, sender, edgeWeight);

    // Compute effective threshold
    let effThresh = target.credibility_threshold;
    // Literacy boost
    const litTopic = rumor.scenario;
    const baseLit = target.literacy[litTopic] || 0.5;
    const litBoost = clamp(1.0 + (baseLit - 0.5) * 1.5, 0.5, 2.0);
    effThresh *= litBoost;
    // Platform threshold
    effThresh *= PLATFORM_CONFIG[platform].threshold_modifier;
    // WhatsApp forwarded depth penalty
    if (platform === Platform.WHATSAPP && forwardDepth >= 5) effThresh *= 1.3;
    // Platform affinity
    const scCfg = RUMOR_SCENARIOS[rumor.scenario] || {};
    const platAff = (scCfg.platform_affinity || {})[platform] || 0.5;
    effThresh *= (1 + (0.5 - platAff) * 0.5);
    // WhatsApp forwarded_tag
    if (platform === Platform.WHATSAPP && rumor.forwarded_tag) effThresh *= 1.3;

    if (target.agent_type === AgentType.FACT_CHECKER) {
      if (credMod !== 1) effThresh *= (1 / credMod);
      effThresh = clamp(effThresh, 0.85, 0.999);
    } else {
      // Trust decay
      effThresh *= Math.pow(this.config.decay_rate, target.times_exposed);
      // Confirmation bias
      const alignment = this._computeAlignment(target, rumor);
      const exposureScaling = Math.min(1, target.times_exposed / 3);
      effThresh *= (1 - alignment * this.config.bias_strength * exposureScaling);
      // Seed persona credibility
      if (credMod !== 1) effThresh *= (1 / credMod);
      // Backfire
      if (backfire > 0) effThresh *= (1 - backfire);
      // Literacy floor
      if (baseLit > 0.7) effThresh = Math.max(effThresh, baseLit * 0.4);
      effThresh = clamp(effThresh, 0.05, 0.999);
    }
    target.effective_threshold = effThresh;

    // Bernoulli share decision
    const sourceTrust = this._getSenderTrust(sender, edgeWeight, target);
    const emotionalImpact = emotionDot(rumor.emotions, target.susceptibility);
    let rumorCred = rumor.virality_score * (1 + emotionalImpact * this.config.emotion_weight) * (sourceTrust / 1.5);
    let believeProb;
    if (rumorCred > effThresh) {
      const excessRatio = Math.min(1, (rumorCred - effThresh) / Math.max(effThresh, 0.1));
      believeProb = 0.25 + 0.45 * excessRatio;
    } else {
      believeProb = (rumorCred / Math.max(effThresh, 0.01)) * 0.12;
    }
    believeProb = clamp(believeProb, 0.01, 0.90);
    // Framing modifier
    const rumorShape = this._selectRumorShape(sender, rumor, edgeWeight);
    believeProb *= (1 + RUMOR_FRAMING_MODIFIERS[rumorShape]);
    believeProb = Math.min(believeProb, 0.95);
    // Demographic sharing modifier
    believeProb *= (1 + 0.3 * (1 - target.digital_nativity));
    believeProb = Math.min(believeProb, 0.95);
    // Track rumor source for rewiring
    target.rumor_sources[data.sender_id] = (target.rumor_sources[data.sender_id] || 0) + 1;
    // Bot detection
    if (sender.agent_type === AgentType.BOT && !sender.detected) {
      this._checkBotDetection(sender, platform);
      if (sender.detected) return;
    }

    // Phase 5: compute values needed for node event log
    const alignment = (target.agent_type !== AgentType.FACT_CHECKER) ? this._computeAlignment(target, rumor) : 0;
    const _framingMod = RUMOR_FRAMING_MODIFIERS[rumorShape] || 0;
    const _believed = this.rng.random() < believeProb;

    // Phase 5: Log event for node popup inbox
    if (!this.nodeEventLog[target.id]) this.nodeEventLog[target.id] = [];
    this.nodeEventLog[target.id].push({
      time: this.currentTime, senderId: sender.id,
      edgeStrength: edgeWeight,
      rumor: { emotions: rumor.emotions.slice(), scenario: rumor.scenario, version: rumor.version, mediaType: rumor.media_type, contentQuality: rumor.content_quality },
      platform: platform, outcome: _believed ? 'believed' : 'rejected',
      thresholdAtTime: effThresh, confirmationBias: alignment * this.config.bias_strength,
      sourceTrust: sourceTrust, rumorCredibility: rumorCred,
      framingModifier: _framingMod, shapeName: rumorShape,
      effectiveThreshold: effThresh, effectiveCredibility: rumorCred * (1 + _framingMod),
      downstreamCount: 0, senderType: sender.agent_type
    });
    // Cap at 50 per node
    if (this.nodeEventLog[target.id].length > 50) this.nodeEventLog[target.id].shift();

    if (_believed) {
      this._currentShareAmplified = data._amplified || false;
      this._infectNode(target, sender, rumor, edgeWeight, platform, forwardDepth);
      if (platform === Platform.REDDIT) {
        rumor.karma_score++;
        this._checkRedditMod(rumor, platform);
      }
      // Seek mechanic
      if (emotionDot(rumor.emotions, target.susceptibility) > 0.7 && target.rewiring_events < 3) {
        if (this.rng.random() < 0.10) this._reactiveSeek(target, platform);
      }
    } else {
      if (platform === Platform.REDDIT) rumor.karma_score--;
      // Unfollow
      if ((target.rumor_sources[data.sender_id] || 0) >= 2 && target.rewiring_events < 3) {
        if (target.status === NodeStatus.CORRECTED || target.status === NodeStatus.UNAWARE) {
          if (this.rng.random() < 0.15) this._reactiveUnfollow(target, sender, platform);
        }
      }
      this._logEvent(this.currentTime, 'rumor_rejected', target.id, data.sender_id, platform, {});
      // FC correction
      if (target.agent_type === AgentType.FACT_CHECKER) {
        target.status = NodeStatus.IMMUNE;
        if (!this.correctionActive) {
          let fcMu = (this.config.correction_delay_minutes || 15) * 60;
          if (PLATFORM_CONFIG[platform].algorithmic_amplification) fcMu *= 0.5;
          if (this.crisisActive) fcMu *= 2;
          const corrDelay = this.rng.exponential(fcMu);
          this._scheduleEvent(this.currentTime + corrDelay, EventType.GENERATE_CORRECTION, target.id, { rumor_version: rumorVersion }, platform);
        } else {
          this._scheduleCorrectionShares(target, platform);
        }
      }
    }
  }

  _infectNode(target, sender, rumor, edgeWeight, platform, forwardDepth) {
    if (target.agent_type === AgentType.FACT_CHECKER) return;
    target.status = this.rng.random() < this.config.silent_believer_probability ? NodeStatus.SILENT_BELIEVER : NodeStatus.BELIEVING;
    target.infected_by = sender.id;
    target.infected_at = this.currentTime;
    target.infected_on_platform = platform;
    target.rumor_version = rumor.version;
    sender.downstream_infections++;
    rumor.total_infections++;
    this.lastInfectionTime = this.currentTime;
    this._logEvent(this.currentTime, 'node_infected', target.id, sender.id, platform, { status: target.status, rumor_version: rumor.version });
    this.infectionTimeline.push([this.currentTime, this._computeInfectionRate()]);

    if (target.status === NodeStatus.BELIEVING) {
      let curRumor = rumor;
      if (this.rng.random() < this.config.mutation_probability) {
        curRumor = this._mutateRumor(rumor, target, platform);
      }
      curRumor.forward_count++;
      const chainDepth = forwardDepth + 1;
      const isDeeplyForwarded = platform === Platform.WHATSAPP && curRumor.forward_count >= 5;
      if (isDeeplyForwarded && !curRumor.forwarded_tag) curRumor.forwarded_tag = true;
      // WhatsApp self-correction
      if (platform === Platform.WHATSAPP && isDeeplyForwarded && this.rng.random() < 0.05) {
        this._scheduleEvent(this.currentTime + this.rng.exponential(1800), EventType.WHATSAPP_SELF_CORRECTION, target.id, { rumor_version: curRumor.version }, platform);
      }
      // Instagram story TTL
      if (platform === Platform.INSTAGRAM && curRumor.expiry_time === null && (curRumor.media_type === 'reel' || curRumor.media_type === 'image')) {
        curRumor.expiry_time = this.currentTime + PLATFORM_CONFIG.instagram.story_ttl;
      }
      const bf = this._computeBackfire(target, curRumor);
      this._scheduleShares(target, curRumor, platform, false, bf, chainDepth);
      this.totalShares++;
      this.totalSharesPerPlatform[platform]++;
      if (!this._currentShareAmplified) {
        this.recentSharesPerPlatform[platform].push(this.currentTime);
        this._checkAlgoAmp(target, curRumor, platform);
      }
      // Platform hop
      if (target.platforms.length > 1 && this.config.active_platforms.length > 1) {
        this._checkPlatformHop(target, curRumor, platform);
      }
    }
  }

  // ---- Mutation ----

  _mutateRumor(parent, mutator, platform) {
    const newVer = this.nextRumorId++;
    this.totalMutations++;
    const newRumor = createRumor(newVer);
    newRumor.version = newVer;
    newRumor.parent_version = parent.version;
    newRumor.scenario = parent.scenario;
    newRumor.media_type = parent.media_type;
    newRumor.content_quality = clamp(parent.content_quality + this.rng.uniform(-0.1, 0.1), 0.1, 1);
    // Mutate emotions
    const newEmo = parent.emotions.slice();
    for (let i = 0; i < 5; i++) newEmo[i] = clamp(newEmo[i] + this.rng.uniform(-0.15, 0.15), 0, 1);
    newRumor.emotions = newEmo;
    // Mutate alignment
    const newAlign = parent.alignment_vector.slice();
    for (let i = 0; i < 4; i++) {
      newAlign[i] += this.rng.normal(0, 0.05);
      newAlign[i] = clamp(newAlign[i], i === 0 ? -1 : 0, 1);
    }
    newRumor.alignment_vector = newAlign;
    newRumor.origin_platform = platform;
    newRumor.origin_node = mutator.id;
    newRumor.origin_time = this.currentTime;
    newRumor.forward_count = 0;
    // Recompute virality
    const mediaIdx = MEDIA_TYPES.indexOf(parent.media_type);
    const pf = PLATFORM_FIT_MATRIX[platform][mediaIdx];
    newRumor.virality_score = clamp(newRumor.content_quality * pf * (1 + emotionMean(newEmo) * 0.3), 0, 5);
    // Mutation distance
    const origEmo = this.rumorVersions[0].emotions;
    let dist = 0;
    for (let i = 0; i < 5; i++) dist += (newEmo[i] - origEmo[i]) ** 2;
    newRumor.mutation_distance = Math.sqrt(dist);
    newRumor.mutation_chain = parent.mutation_chain.concat([newVer]);
    this.rumorVersions[newVer] = newRumor;
    this._logEvent(this.currentTime, 'mutation', mutator.id, null, platform, { parent_version: parent.version, new_version: newVer });
    return newRumor;
  }

  // ---- Correction handlers ----

  _handleGenerateCorrection(event) {
    const node = this.nodes[event.nodeId];
    if (node.agent_type !== AgentType.FACT_CHECKER || this.correctionActive) return;
    this.correctionActive = true;
    const platform = event.platform || this.config.seed_platform;
    this._logEvent(this.currentTime, 'correction_generated', node.id, null, platform, {});
    this._scheduleCorrectionShares(node, platform);
    // Community note trigger
    const twShares = this.totalSharesPerPlatform[Platform.TWITTER] || 0;
    if (this.config.active_platforms.includes(Platform.TWITTER) && twShares > 30) {
      if (this.rng.random() < 0.6) {
        this._scheduleEvent(this.currentTime + this.rng.exponential(7200), EventType.TWITTER_COMMUNITY_NOTE, node.id, { rumor_version: event.data.rumor_version || 0 }, Platform.TWITTER);
      }
    }
  }

  _scheduleCorrectionShares(source, platform) {
    const pCfg = PLATFORM_CONFIG[platform];
    const effMu = pCfg.base_service_time / pCfg.correction_speed_modifier;
    const conns = source.platform_connections[platform] || [];
    for (const tid of conns) {
      if (this.correctionSentTo.has(tid)) continue;
      const t = this.nodes[tid];
      if (t.status === NodeStatus.REMOVED || t.status === NodeStatus.CORRECTED) continue;
      this.correctionSentTo.add(tid);
      this._scheduleEvent(this.currentTime + this.rng.exponential(effMu), EventType.SHARE_CORRECTION, tid, { sender_id: source.id }, platform);
    }
  }

  _handleShareCorrection(event) {
    const target = this.nodes[event.nodeId];
    const senderId = event.data.sender_id;
    const platform = event.platform || this.config.seed_platform;
    if (target.status === NodeStatus.REMOVED) return;
    target.rumor_sources[senderId] = (target.rumor_sources[senderId] || 0) + 1;
    const curHour = Math.floor((this.config.start_hour + this.currentTime / 3600) % 24);
    if (this.rng.random() > target.active_hours_profile[curHour]) return;

    if (target.status === NodeStatus.BELIEVING || target.status === NodeStatus.SILENT_BELIEVER) {
      let fatigueRate = 0.7;
      const rumor = this.rumorVersions[target.rumor_version] || this.rumorVersions[0];
      if (rumor) {
        const alignment = this._computeAlignment(target, rumor);
        fatigueRate = alignment > 0.5 ? 0.5 : 0.7;
      }
      let effectiveness = 0.8 * Math.pow(fatigueRate, target.times_correction_seen);
      target.times_correction_seen++;
      // Correction framing
      const sender = this.nodes[senderId];
      const corrShape = this._selectCorrectionShape(sender);
      effectiveness *= (1 + CORRECTION_FRAMING_MODIFIERS[corrShape]);
      // Demographic receptivity
      effectiveness *= (0.5 + 0.5 * target.digital_nativity);
      effectiveness = Math.min(effectiveness, 0.95);
      if (this.rng.random() < effectiveness) {
        target.status = NodeStatus.CORRECTED;
        this._logEvent(this.currentTime, 'node_corrected', target.id, senderId, platform, {});
        // Unfollow prolific sources
        for (const [srcId, cnt] of Object.entries(target.rumor_sources)) {
          if (cnt >= 2 && target.rewiring_events < 3 && this.rng.random() < 0.15) {
            this._reactiveUnfollow(target, this.nodes[parseInt(srcId)], platform);
          }
        }
        if (this.rng.random() < 0.3) this._scheduleCorrectionShares(target, platform);
      }
    } else if (target.status === NodeStatus.UNAWARE) {
      // Pre-bunking
      const sender = this.nodes[senderId];
      const cq = sender.agent_type === AgentType.FACT_CHECKER ? 0.8 : 0.4;
      const preBunk = 0.1 + 0.15 * cq;
      target.effective_threshold *= (1 + preBunk);
      target.credibility_threshold *= (1 + preBunk);
    }
  }

  // ---- Attention recovery ----

  _handleAttentionRecovery(event) {
    const curHour = Math.floor((this.config.start_hour + this.currentTime / 3600) % 24);
    for (const node of this.nodes) {
      if (node.status === NodeStatus.REMOVED) continue;
      const activity = node.active_hours_profile[curHour];
      let recovery = this.config.attention_recovery_rate;
      if (activity < 0.2) recovery *= 1.5;
      else if (activity > 0.7) recovery *= 0.3;
      recovery *= node.attention_budget;
      node.attention_budget = Math.min(1, node.attention_budget + recovery);
      // Decay priming
      for (let d = 0; d < 5; d++) node.emotional_priming[d] *= 0.95;
    }
    this._scheduleEvent(this.currentTime + 3600, EventType.ATTENTION_RECOVERY, 0, {});
  }

  // ---- Termination ----

  _handleCheckTermination(event) {
    const [shouldTerminate, reason] = this._checkTermination();
    if (shouldTerminate) {
      this._terminationTime = this.currentTime;
      this.eventQueue.clear();
      this._logEvent(this.currentTime, 'termination', 0, null, null, { reason });
      return;
    }
    this._scheduleEvent(this.currentTime + this.config.termination_check_interval, EventType.CHECK_TERMINATION, 0, {});
  }

  _checkTermination() {
    if (this.currentTime >= this.config.max_time) return [true, 'max_time'];
    const infRate = this._computeInfectionRate();
    const r0 = this._computeR0();
    this.r0Timeline.push([this.currentTime, r0]);
    if (r0 > this.r0Peak) this.r0Peak = r0;
    // Rumor dead
    if (r0 < 0.1) {
      if (this.r0BelowSince === null) this.r0BelowSince = this.currentTime;
      else if (this.currentTime - this.r0BelowSince >= 1800 && this.currentTime - this.lastInfectionTime >= 3600) return [true, 'rumor_dead'];
    } else { this.r0BelowSince = null; }
    // Saturated
    let totalReached = 0;
    for (const n of this.nodes) if (n.status !== NodeStatus.UNAWARE) totalReached++;
    if (totalReached / this.nodes.length > 0.95) return [true, 'saturated'];
    // Corrected
    let believers = 0, corrected = 0;
    for (const n of this.nodes) {
      if (n.status === NodeStatus.BELIEVING || n.status === NodeStatus.SILENT_BELIEVER) believers++;
      if (n.status === NodeStatus.CORRECTED) corrected++;
    }
    if (believers + corrected > 0 && corrected / (believers + corrected) > 0.9) {
      const recent = this.infectionTimeline.filter(([t]) => t > this.currentTime - 3600).length;
      if (recent < this.config.network_size * 0.005) return [true, 'corrected'];
    }
    return [false, ''];
  }

  // ---- Platform-specific handlers ----

  _handleWhatsappSelfCorrection(event) {
    const t = this.nodes[event.nodeId];
    if (t.status !== NodeStatus.BELIEVING && t.status !== NodeStatus.SILENT_BELIEVER) return;
    if (this.rng.random() < 0.3) {
      t.status = NodeStatus.CORRECTED;
      this._logEvent(this.currentTime, 'whatsapp_self_correction', t.id, null, Platform.WHATSAPP, {});
    }
  }

  _handleRedditModAction(event) {
    const rv = event.data.rumor_version || 0;
    const rumor = this.rumorVersions[rv];
    if (!rumor || rumor.removed_by_mod || rumor.quarantined) return;
    const roll = this.rng.random();
    if (roll < 0.60) { rumor.removed_by_mod = true; rumor.karma_score = -999; this._logEvent(this.currentTime, 'reddit_mod_remove', event.nodeId, null, Platform.REDDIT, {}); }
    else if (roll < 0.90) { this._scheduleCorrectionShares(this.nodes[event.nodeId], Platform.REDDIT); this._logEvent(this.currentTime, 'reddit_mod_pin_correction', event.nodeId, null, Platform.REDDIT, {}); }
    else { rumor.quarantined = true; this._logEvent(this.currentTime, 'reddit_mod_quarantine', event.nodeId, null, Platform.REDDIT, {}); }
  }

  _checkRedditMod(rumor, platform) {
    if (platform !== Platform.REDDIT || rumor.removed_by_mod || rumor.quarantined) return;
    const pDetect = Math.min(1, Math.abs(rumor.karma_score) / 100);
    if (this.rng.random() > pDetect) return;
    const mods = this.nodes.filter(n => n.agent_type === AgentType.FACT_CHECKER && n.platforms.includes(Platform.REDDIT));
    if (!mods.length) return;
    const mod = mods[this.rng.integers(0, mods.length)];
    let delay = this.rng.exponential(1800);
    if (!this.modActionsPerMod[mod.id]) this.modActionsPerMod[mod.id] = [];
    const recent = this.modActionsPerMod[mod.id].filter(t => this.currentTime - t < 3600);
    this.modActionsPerMod[mod.id] = recent;
    if (recent.length >= 5) delay *= 2;
    recent.push(this.currentTime);
    this._scheduleEvent(this.currentTime + delay, EventType.REDDIT_MOD_ACTION, mod.id, { rumor_version: rumor.version }, Platform.REDDIT);
  }

  _handlePlatformHop(event) {
    const node = this.nodes[event.nodeId];
    const rv = event.data.rumor_version;
    const destPlatform = event.data.dest_platform;
    const rumor = this.rumorVersions[rv];
    if (!rumor) return;
    if (node.status !== NodeStatus.BELIEVING && node.status !== NodeStatus.SILENT_BELIEVER) return;
    if (!node.platforms.includes(destPlatform)) return;
    this.totalPlatformHops++;
    this._logEvent(this.currentTime, 'platform_hop', node.id, null, destPlatform, { source_platform: event.data.source_platform, dest_platform: destPlatform });
    this._scheduleShares(node, rumor, destPlatform, false, 0, 0);
    // Correction follow (15%)
    if (this.correctionActive) {
      const srcPlat = event.data.source_platform;
      const hasBridge = this.nodes.some(n => n.status === NodeStatus.CORRECTED && n.platforms.includes(srcPlat) && n.platforms.includes(destPlatform) && n.id !== node.id);
      if (hasBridge && this.rng.random() < 0.15) {
        const corrSrc = this.nodes.find(n => n.status === NodeStatus.CORRECTED && n.platforms.includes(destPlatform));
        const infectedOnDest = this.nodes.filter(n => (n.status === NodeStatus.BELIEVING || n.status === NodeStatus.SILENT_BELIEVER) && n.platforms.includes(destPlatform));
        if (corrSrc && infectedOnDest.length > 0) {
          const target = infectedOnDest[this.rng.integers(0, infectedOnDest.length)];
          this._scheduleEvent(this.currentTime + this.rng.exponential(3600), EventType.SHARE_CORRECTION, target.id, { sender_id: corrSrc.id }, destPlatform);
        }
      }
    }
  }

  _checkPlatformHop(node, rumor, srcPlatform) {
    const emoCharge = emotionMean(rumor.emotions);
    let hopProb = 0.5 * rumor.virality_score * emoCharge * node.hop_tendency;
    if (srcPlatform === Platform.INSTAGRAM && rumor.expiry_time !== null && rumor.expiry_time > this.currentTime) {
      const remainingLife = (rumor.expiry_time - this.currentTime) / PLATFORM_CONFIG.instagram.story_ttl;
      if (remainingLife < 1) hopProb *= (1 + (1 - remainingLife) * 0.5);
    }
    hopProb = Math.min(0.4, hopProb);
    if (this.rng.random() >= hopProb) return;
    const otherPlats = node.platforms.filter(p => p !== srcPlatform && this.config.active_platforms.includes(p));
    if (!otherPlats.length) return;
    const sc = RUMOR_SCENARIOS[rumor.scenario] || {};
    const affinities = sc.platform_affinity || {};
    const weights = otherPlats.map(p => {
      const mi = MEDIA_TYPES.indexOf(rumor.media_type);
      return PLATFORM_FIT_MATRIX[p][mi] * (affinities[p] || 0.5);
    });
    const wTotal = weights.reduce((s, w) => s + w, 0);
    if (wTotal <= 0) return;
    for (let i = 0; i < weights.length; i++) weights[i] /= wTotal;
    const destIdx = this.rng.choiceIndex(otherPlats.length, weights);
    const dest = otherPlats[destIdx];
    this._scheduleEvent(this.currentTime + this.rng.exponential(300), EventType.PLATFORM_HOP, node.id, { rumor_version: rumor.version, source_platform: srcPlatform, dest_platform: dest }, dest);
  }

  _handleCommunityNote(event) {
    const rv = event.data.rumor_version || 0;
    const rumor = this.rumorVersions[rv];
    if (rumor) rumor._community_note = true;
    this._logEvent(this.currentTime, 'twitter_community_note', event.nodeId, null, Platform.TWITTER, {});
  }

  // ---- Algorithmic Amplification ----

  _checkAlgoAmp(sharer, rumor, platform) {
    const pCfg = PLATFORM_CONFIG[platform];
    if (!pCfg.algorithmic_amplification) return;
    if (this.currentTime < (this._ampCooldownUntil[platform] || 0)) return;
    if (!pCfg.engagement_threshold_pct || !pCfg.engagement_window_min) return;
    const windowSec = pCfg.engagement_window_min * 60;
    const cutoff = this.currentTime - windowSec;
    const shares = this.recentSharesPerPlatform[platform];
    while (shares.length && shares[0] < cutoff) shares.shift();
    const nodesOnPlat = this.nodes.filter(n => n.platforms.includes(platform)).length;
    const threshold = Math.max(5, Math.floor(nodesOnPlat * pCfg.engagement_threshold_pct));
    if (shares.length <= threshold) return;
    const boostMult = this.rng.uniform(3, 5);
    const boostDur = this.rng.exponential(1800);
    this._ampCooldownUntil[platform] = this.currentTime + boostDur;
    const sharerConns = new Set(sharer.platform_connections[platform] || []);
    const unaware = this.nodes.filter(n => n.status === NodeStatus.UNAWARE && n.platforms.includes(platform) && !sharerConns.has(n.id));
    let boostCount = Math.min(Math.floor(sharerConns.size * boostMult), unaware.length);
    if (boostCount > 0) {
      const targets = this.rng.sample(unaware, boostCount);
      for (const t of targets) {
        this._scheduleEvent(this.currentTime + this.rng.exponential(boostDur / Math.max(boostCount, 1)), EventType.SHARE_RUMOR, t.id, { sender_id: sharer.id, rumor_version: rumor.version, edge_weight: 0.1, credibility_modifier: 1, _amplified: true }, platform);
      }
      this._logEvent(this.currentTime, 'algorithmic_amplification', sharer.id, null, platform, { boost_count: boostCount });
    }
  }

  // ---- Super Spreader ----

  _handleSuperSpreaderCheck(event) {
    if (this.currentTime - this._lastSseTime <= 1800) {
      if (this.currentTime + 60 < this.config.max_time) this._scheduleEvent(this.currentTime + 60, EventType.SUPER_SPREADER_CHECK, 0, {});
      return;
    }
    // Check 4 triggers
    const cutoff5 = this.currentTime - 300;
    let totalRecent = 0;
    for (const p of this.config.active_platforms) totalRecent += this.recentSharesPerPlatform[p].filter(t => t > cutoff5).length;
    if (totalRecent > this.config.network_size * 0.10) {
      this._lastSseTime = this.currentTime;
      this._triggerSuperSpreader('engagement', totalRecent);
    } else {
      // Influencer trigger
      const infCutoff = this.currentTime - 60;
      const recentInf = this.eventLog.slice(-200).filter(e => e.type === 'node_infected' && e.time > infCutoff && this.nodes[e.nodeId].agent_type === AgentType.INFLUENCER).length;
      if (recentInf > 0) { this._lastSseTime = this.currentTime; this._triggerSuperSpreader('influencer', recentInf); }
    }
    if (this.currentTime + 60 < this.config.max_time) this._scheduleEvent(this.currentTime + 60, EventType.SUPER_SPREADER_CHECK, 0, {});
  }

  _triggerSuperSpreader(triggerType, count) {
    this.superSpreaderEvents++;
    this._logEvent(this.currentTime, 'super_spreader_event', 0, null, null, { trigger_type: triggerType });
    const rumor = this.rumorVersions[0];
    if (!rumor) return;
    const believers = this.nodes.filter(n => n.status === NodeStatus.BELIEVING);
    const numExtra = Math.min(Math.floor(count * 0.1), believers.length);
    if (numExtra > 0) {
      const extra = this.rng.sample(believers, numExtra);
      for (const s of extra) {
        for (const plat of s.platforms) {
          if (this.config.active_platforms.includes(plat)) this._scheduleShares(s, rumor, plat, false, 0, 0);
        }
      }
    }
  }

  // ---- Crisis ----

  _handleCrisisStart(event) {
    this.crisisActive = true;
    const intensity = event.data.intensity || 0.5;
    const duration = event.data.duration || 14400;
    for (const node of this.nodes) {
      this.crisisPreThresholds[node.id] = node.credibility_threshold;
      const mod = 1 + intensity;
      node.credibility_threshold *= (1 - mod * 0.3);
      node.effective_threshold *= (1 - mod * 0.3);
      node.credibility_threshold = Math.max(0.05, node.credibility_threshold);
      node.effective_threshold = Math.max(0.05, node.effective_threshold);
      node.susceptibility[0] = Math.min(1, node.susceptibility[0] + 0.2); // fear
      node.susceptibility[4] = Math.min(1, node.susceptibility[4] + 0.2); // urgency
      if (node.age_group === 'middle') node.literacy.financial = Math.max(0, node.literacy.financial * 0.85);
    }
    this._logEvent(this.currentTime, 'crisis_start', 0, null, null, { intensity, duration });
    this._scheduleEvent(this.currentTime + duration, EventType.CRISIS_END, 0, { intensity });
  }

  _handleCrisisEnd(event) {
    this.crisisActive = false;
    for (const node of this.nodes) {
      const pre = this.crisisPreThresholds[node.id];
      if (pre !== undefined) {
        const recovery = Math.min(1, this.rng.exponential(0.5));
        node.credibility_threshold += (pre - node.credibility_threshold) * recovery;
        node.effective_threshold = node.credibility_threshold;
      }
      node.susceptibility[0] = Math.max(node.original_susceptibility[0], node.susceptibility[0] - 0.15);
      node.susceptibility[4] = Math.max(node.original_susceptibility[4], node.susceptibility[4] - 0.15);
    }
    this._logEvent(this.currentTime, 'crisis_end', 0, null, null, {});
  }

  // ---- Bot handlers ----

  _checkBotDetection(bot, platform) {
    bot.shares_this_hour++;
    let rate = 0.008;
    if (bot.shares_this_hour > 20) rate *= 15;
    else if (bot.shares_this_hour > 10) rate *= 5;
    rate *= (BOT_DETECTION_PLATFORM_MULT[platform] || 1);
    if (bot.bot_cluster_id !== null) {
      const cluster = this.botClusters[bot.bot_cluster_id] || [];
      const recentCluster = cluster.filter(bid => { const b = this.nodes[bid]; return b.id !== bot.id && b.infected_at !== null && Math.abs(this.currentTime - b.infected_at) < 60; }).length;
      if (recentCluster >= 2) rate *= 2;
    }
    if (this.rng.random() < rate) {
      bot.detected = true;
      bot.status = NodeStatus.REMOVED;
      this.botsDetected++;
      for (const plat of bot.platforms) {
        bot.platform_connections[plat] = [];
        bot.platform_edge_weights[plat] = {};
      }
      this._logEvent(this.currentTime, 'bot_detected', bot.id, null, platform, {});
    }
  }

  _handleBotWave(event) { /* skeleton — dead code per MEMORY.md */ }

  _handleBotCredTick(event) {
    for (const node of this.nodes) {
      if (node.agent_type === AgentType.BOT && !node.detected) {
        node.apparent_credibility = Math.min(0.6, node.apparent_credibility + 0.05);
        node.shares_this_hour = 0;
      }
    }
    if (this.currentTime + 3600 < this.config.max_time) this._scheduleEvent(this.currentTime + 3600, EventType.BOT_CREDIBILITY_TICK, 0, {});
  }

  // ---- Rewiring ----

  _reactiveUnfollow(node, source, platform) {
    const conns = node.platform_connections[platform];
    if (!conns) return;
    const idx = conns.indexOf(source.id);
    if (idx === -1) return;
    conns.splice(idx, 1);
    if (PLATFORM_CONFIG[platform].edge_bidirectional) {
      const srcConns = source.platform_connections[platform];
      if (srcConns) { const si = srcConns.indexOf(node.id); if (si !== -1) srcConns.splice(si, 1); }
    }
    node.rewiring_events++;
    this.rewiringEvents++;
    this._logEvent(this.currentTime, 'unfollow', node.id, source.id, platform, {});
  }

  _reactiveSeek(node, platform) {
    const chamber = node.echo_chamber_idx;
    const candidates = this.nodes.filter(n => n.echo_chamber_idx === chamber && n.id !== node.id && !(node.platform_connections[platform] || []).includes(n.id) && n.platforms.includes(platform));
    if (!candidates.length) return;
    const numNew = Math.min(this.rng.integers(1, 3), candidates.length);
    const targets = this.rng.sample(candidates, numNew);
    for (const t of targets) {
      const strength = this.rng.uniform(0.2, 0.4);
      if (!node.platform_connections[platform]) node.platform_connections[platform] = [];
      node.platform_connections[platform].push(t.id);
      if (!node.platform_edge_weights[platform]) node.platform_edge_weights[platform] = {};
      node.platform_edge_weights[platform][t.id] = strength;
      if (PLATFORM_CONFIG[platform].edge_bidirectional) {
        if (!t.platform_connections[platform]) t.platform_connections[platform] = [];
        t.platform_connections[platform].push(node.id);
        if (!t.platform_edge_weights[platform]) t.platform_edge_weights[platform] = {};
        t.platform_edge_weights[platform][node.id] = strength;
      }
      this._logEvent(this.currentTime, 'seek_connection', node.id, t.id, platform, {});
    }
    node.rewiring_events++;
    this.rewiringEvents++;
  }

  // ---- Computation helpers ----

  _computeAlignment(node, rumor) {
    const d = vec4dist(node.worldview_vector, rumor.alignment_vector);
    return clamp(1 - d / 4.0, 0, 1);
  }

  _getSenderTrust(sender, edgeWeight, receiver) {
    if (sender.agent_type === AgentType.BOT) {
      let base = sender.apparent_credibility;
      if (receiver && this.rng.random() < receiver.bot_detection_intuition) base = SENDER_TRUST_MODIFIERS.bot_detected;
      return base;
    }
    if (sender.agent_type === AgentType.INFLUENCER) return SENDER_TRUST_MODIFIERS.influencer;
    if (sender.agent_type === AgentType.FACT_CHECKER) return SENDER_TRUST_MODIFIERS.fact_checker_shares_rumor;
    if (edgeWeight > 0.7) return SENDER_TRUST_MODIFIERS.strong_tie;
    if (edgeWeight < 0.3) return SENDER_TRUST_MODIFIERS.stranger;
    return SENDER_TRUST_MODIFIERS.regular;
  }

  _computeInfectionRate() {
    let infected = 0;
    for (const n of this.nodes) if (n.status === NodeStatus.BELIEVING || n.status === NodeStatus.SILENT_BELIEVER) infected++;
    return infected / this.nodes.length;
  }

  _computeR0() {
    let sum = 0, count = 0;
    for (const n of this.nodes) {
      if ((n.status === NodeStatus.BELIEVING || n.status === NodeStatus.SILENT_BELIEVER) && n.infected_at !== null && (this.currentTime - n.infected_at) < 3600) {
        sum += n.downstream_infections;
        count++;
      }
    }
    return count > 0 ? sum / count : 0;
  }

  _computeBackfire(sender, rumor) {
    let total = 0;
    if (sender.agent_type === AgentType.FACT_CHECKER) total += Math.min(0.7, sender.credibility_threshold * 0.5);
    else if (sender.agent_type === AgentType.INFLUENCER) total += Math.min(0.5, sender.credibility_threshold * 0.3);
    const litVal = sender.literacy[rumor.scenario] || 0.5;
    if (litVal > 0.7) total += Math.min(0.7, litVal * 0.5);
    return Math.min(0.85, total);
  }

  _selectRumorShape(sender, rumor, edgeWeight) {
    if (sender.agent_type === AgentType.BOT) return RumorShape.BARE_FORWARD;
    if (emotionDot(rumor.emotions, sender.susceptibility) > 0.7 && sender.times_exposed <= 2) return RumorShape.REACTION;
    if (sender.agent_type === AgentType.INFLUENCER) return RumorShape.ELABORATOR;
    if (sender.effective_threshold > 0.6) return RumorShape.SKEPTIC_SHARER;
    if (edgeWeight > 0.7) return RumorShape.PERSONAL_FRAME;
    const shapes = [RumorShape.BARE_FORWARD, RumorShape.REACTION, RumorShape.PERSONAL_FRAME, RumorShape.ELABORATOR, RumorShape.SKEPTIC_SHARER];
    const w = [0.30, 0.20, 0.25, 0.10, 0.15];
    return shapes[this.rng.choiceIndex(5, w)];
  }

  _selectCorrectionShape(sender) {
    if (sender.agent_type === AgentType.FACT_CHECKER) return CorrectionShape.DEBUNK;
    if (sender.status === NodeStatus.CORRECTED) return this.rng.random() < 0.6 ? CorrectionShape.RELUCTANT_WALKBACK : CorrectionShape.RELAY;
    if (sender.status === NodeStatus.UNAWARE) return this.rng.random() < 0.3 ? CorrectionShape.TOLD_YOU_SO : CorrectionShape.RELAY;
    return CorrectionShape.RELAY;
  }

  _updateEmotionalState(node, rumor) {
    let anyHigh = false;
    for (let i = 0; i < 5; i++) {
      if (rumor.emotions[i] > 0.5) {
        anyHigh = true;
        node.emotional_priming[i] += 0.05 * rumor.emotions[i];
        node.messages_processed_per_emotion[i]++;
      }
    }
    if (anyHigh) {
      let total = 0;
      for (let i = 0; i < 5; i++) total += node.messages_processed_per_emotion[i];
      if (total > 0 && total % 10 === 0) {
        for (let i = 0; i < 5; i++) {
          if (node.messages_processed_per_emotion[i] > 0) {
            node.emotional_fatigue[i] += 0.05 * node.original_susceptibility[i];
          }
        }
      }
    }
    for (let i = 0; i < 5; i++) {
      const orig = node.original_susceptibility[i];
      node.susceptibility[i] = clamp(orig + node.emotional_priming[i] - node.emotional_fatigue[i], orig * 0.3, orig * 1.5);
    }
  }

  _degradeLiteracy(target, rumor, sender, edgeWeight) {
    const topic = rumor.scenario;
    const baseLit = target.literacy[topic] || 0.5;
    let pressure = 1.0;
    const st = this._getSenderTrust(sender, edgeWeight, null);
    if (st > 1.5) pressure *= 1.3;
    else if (st > 1.0) pressure *= 1.1;
    if (rumor.emotions[0] > 0.5) pressure *= 1.2;
    if (emotionMean(rumor.emotions) > 0.5) pressure *= 1.1;
    if (this._computeAlignment(target, rumor) > 0.6) pressure *= 1.15;
    target.literacy[topic] = Math.max(0.1, baseLit * Math.pow(0.97, target.times_exposed * pressure));
  }

  _logEvent(time, type, nodeId, targetId, platform, details) {
    if (this.eventLog.length >= 500) this.eventLog.shift();
    this.eventLog.push({ time, type, nodeId, targetId, platform, details: details || {} });
  }

  _classifyDeathType() {
    const r0 = this._computeR0();
    let corrected = 0, believers = 0, peakBelievers = 0;
    for (const n of this.nodes) {
      if (n.status === NodeStatus.BELIEVING || n.status === NodeStatus.SILENT_BELIEVER) believers++;
      if (n.status === NodeStatus.CORRECTED) corrected++;
    }
    for (const [, rate] of this.infectionTimeline) {
      const c = Math.floor(rate * this.nodes.length);
      if (c > peakBelievers) peakBelievers = c;
    }
    if (!peakBelievers) peakBelievers = believers;
    const infRate = this._computeInfectionRate();
    if (this._terminationTime === null && this.currentTime >= this.config.max_time) return DeathType.STILL_ALIVE;
    if (infRate >= 0.80) return DeathType.SATURATED;
    if (infRate < 0.05) return DeathType.STARVED;
    if (peakBelievers > 0 && corrected >= 0.3 * peakBelievers) return DeathType.CORRECTED;
    // Time decayed
    for (const p of this.config.active_platforms) {
      if (PLATFORM_CONFIG[p].story_decay) {
        for (const rv of Object.values(this.rumorVersions)) {
          if (rv.expiry_time !== null && this.currentTime > rv.expiry_time) return DeathType.TIME_DECAYED;
        }
        const actualTime = this._terminationTime || this.currentTime;
        if (p === this.config.seed_platform && actualTime > 7200 && peakBelievers > Math.floor(0.05 * this.nodes.length)) return DeathType.TIME_DECAYED;
      }
    }
    // Mutated away
    let maxDist = 0;
    for (const rv of Object.values(this.rumorVersions)) if (rv.mutation_distance > maxDist) maxDist = rv.mutation_distance;
    if (maxDist > 0.35) return DeathType.MUTATED_AWAY;
    return DeathType.STARVED;
  }

  // ---- Snapshot for visualization ----

  generateSnapshot() {
    const n = this.nodes.length;
    // Typed arrays for efficient transfer
    const statusArr = new Uint8Array(n);
    const typeArr = new Uint8Array(n);
    const chamberArr = new Uint8Array(n);
    const statusMap = { unaware:0, believing:1, silent_believer:2, corrected:3, immune:4, removed:5 };
    const typeMap = { regular:0, influencer:1, fact_checker:2, bot:3, lurker:4 };
    for (let i = 0; i < n; i++) {
      statusArr[i] = statusMap[this.nodes[i].status] || 0;
      typeArr[i] = typeMap[this.nodes[i].agent_type] || 0;
      chamberArr[i] = this.nodes[i].echo_chamber_idx;
    }
    // Active edges (recent infections — use wider window to capture events from last batch)
    const edges = [];
    const recentCutoff = this.currentTime - 600;
    for (const e of this.eventLog.slice(-50)) {
      if (e.time < recentCutoff) continue;
      if (e.type === 'node_infected' && e.targetId !== null) {
        // Phase 5: augment with tooltip data
        const senderNode = this.nodes[e.targetId];
        const targetNode = this.nodes[e.nodeId];
        const rumorV = (e.details || {}).rumor_version || 0;
        const rv = this.rumorVersions[rumorV];
        const emotionNames = ['fear','outrage','humor','curiosity','urgency'];
        let domEm = 'curiosity', domVal = 0;
        if (rv && rv.emotions) { let mx = 0; for (let ei = 0; ei < 5; ei++) { if (rv.emotions[ei] > mx) { mx = rv.emotions[ei]; domEm = emotionNames[ei]; domVal = mx; } } }
        edges.push({ source: e.targetId, target: e.nodeId, type: 'rumor',
          time: e.time, edgeStrength: 0.5, rumorVersion: rumorV, dominantEmotion: domEm, emotionValue: domVal,
          mediaType: rv ? rv.media_type : 'text', scenario: rv ? rv.scenario : 'celebrity',
          senderType: senderNode ? senderNode.agent_type : 'regular', platform: e.platform || this.config.seed_platform,
          isCorrection: false });
      } else if (e.type === 'node_corrected' && e.targetId !== null) {
        edges.push({ source: e.targetId, target: e.nodeId, type: 'correction',
          time: e.time, edgeStrength: 0.5, isCorrection: true, platform: e.platform || this.config.seed_platform,
          scenario: this.config.scenario, senderType: 'fact_checker' });
      } else if (e.type === 'platform_hop') {
        // Pick a neighbor on the destination platform for a visible edge
        const hopNode = this.nodes[e.nodeId];
        const destPlat = (e.details || {}).dest_platform;
        if (hopNode && destPlat) {
          const conns = hopNode.platform_connections[destPlat] || [];
          const tgt = conns.length > 0 ? conns[0] : e.nodeId;
          edges.push({ source: e.nodeId, target: tgt, type: 'hop' });
        } else {
          edges.push({ source: e.nodeId, target: e.nodeId, type: 'hop' });
        }
      }
    }
    // Stats
    let believing = 0, silent = 0, correctedN = 0, unaware = 0;
    for (const nd of this.nodes) {
      if (nd.status === NodeStatus.BELIEVING) believing++;
      else if (nd.status === NodeStatus.SILENT_BELIEVER) silent++;
      else if (nd.status === NodeStatus.CORRECTED) correctedN++;
      else if (nd.status === NodeStatus.UNAWARE) unaware++;
    }
    const r0 = this._computeR0();
    // Recent events for feed
    const recentEvents = this.eventLog.slice(-20).map(e => ({
      time: e.time, type: e.type, nodeId: e.nodeId, targetId: e.targetId, platform: e.platform, details: e.details
    }));
    // Concept values
    const pCfg = PLATFORM_CONFIG[this.config.seed_platform];
    let avgAttention = 0, avgThreshold = 0;
    for (const nd of this.nodes) { avgAttention += nd.attention_budget; avgThreshold += nd.effective_threshold; }
    avgAttention /= n;
    avgThreshold /= n;
    // Bernoulli: average believe probability from recent infections
    const recentInfections = this.eventLog.filter(e => e.type === 'node_infected').length;
    const recentAttempts = this.eventLog.filter(e => e.type === 'node_infected' || e.type === 'rumor_rejected').length;
    const avgBelieveP = recentAttempts > 0 ? recentInfections / recentAttempts : 0;
    // Emotion: mean of seed rumor
    const seedRumor = this.rumorVersions[0];
    const avgEmotion = seedRumor ? emotionMean(seedRumor.emotions) : 0;
    // Queue utilization: rho = lambda * service / n_servers (where n_servers ~ network_size)
    const lambda = pCfg.arrival_rate;
    const mu = pCfg.base_service_time;
    const rho = Math.min(0.99, (lambda * mu) / n);
    // Average credibility of seed rumor
    const avgCred = seedRumor ? seedRumor.virality_score : 0;
    // Average framing modifier (use rumor framing)
    const avgFraming = 0.10; // typical average across shapes

    return {
      time: this.currentTime,
      status: statusArr, types: typeArr, chambers: chamberArr,
      edges, stats: { believing, silent, corrected: correctedN, unaware, r0, r0Peak: this.r0Peak, mutations: this.totalMutations, hops: this.totalPlatformHops, botsDetected: this.botsDetected, infectionRate: (believing + silent) / n },
      recentEvents,
      concepts: { poisson: lambda, service: mu, decay: this.config.decay_rate, attention: avgAttention, r0, bernoulli: avgBelieveP, emotion: avgEmotion, bias: this.config.bias_strength, queue: rho, cred: avgCred, framing: avgFraming },
    };
  }

  // ---- Headless run for Monte Carlo ----

  runHeadless() {
    this.setup();
    let maxIter = 500000;
    while (this.eventQueue.size > 0 && maxIter-- > 0) {
      const event = this.eventQueue.peek();
      if (event.time > this.config.max_time) break;
      this.eventQueue.pop();
      this.currentTime = event.time;
      this._processEvent(event);
    }
    return {
      finalInfectionRate: this._computeInfectionRate(),
      terminationTime: this._terminationTime || this.currentTime,
      r0Peak: this.r0Peak,
      deathType: this._classifyDeathType(),
      mutations: this.totalMutations,
      hops: this.totalPlatformHops,
    };
  }
}

// ---- 2f. Worker Message Handler ----

let engine = null;
let runInterval = null;
let speed = 1;
let playing = false;

function emitSnapshot() {
  if (!engine) return;
  const snap = engine.generateSnapshot();
  self.postMessage({ type: 'snapshot', data: snap }, [snap.status.buffer, snap.types.buffer, snap.chambers.buffer]);
}

// Adaptive playback controller
// At 1x speed: process 2 events per tick at 15fps → 30 events/sec
// A typical 500-event sim plays out over ~15-20 seconds
// At 10x: 20 events/tick → finishes in ~2s
// Interval is 66ms (15fps) to avoid snapshot overhead at 30fps
const TICK_INTERVAL = 66; // ms between ticks (~15fps)

function runLoop() {
  if (!engine || !playing) return;
  const batchSize = Math.max(1, Math.round(2 * speed));
  let processed = 0;
  while (engine.eventQueue.size > 0 && processed < batchSize) {
    const next = engine.eventQueue.peek();
    if (next.time > engine.config.max_time) break;
    engine.eventQueue.pop();
    engine.currentTime = next.time;
    engine._processEvent(next);
    processed++;
  }
  // Check if sim is finished
  if (engine.eventQueue.size === 0 || engine.currentTime >= engine.config.max_time) {
    playing = false;
    if (runInterval) { clearInterval(runInterval); runInterval = null; }
    emitSnapshot();
    self.postMessage({ type: 'finished', data: { deathType: engine._classifyDeathType(), time: engine.currentTime } });
    return;
  }
  emitSnapshot();
}

self.onmessage = function(e) {
  const msg = e.data;
  switch (msg.type) {
    case 'init': {
      if (msg.config.scenario === 'custom' && msg.config.custom_rumor) {
        RUMOR_SCENARIOS.custom = msg.config.custom_rumor;
      }
      engine = new SimulationEngine(msg.config);
      engine.setup();
      // Store initial checkpoint at time 0 so backward scrub always works
      engine._nextCheckpointPct = 0;
      engine.maybeStoreCheckpoint();
      // Send initial topology for D3
      const topology = { nodes: [], edges: [] };
      const seedPlat = engine.config.seed_platform;
      for (const node of engine.nodes) {
        topology.nodes.push({ id: node.id, type: node.agent_type, chamber: node.echo_chamber_idx, platforms: node.platforms });
      }
      // Send edges from seed platform adjacency
      const adj = engine.platformAdj[seedPlat] || {};
      const seenEdges = new Set();
      for (const src in adj) {
        for (const tgt of adj[src]) {
          const key = Math.min(src, tgt) + '-' + Math.max(src, tgt);
          if (!seenEdges.has(key)) {
            seenEdges.add(key);
            topology.edges.push({ source: parseInt(src), target: parseInt(tgt) });
          }
        }
      }
      self.postMessage({ type: 'topology', data: topology });
      emitSnapshot();
      self.postMessage({ type: 'ready' });
      break;
    }
    case 'play':
      playing = true;
      speed = msg.speed || 1;
      if (runInterval) clearInterval(runInterval);
      runInterval = setInterval(runLoop, TICK_INTERVAL);
      break;
    case 'pause':
      playing = false;
      if (runInterval) { clearInterval(runInterval); runInterval = null; }
      break;
    case 'step':
      if (engine) { engine.processEvents(20); emitSnapshot(); }
      break;
    case 'speed':
      speed = msg.speed || 1;
      break;
    case 'reset':
      playing = false;
      if (runInterval) { clearInterval(runInterval); runInterval = null; }
      engine = null;
      self.postMessage({ type: 'reset_done' });
      break;
    case 'monte_carlo': {
      const mcConfig = msg.config;
      const nRuns = msg.nRuns || 100;
      const results = [];
      for (let i = 0; i < nRuns; i++) {
        const cfg = Object.assign({}, mcConfig, { master_seed: (mcConfig.master_seed || 42) + i * 7 + i });
        const eng = new SimulationEngine(cfg);
        const result = eng.runHeadless();
        results.push(result);
        if (i % 10 === 0 || i === nRuns - 1) {
          // Compute running stats
          const rates = results.map(r => r.finalInfectionRate);
          const mean = rates.reduce((s, v) => s + v, 0) / rates.length;
          let variance = 0;
          for (const r of rates) variance += (r - mean) ** 2;
          variance /= Math.max(rates.length - 1, 1);
          const std = Math.sqrt(variance);
          const ci = 1.96 * std / Math.sqrt(rates.length);
          self.postMessage({ type: 'mcProgress', data: { run: i + 1, total: nRuns, mean, std, ci, ciLow: mean - ci, ciHigh: mean + ci } });
        }
      }
      // Final results
      const rates = results.map(r => r.finalInfectionRate);
      const r0s = results.map(r => r.r0Peak);
      const deaths = {};
      for (const r of results) deaths[r.deathType] = (deaths[r.deathType] || 0) + 1;
      const mean = rates.reduce((s, v) => s + v, 0) / rates.length;
      const sorted = rates.slice().sort((a, b) => a - b);
      const median = sorted[Math.floor(sorted.length / 2)];
      let variance = 0;
      for (const r of rates) variance += (r - mean) ** 2;
      variance /= Math.max(rates.length - 1, 1);
      const std = Math.sqrt(variance);
      const ci = 1.96 * std / Math.sqrt(rates.length);
      const meanR0 = r0s.reduce((s, v) => s + v, 0) / r0s.length;
      self.postMessage({ type: 'mcComplete', data: { rates, r0s, deaths, mean, median, std, ci, ciLow: mean - ci, ciHigh: mean + ci, meanR0, nRuns } });
      break;
    }
    // Phase 5: Node data request for popup
    case 'requestNodeData': {
      if (!engine) break;
      const nid = msg.nodeId;
      const nd = engine.nodes[nid];
      if (!nd) { self.postMessage({ type: 'nodeData', nodeId: nid, events: [], nodeState: null }); break; }
      // Serialize node state
      const nState = {
        id: nd.id, agent_type: nd.agent_type, echo_chamber_idx: nd.echo_chamber_idx,
        worldview_vector: nd.worldview_vector.slice(),
        susceptibility: nd.susceptibility.slice(), original_susceptibility: nd.original_susceptibility.slice(),
        emotional_priming: nd.emotional_priming.slice(), emotional_fatigue: nd.emotional_fatigue.slice(),
        credibility_threshold: nd.credibility_threshold, effective_threshold: nd.effective_threshold,
        attention_budget: nd.attention_budget, status: nd.status,
        times_exposed: nd.times_exposed, times_correction_seen: nd.times_correction_seen,
        infected_by: nd.infected_by, infected_at: nd.infected_at, infected_on_platform: nd.infected_on_platform,
        downstream_infections: nd.downstream_infections, rumor_version: nd.rumor_version,
        age_group: nd.age_group, digital_nativity: nd.digital_nativity,
        platforms: nd.platforms.slice(), rewiring_events: nd.rewiring_events,
        connections: 0, literacy: Object.assign({}, nd.literacy),
      };
      // Count connections on seed platform
      const seedAdj = engine.platformAdj[engine.config.seed_platform] || {};
      nState.connections = (seedAdj[nid] || new Set()).size;
      self.postMessage({ type: 'nodeData', nodeId: nid, events: engine.nodeEventLog[nid] || [], nodeState: nState });
      break;
    }
    // Phase 5: Critical path request
    case 'requestCriticalPath': {
      if (!engine) break;
      let maxNode = null, maxDown = 0;
      for (const nd of engine.nodes) {
        if (nd.downstream_infections > maxDown) { maxDown = nd.downstream_infections; maxNode = nd; }
      }
      const path = [];
      let cur = maxNode;
      while (cur && cur.infected_by !== null) { path.unshift(cur.id); cur = engine.nodes[cur.infected_by]; }
      if (cur) path.unshift(cur.id);
      // Bridge nodes: nodes that connect different echo chambers
      const bridges = [];
      for (let i = 0; i < path.length - 1; i++) {
        const a = engine.nodes[path[i]], b = engine.nodes[path[i+1]];
        if (a && b && a.echo_chamber_idx !== b.echo_chamber_idx) bridges.push(path[i]);
      }
      // Stats
      const totalInfected = engine.nodes.filter(n => n.status === 'believing' || n.status === 'silent_believer' || n.status === 'corrected').length;
      const pathSpread = maxDown;
      self.postMessage({ type: 'criticalPath', path, bridgeNodes: bridges, stats: { pathLength: path.length, keyBridge: bridges[0] || null, spreadPct: totalInfected > 0 ? (pathSpread / totalInfected * 100).toFixed(1) : 0, totalInfected } });
      break;
    }
    // Phase 5: Mutation chain request
    case 'requestMutationChain': {
      if (!engine) break;
      const mutations = [];
      for (const key of Object.keys(engine.rumorVersions).sort((a,b) => a - b)) {
        const r = engine.rumorVersions[key];
        const ems = r.emotions || [0,0,0,0,0];
        const emotionNames = ['fear','outrage','humor','curiosity','urgency'];
        let maxI = 0;
        for (let i = 1; i < ems.length; i++) { if (ems[i] > ems[maxI]) maxI = i; }
        mutations.push({ version: r.version, dominantEmotion: emotionNames[maxI], dominantValue: ems[maxI], contentQuality: r.content_quality, originTime: r.origin_time, originNode: r.origin_node, platform: r.origin_platform });
      }
      self.postMessage({ type: 'mutationChain', mutations });
      break;
    }
    // Phase 5: Timeline scrub
    case 'scrubTo': {
      if (!engine) break;
      playing = false;
      if (runInterval) { clearInterval(runInterval); runInterval = null; }
      const targetTime = msg.targetTime || 0;
      // Find nearest checkpoint at or before targetTime
      const pctTarget = Math.round((targetTime / engine.config.max_time) * 100);
      let bestKey = -1;
      for (const [key] of engine._checkpoints) {
        if (key <= pctTarget && key > bestKey) bestKey = key;
      }
      if (bestKey >= 0 && targetTime < engine.currentTime) {
        // Restore checkpoint and fast-forward
        const cp = engine._checkpoints.get(bestKey);
        engine.restoreCheckpoint(cp);
        // Fast-forward by processing events until targetTime
        let safety = 0;
        while (engine.eventQueue.size > 0 && safety < 50000) {
          const nextEvt = engine.eventQueue.peek();
          if (nextEvt.time > targetTime) break;
          engine.eventQueue.pop();
          engine.currentTime = nextEvt.time;
          engine._processEvent(nextEvt);
          safety++;
        }
        engine.currentTime = targetTime;
      }
      emitSnapshot();
      break;
    }
  }
};
  </script>

  <!-- ======== MAIN THREAD APPLICATION ======== -->
  <script>
(function() {
'use strict';

// ============================================================
// Step 3: Web Worker Integration
// ============================================================

let worker = null;
let appState = { mode: 'visual', playing: false, speed: 1, simTime: 0, maxTime: 172800, topology: null, lastSnapshot: null, lastConfig: null, layoutMode: 'focus' };

function createWorker() {
  if (worker) worker.terminate();
  const src = document.getElementById('worker-source').textContent;
  const blob = new Blob([src], { type: 'application/javascript' });
  worker = new Worker(URL.createObjectURL(blob));
  worker.onmessage = handleWorkerMessage;
  worker.onerror = (e) => console.error('[Worker Error]', e.message);
}

function handleWorkerMessage(e) {
  const msg = e.data;
  switch (msg.type) {
    case 'ready': console.log('[Afwah] Worker ready'); break;
    case 'topology': appState.topology = msg.data; initD3Graph(msg.data); break;
    case 'snapshot': appState.lastSnapshot = msg.data; appState.simTime = msg.data.time; updateVisualization(msg.data); break;
    case 'finished':
      appState.playing = false;
      updatePlayButton();
      console.log('[Afwah] Sim finished:', msg.data);
      // Phase 5: Add analysis buttons to feed on completion
      addSimAnalysisButtons();
      break;
    case 'mcProgress': updateMCProgress(msg.data); break;
    case 'mcComplete': updateMCResults(msg.data); break;
    case 'reset_done': console.log('[Afwah] Reset done'); break;
    // Phase 5 handlers
    case 'nodeData': handleNodeData(msg); break;
    case 'criticalPath': renderCriticalPath(msg); break;
    case 'mutationChain': showMutationChain(msg.mutations); break;
  }
}

function buildConfig() {
  const seed = parseInt(document.getElementById('in-seed').value) || 0;
  const botPct = parseFloat(document.getElementById('sl-bots').value);
  const corrDelay = parseInt(document.getElementById('sl-correction').value);
  const scenario = document.getElementById('sel-scenario').value;
  const config = {
    network_size: parseInt(document.getElementById('sl-size').value),
    num_echo_chambers: parseInt(document.getElementById('sl-chambers').value),
    seed_platform: document.getElementById('sel-platform').value,
    active_platforms: ['twitter', 'whatsapp', 'instagram', 'reddit'],
    scenario: scenario,
    media_type: document.getElementById('sel-media').value,
    seed_persona: document.getElementById('sel-persona').value,
    decay_rate: parseFloat(document.getElementById('sl-decay').value),
    bot_percentage: botPct,
    correction_delay_minutes: corrDelay,
    master_seed: seed || null,
    max_time: 172800,
  };
  if (scenario === 'custom') config.custom_rumor = getCustomScenario();
  return config;
}

// ============================================================
// Step 4: D3 Network Graph
// ============================================================

let svg, simulation, nodeElements, linkElements, linkGroup;
let graphNodes = [], graphLinks = [];
const statusColors = ['#A0A0B0','#E05252','#D4A04A','#5294CC','#52B788','#4A4A5A'];
const typeRadius = { regular:3, influencer:6, fact_checker:5, bot:3, lurker:2 };
const typeStroke = { regular:'transparent', influencer:'#F0C040', fact_checker:'#52B788', bot:'#9B5DE5', lurker:'transparent' };

function initD3Graph(topology) {
  const container = document.getElementById('graph-panel');
  const width = container.clientWidth || 800;
  const height = Math.max(300, container.clientHeight || 600);
  svg = d3.select('#main-graph').attr('width', width).attr('height', height);
  svg.selectAll('*').remove();

  // Dark background rect
  svg.append('rect').attr('width', width).attr('height', height).attr('fill', 'none');

  // Zoom wrapper: all visual elements go inside this group
  const zoomG = svg.append('g').attr('class', 'zoom-container');

  linkGroup = zoomG.append('g').attr('class', 'links');
  const nodeGroup = zoomG.append('g').attr('class', 'nodes');
  const pulseGroup = zoomG.append('g').attr('class', 'pulses');

  graphNodes = topology.nodes.map(n => ({ ...n, x: width/2 + (Math.random()-0.5)*200, y: height/2 + (Math.random()-0.5)*200 }));
  graphLinks = topology.edges.map(e => ({ source: e.source, target: e.target }));

  // Chamber centroids for cluster force
  const chamberCentroids = {};
  const nc = new Set(graphNodes.map(n => n.chamber)).size;
  const angleStep = (2 * Math.PI) / Math.max(nc, 1);
  for (let i = 0; i < nc; i++) {
    chamberCentroids[i] = { x: width/2 + Math.cos(i * angleStep) * Math.min(width, height) * 0.25, y: height/2 + Math.sin(i * angleStep) * Math.min(width, height) * 0.25 };
  }

  simulation = d3.forceSimulation(graphNodes)
    .force('charge', d3.forceManyBody().strength(-6))
    .force('center', d3.forceCenter(width/2, height/2))
    .force('collision', d3.forceCollide(4))
    .force('link', d3.forceLink(graphLinks).id(d => d.id).distance(30).strength(0.1))
    .force('cluster', alpha => {
      for (const node of graphNodes) {
        const c = chamberCentroids[node.chamber];
        if (c) {
          node.vx += (c.x - node.x) * alpha * 0.08;
          node.vy += (c.y - node.y) * alpha * 0.08;
        }
      }
    })
    .alphaDecay(0.02)
    .on('tick', () => {
      if (!nodeElements || !linkElements) return;
      linkElements
        .attr('x1', d => d.source.x).attr('y1', d => d.source.y)
        .attr('x2', d => d.target.x).attr('y2', d => d.target.y);
      nodeElements.attr('cx', d => d.x = Math.max(5, Math.min(width-5, d.x)))
                   .attr('cy', d => d.y = Math.max(5, Math.min(height-5, d.y)));
    });

  // Pre-settle (tick handler is guarded, won't crash)
  simulation.stop();
  simulation.alpha(1);
  for (let i = 0; i < 300; i++) simulation.tick();

  // Draw static edges (subtle, low opacity for 500-node graph)
  linkElements = linkGroup.selectAll('line').data(graphLinks).join('line')
    .attr('stroke', 'rgba(255,255,255,0.06)')
    .attr('stroke-width', 0.4)
    .attr('x1', d => d.source.x).attr('y1', d => d.source.y)
    .attr('x2', d => d.target.x).attr('y2', d => d.target.y);

  // Draw nodes
  nodeElements = nodeGroup.selectAll('circle').data(graphNodes, d => d.id).join('circle')
    .attr('r', d => typeRadius[d.type] || 3)
    .attr('fill', statusColors[0])
    .attr('stroke', d => typeStroke[d.type] || 'transparent')
    .attr('stroke-width', d => typeStroke[d.type] !== 'transparent' ? 1.5 : 0)
    .attr('cx', d => d.x)
    .attr('cy', d => d.y)
    .style('cursor', 'pointer')
    .on('click', function(event, d) {
      event.stopPropagation();
      if (!worker) return;
      worker.postMessage({ type: 'requestNodeData', nodeId: d.id });
      highlightNode(d.id);
    });

  // Resume simulation gently for final settling
  simulation.alpha(0.05).restart();

  // Echo chamber boundaries (dotted circles) — inside zoomG so they zoom too
  for (let i = 0; i < nc; i++) {
    const c = chamberCentroids[i];
    zoomG.append('circle').attr('cx', c.x).attr('cy', c.y)
      .attr('r', Math.min(width, height) * 0.15)
      .attr('fill', 'none')
      .attr('stroke', 'rgba(255,255,255,0.06)')
      .attr('stroke-dasharray', '4,4');
  }

  // D3 zoom + pan behavior
  const zoom = d3.zoom()
    .scaleExtent([0.3, 5])
    .on('zoom', (event) => { zoomG.attr('transform', event.transform); });
  svg.call(zoom);
  svg.on('dblclick.zoom', null); // disable double-click zoom (conflicts with node clicks)

  // Store references for external zoom controls and animateEdgePulse
  svg.node().__zoom_ref = zoom;
  linkGroup._pulseGroup = pulseGroup;
}

// ============================================================
// Enhanced Layout Mode — spread-out clustered graph
// ============================================================

const chamberHullColors = [
  'rgba(224,82,82,0.07)',   // red-ish
  'rgba(82,148,204,0.07)',  // blue-ish
  'rgba(82,183,136,0.07)',  // green-ish
  'rgba(200,82,148,0.07)',  // purple-ish
  'rgba(212,160,74,0.07)',  // amber (if >4 chambers)
  'rgba(146,82,204,0.07)',  // violet
];
const chamberStrokeColors = [
  'rgba(224,82,82,0.25)',
  'rgba(82,148,204,0.25)',
  'rgba(82,183,136,0.25)',
  'rgba(200,82,148,0.25)',
  'rgba(212,160,74,0.25)',
  'rgba(146,82,204,0.25)',
];
let _enhancedHullGroup = null;
let _enhancedChamberCentroids = null;

function initEnhancedGraph(topology) {
  const container = document.getElementById('graph-panel');
  const width = container.clientWidth || 800;
  const height = Math.max(300, container.clientHeight || 600);
  svg = d3.select('#main-graph').attr('width', width).attr('height', height);
  svg.selectAll('*').remove();

  svg.append('rect').attr('width', width).attr('height', height).attr('fill', 'none');

  const zoomG = svg.append('g').attr('class', 'zoom-container');

  // Hull group renders behind everything
  _enhancedHullGroup = zoomG.append('g').attr('class', 'hulls');
  linkGroup = zoomG.append('g').attr('class', 'links');
  const nodeGroup = zoomG.append('g').attr('class', 'nodes');
  const pulseGroup = zoomG.append('g').attr('class', 'pulses');

  // Reuse existing graphNodes/graphLinks but reset positions for fresh layout
  graphNodes = topology.nodes.map(n => ({
    ...n,
    x: width/2 + (Math.random()-0.5)*300,
    y: height/2 + (Math.random()-0.5)*300
  }));
  graphLinks = topology.edges.map(e => ({ source: e.source, target: e.target }));

  // Chamber centroids — pushed further out (0.35 vs 0.25)
  _enhancedChamberCentroids = {};
  const nc = new Set(graphNodes.map(n => n.chamber)).size;
  const angleStep = (2 * Math.PI) / Math.max(nc, 1);
  for (let i = 0; i < nc; i++) {
    _enhancedChamberCentroids[i] = {
      x: width/2 + Math.cos(i * angleStep - Math.PI/2) * Math.min(width, height) * 0.35,
      y: height/2 + Math.sin(i * angleStep - Math.PI/2) * Math.min(width, height) * 0.35
    };
  }

  // Build a quick chamber lookup for edges
  const nodeIdToChamber = {};
  for (const n of graphNodes) nodeIdToChamber[n.id] = n.chamber;

  // Enhanced force simulation
  simulation = d3.forceSimulation(graphNodes)
    .force('charge', d3.forceManyBody().strength(-30))
    .force('center', d3.forceCenter(width/2, height/2).strength(0.03))
    .force('collision', d3.forceCollide(8))
    .force('link', d3.forceLink(graphLinks).id(d => d.id).distance(60).strength(0.05))
    .force('cluster', alpha => {
      for (const node of graphNodes) {
        const c = _enhancedChamberCentroids[node.chamber];
        if (c) {
          node.vx += (c.x - node.x) * alpha * 0.15;
          node.vy += (c.y - node.y) * alpha * 0.15;
        }
      }
    })
    .alphaDecay(0.015)
    .on('tick', () => {
      if (!nodeElements || !linkElements) return;
      linkElements
        .attr('x1', d => d.source.x).attr('y1', d => d.source.y)
        .attr('x2', d => d.target.x).attr('y2', d => d.target.y);
      nodeElements.attr('cx', d => d.x).attr('cy', d => d.y);
    });

  // Pre-settle with more iterations for the stronger forces
  simulation.stop();
  simulation.alpha(1);
  for (let i = 0; i < 400; i++) simulation.tick();

  // Draw edges — cross-chamber edges slightly more visible
  linkElements = linkGroup.selectAll('line').data(graphLinks).join('line')
    .attr('stroke', d => {
      const sc = typeof d.source === 'object' ? d.source.chamber : nodeIdToChamber[d.source];
      const tc = typeof d.target === 'object' ? d.target.chamber : nodeIdToChamber[d.target];
      return sc !== tc ? 'rgba(255,255,255,0.12)' : 'rgba(255,255,255,0.05)';
    })
    .attr('stroke-width', d => {
      const sc = typeof d.source === 'object' ? d.source.chamber : nodeIdToChamber[d.source];
      const tc = typeof d.target === 'object' ? d.target.chamber : nodeIdToChamber[d.target];
      return sc !== tc ? 0.6 : 0.3;
    })
    .attr('x1', d => d.source.x).attr('y1', d => d.source.y)
    .attr('x2', d => d.target.x).attr('y2', d => d.target.y);

  // Draw nodes (same style as focus mode)
  nodeElements = nodeGroup.selectAll('circle').data(graphNodes, d => d.id).join('circle')
    .attr('r', d => typeRadius[d.type] || 3)
    .attr('fill', statusColors[0])
    .attr('stroke', d => typeStroke[d.type] || 'transparent')
    .attr('stroke-width', d => typeStroke[d.type] !== 'transparent' ? 1.5 : 0)
    .attr('cx', d => d.x)
    .attr('cy', d => d.y)
    .style('cursor', 'pointer')
    .on('click', function(event, d) {
      event.stopPropagation();
      if (!worker) return;
      worker.postMessage({ type: 'requestNodeData', nodeId: d.id });
      highlightNode(d.id);
    });

  // Gentle restart for final settling
  simulation.alpha(0.05).restart();

  // Draw convex hulls per chamber
  updateEnhancedHulls();

  // Chamber labels
  for (let i = 0; i < nc; i++) {
    const c = _enhancedChamberCentroids[i];
    zoomG.append('text')
      .attr('class', 'chamber-label')
      .attr('x', c.x).attr('y', c.y - Math.min(width, height) * 0.12)
      .attr('text-anchor', 'middle')
      .attr('fill', chamberStrokeColors[i % chamberStrokeColors.length].replace('0.25', '0.6'))
      .attr('font-size', '11px')
      .attr('font-weight', '600')
      .attr('letter-spacing', '0.5px')
      .text('CHAMBER ' + i);
  }

  // Zoom behavior
  const zoom = d3.zoom()
    .scaleExtent([0.3, 5])
    .on('zoom', (event) => { zoomG.attr('transform', event.transform); });
  svg.call(zoom);
  svg.on('dblclick.zoom', null);

  // Fallback: hide edge tooltip when mouse is not over a pulse line
  svg.on('mousemove.edgeTooltip', function(event) {
    // Handled by document-level listener, but namespace is needed to not conflict with zoom
  });

  svg.node().__zoom_ref = zoom;
  linkGroup._pulseGroup = pulseGroup;
}

function updateEnhancedHulls() {
  if (!_enhancedHullGroup || !graphNodes.length) return;
  _enhancedHullGroup.selectAll('path').remove();

  // Group nodes by chamber
  const chamberNodes = {};
  for (const n of graphNodes) {
    if (!chamberNodes[n.chamber]) chamberNodes[n.chamber] = [];
    chamberNodes[n.chamber].push([n.x, n.y]);
  }

  for (const [chamber, points] of Object.entries(chamberNodes)) {
    if (points.length < 3) continue; // need 3+ points for a hull
    const hull = d3.polygonHull(points);
    if (!hull) continue;

    // Expand hull outward by padding for a softer look
    const cx = d3.mean(hull, p => p[0]);
    const cy = d3.mean(hull, p => p[1]);
    const padded = hull.map(p => {
      const dx = p[0] - cx, dy = p[1] - cy;
      const dist = Math.sqrt(dx*dx + dy*dy);
      const scale = dist > 0 ? (dist + 20) / dist : 1;
      return [cx + dx * scale, cy + dy * scale];
    });

    const ci = parseInt(chamber) % chamberHullColors.length;
    _enhancedHullGroup.append('path')
      .attr('d', 'M' + padded.map(p => p.join(',')).join('L') + 'Z')
      .attr('fill', chamberHullColors[ci])
      .attr('stroke', chamberStrokeColors[ci])
      .attr('stroke-width', 1)
      .attr('stroke-dasharray', '6,3')
      .style('pointer-events', 'none');
  }
}

function updateNodeColors(statusArr) {
  if (!nodeElements) return;
  nodeElements.attr('fill', (d, i) => statusColors[statusArr[i]] || statusColors[0]);
}

function _startPulseFade(pulseLine, hitLine) {
  const curOpacity = parseFloat(pulseLine.attr('opacity')) || 0.9;
  // Scale duration proportionally to remaining opacity (so half-faded lines finish faster)
  const dur = Math.round((curOpacity / 0.9) * 1200);
  pulseLine.transition('pulseFade').duration(dur).attr('opacity', 0).remove();
  hitLine.transition('pulseFade').duration(dur).remove();
}

function pausePulseLines() {
  const pulseGroup = linkGroup && linkGroup._pulseGroup;
  if (!pulseGroup) return;
  // Interrupt all running transitions — lines freeze at current opacity
  pulseGroup.selectAll('line').interrupt('pulseFade');
}

function resumePulseLines() {
  const pulseGroup = linkGroup && linkGroup._pulseGroup;
  if (!pulseGroup) return;
  // Collect pairs (visible pulse line + its hit-area sibling) and restart fade
  const allLines = pulseGroup.selectAll('line').nodes();
  for (let i = 0; i < allLines.length; i++) {
    const el = allLines[i];
    // Hit lines have class 'pulse-line', visible ones don't
    if (el.classList.contains('pulse-line')) continue; // skip hit lines, handle them via their sibling
    const pulseSel = d3.select(el);
    // The hit line is the previous sibling (we always append hitLine then pulseLine)
    const hitEl = el.previousElementSibling;
    if (hitEl && hitEl.classList.contains('pulse-line')) {
      _startPulseFade(pulseSel, d3.select(hitEl));
    } else {
      // Orphaned visible line — just fade it out
      pulseSel.transition('pulseFade').duration(600).attr('opacity', 0).remove();
    }
  }
}

function animateEdgePulse(edges) {
  const pulseGroup = linkGroup && linkGroup._pulseGroup;
  if (!pulseGroup || !edges.length) return;
  const colorMap = { rumor:'#E05252', correction:'#5294CC', hop:'#C85294' };
  const nodeMap = {};
  for (const n of graphNodes) nodeMap[n.id] = n;
  for (const edge of edges.slice(0, 20)) {
    const src = nodeMap[edge.source];
    const tgt = nodeMap[edge.target];
    if (!src || !tgt || (src.x === tgt.x && src.y === tgt.y)) continue;
    // Invisible wider hit-area line (10px) for easier hovering
    const hitLine = pulseGroup.append('line')
      .datum(edge)
      .attr('class', 'pulse-line')
      .attr('x1', src.x).attr('y1', src.y)
      .attr('x2', tgt.x).attr('y2', tgt.y)
      .attr('stroke', 'transparent')
      .attr('stroke-width', 10)
      .style('pointer-events', 'stroke');
    // Visible thin pulse line (no pointer events — hit area handles hover)
    const pulseLine = pulseGroup.append('line')
      .datum(edge)
      .attr('x1', src.x).attr('y1', src.y)
      .attr('x2', tgt.x).attr('y2', tgt.y)
      .attr('stroke', colorMap[edge.type] || '#E05252')
      .attr('stroke-width', 2)
      .attr('opacity', 0.9)
      .style('pointer-events', 'none');
    // Edge tooltip hover handlers (on the wide hit-area line)
    hitLine.on('mousemove', function(event) {
      const d = d3.select(this).datum();
      if (!d) return;
      const key = d.source + '-' + d.target;
      const cached = recentEdgeEvents.get(key) || d;
      // Generate message on demand for tooltip via message generation system
      if (!cached._tooltipMsg) {
        try {
          const scenario = cached.scenario || appState.lastConfig?.scenario || 'celebrity';
          const platform = cached.platform || appState.lastConfig?.seed_platform || 'twitter';
          const sType = cached.senderType || MT_AgentType.REGULAR;
          const eStr = cached.edgeStrength || 0.5;
          if (cached.isCorrection) {
            const cShape = (sType === MT_AgentType.FACT_CHECKER) ? MT_CorrectionShape.DEBUNK : MT_CorrectionShape.RELAY;
            cached._tooltipMsg = generateCorrectionMessage(cShape, scenario, null, platform);
          } else {
            const shape = selectRumorShape(sType, 0.5, 1, 0.5, eStr);
            let msg = generateMessage(shape, scenario, null, null, platform);
            msg = applyPlatformTone(msg, platform, shape, sType);
            cached._tooltipMsg = msg;
          }
        } catch(e) { cached._tooltipMsg = ''; }
      }
      cached.message = cached._tooltipMsg;
      showEdgeTooltip(event.clientX, event.clientY, cached);
    });
    // Start fade-out only if simulation is playing; if paused, lines stay visible
    if (appState.playing) {
      _startPulseFade(pulseLine, hitLine);
    }
  }
}

// ============================================================
// Step 5: Controls & Timeline
// ============================================================

// Theme
const html = document.documentElement;
document.getElementById('theme-toggle').addEventListener('click', () => {
  const isDark = html.getAttribute('data-theme') === 'dark';
  html.setAttribute('data-theme', isDark ? 'light' : 'dark');
  document.getElementById('theme-icon').className = isDark ? 'ph ph-sun' : 'ph ph-moon';
  // Re-render MC charts with new theme colors if data exists
  if (typeof _lastMCData !== 'undefined' && _lastMCData) requestAnimationFrame(() => updateMCResults(_lastMCData));
});

// Mode tabs
function setMode(mode) {
  appState.mode = mode;
  document.getElementById('tab-visual').classList.toggle('active', mode === 'visual');
  document.getElementById('tab-mc').classList.toggle('active', mode === 'mc');
  document.getElementById('main').style.display = mode === 'visual' ? 'grid' : 'none';
  document.getElementById('mc-dashboard').classList.toggle('active', mode === 'mc');
  document.getElementById('timeline').style.display = mode === 'visual' ? 'flex' : 'none';
}
document.getElementById('tab-visual').addEventListener('click', () => setMode('visual'));
document.getElementById('tab-mc').addEventListener('click', () => setMode('mc'));

// Right panel tabs
document.querySelectorAll('.rp-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.rp-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.rp-section').forEach(s => s.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById('sec-' + tab.dataset.tab).classList.add('active');
    // Create or resize Chart.js when Analytics tab becomes visible
    if (tab.dataset.tab === 'analytics') {
      requestAnimationFrame(() => {
        if (!spreadChart && spreadData.labels.length > 0) initSpreadChart();
        else if (spreadChart) { spreadChart.resize(); spreadChart.update(); }
      });
    }
  });
});

// Sliders
function wireSlider(sid, vid, fmt) {
  const sl = document.getElementById(sid), dsp = document.getElementById(vid);
  sl.addEventListener('input', () => { dsp.textContent = fmt(sl.value); });
}
wireSlider('sl-decay','sv-decay', v => parseFloat(v).toFixed(2));
wireSlider('sl-bots','sv-bots', v => Math.round(parseFloat(v)*100)+'%');
wireSlider('sl-correction','sv-correction', v => v+'m');
wireSlider('sl-chambers','sv-chambers', v => v);
wireSlider('sl-size','sv-size', v => v);

// Custom rumor panel toggle
document.getElementById('sel-scenario').addEventListener('change', function() {
  document.getElementById('custom-rumor-panel').style.display = this.value === 'custom' ? 'block' : 'none';
});
// Emotion sliders
['fear','outrage','humor','curiosity','urgency'].forEach(e => {
  wireSlider('sl-emo-' + e, 'sv-emo-' + e, v => parseFloat(v).toFixed(2));
});

function getCustomScenario() {
  const tag = document.getElementById('sel-custom-tag')?.value || 'campus';
  return {
    topic_tag: tag,
    text: document.getElementById('in-custom-text')?.value || 'Breaking news...',
    shortText: document.getElementById('in-custom-short')?.value || 'this',
    emotions: {
      fear: parseFloat(document.getElementById('sl-emo-fear')?.value || 0.3),
      outrage: parseFloat(document.getElementById('sl-emo-outrage')?.value || 0.2),
      humor: parseFloat(document.getElementById('sl-emo-humor')?.value || 0.3),
      curiosity: parseFloat(document.getElementById('sl-emo-curiosity')?.value || 0.7),
      urgency: parseFloat(document.getElementById('sl-emo-urgency')?.value || 0.5),
    },
    platform_affinity: { whatsapp: 0.5, twitter: 0.5, instagram: 0.5, reddit: 0.5 }
  };
}

// Platform → media default
document.getElementById('sel-platform').addEventListener('change', () => {
  const defs = { twitter:'text', whatsapp:'text', instagram:'reel', reddit:'text' };
  document.getElementById('sel-media').value = defs[document.getElementById('sel-platform').value] || 'text';
});

// Speed buttons
document.querySelectorAll('.speed-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    appState.speed = parseFloat(btn.dataset.speed);
    if (worker && appState.playing) worker.postMessage({ type: 'speed', speed: appState.speed });
  });
});

// Zoom controls
document.getElementById('zoom-in').addEventListener('click', () => {
  const svgNode = document.getElementById('main-graph');
  const svgSel = d3.select(svgNode);
  if (svgNode.__zoom_ref) svgSel.transition().duration(300).call(svgNode.__zoom_ref.scaleBy, 1.5);
});
document.getElementById('zoom-out').addEventListener('click', () => {
  const svgNode = document.getElementById('main-graph');
  const svgSel = d3.select(svgNode);
  if (svgNode.__zoom_ref) svgSel.transition().duration(300).call(svgNode.__zoom_ref.scaleBy, 0.67);
});
document.getElementById('zoom-reset').addEventListener('click', () => {
  const svgNode = document.getElementById('main-graph');
  const svgSel = d3.select(svgNode);
  if (svgNode.__zoom_ref) svgSel.transition().duration(300).call(svgNode.__zoom_ref.transform, d3.zoomIdentity);
});

// Transport
function updatePlayButton() {
  document.getElementById('play-icon').className = appState.playing ? 'ph-bold ph-pause' : 'ph-bold ph-play';
  document.getElementById('btn-play').classList.toggle('active', appState.playing);
}

document.getElementById('btn-play').addEventListener('click', () => {
  if (!worker) return;
  appState.playing = !appState.playing;
  updatePlayButton();
  if (appState.playing) {
    resumePulseLines();
  } else {
    pausePulseLines();
  }
  worker.postMessage({ type: appState.playing ? 'play' : 'pause', speed: appState.speed });
});

document.getElementById('btn-step').addEventListener('click', () => {
  if (worker) worker.postMessage({ type: 'step' });
});

document.getElementById('btn-stop').addEventListener('click', () => {
  appState.playing = false;
  updatePlayButton();
  pausePulseLines();
  if (worker) worker.postMessage({ type: 'pause' });
});

// Run button
document.getElementById('btn-run').addEventListener('click', () => {
  createWorker();
  const config = buildConfig();
  appState.maxTime = config.max_time;
  appState.simTime = 0;
  appState.lastConfig = config;
  mainRNG = new MainRNG(config.master_seed || Date.now()); // reseed for variety
  resetFeed();
  resetCharts();
  // Reset header stats
  document.getElementById('gs-believing').textContent = '0% believing';
  document.getElementById('gs-corrected').textContent = '0% corrected';
  document.getElementById('gs-r0').textContent = 'R0: --';
  worker.postMessage({ type: 'init', config });
  // Auto-play after short delay
  setTimeout(() => {
    appState.playing = true;
    updatePlayButton();
    worker.postMessage({ type: 'play', speed: appState.speed });
  }, 500);
});

// Reset button
document.getElementById('btn-reset').addEventListener('click', () => {
  appState.playing = false;
  updatePlayButton();
  if (worker) worker.postMessage({ type: 'reset' });
  if (svg) svg.selectAll('*').remove();
  nodeElements = null;
  linkElements = null;
  graphNodes = [];
  graphLinks = [];
  resetFeed();
  resetCharts();
  // Reset header stats bar
  document.getElementById('gs-believing').textContent = '0% believing';
  document.getElementById('gs-corrected').textContent = '0% corrected';
  document.getElementById('gs-r0').textContent = 'R0: --';
  document.getElementById('time-display').textContent = '0:00 / 0:00';
  document.getElementById('scrubber').value = 0;
  // Clear thumbnails
  for (const id of ['thumb-0','thumb-1','thumb-2']) {
    const c = document.getElementById(id);
    if (c) { const ctx = c.getContext('2d'); ctx.fillStyle = '#1A1A2E'; ctx.fillRect(0, 0, c.width, c.height); }
  }
});

// Scrubber
// Scrubber input handled by Phase 5 timeline scrub system below

// Timeline marker helpers
const markerColors = {
  rumor_seeded:'#E05252', mutation:'#D4A04A', correction_generated:'#5294CC',
  platform_hop:'#C85294', algorithmic_amplification:'#F0C040',
  super_spreader_event:'#FF6B35', crisis_start:'#9B5DE5',
  bot_detected:'#52B788', twitter_community_note:'#00B4D8', termination:'#4A4A5A'
};

function addTimelineMarker(time, type) {
  const pct = (time / appState.maxTime) * 100;
  const container = document.getElementById('timeline-markers');
  const dot = document.createElement('div');
  dot.className = 'timeline-marker';
  dot.style.left = pct + '%';
  dot.style.background = markerColors[type] || '#FFF';
  dot.setAttribute('data-tooltip', type.replace(/_/g, ' ') + ' @ ' + formatTime(time));
  container.appendChild(dot);
}

function formatTime(seconds) {
  const h = Math.floor(seconds / 3600);
  const m = Math.floor((seconds % 3600) / 60);
  return h + ':' + String(m).padStart(2, '0');
}

// ============================================================
// Phase 5 Step 1: Full Message Generation System
// ============================================================

// Main-thread enum/constant duplicates (worker is isolated)
const MT_AgentType = { REGULAR:'regular', INFLUENCER:'influencer', FACT_CHECKER:'fact_checker', BOT:'bot', LURKER:'lurker' };
const MT_NodeStatus = { UNAWARE:'unaware', BELIEVING:'believing', SILENT_BELIEVER:'silent_believer', CORRECTED:'corrected', IMMUNE:'immune', REMOVED:'removed' };
const MT_Platform = { WHATSAPP:'whatsapp', TWITTER:'twitter', INSTAGRAM:'instagram', REDDIT:'reddit' };
const MT_RumorShape = { BARE_FORWARD:'bare_forward', REACTION:'reaction', PERSONAL_FRAME:'personal_frame', ELABORATOR:'elaborator', SKEPTIC_SHARER:'skeptic_sharer' };
const MT_CorrectionShape = { DEBUNK:'debunk', RELAY:'relay', TOLD_YOU_SO:'told_you_so', RELUCTANT_WALKBACK:'reluctant_walkback' };
const MT_SCENARIOS = {
  celebrity: { text:'Breaking: Celebrity hospitalized after collapse', shortText:'the celebrity scandal' },
  financial: { text:'Major bank freezing all accounts immediately', shortText:'the bank crisis' },
  health:    { text:'New study reveals common food causes serious illness', shortText:'the health scare' },
  campus:    { text:'University to cancel entire semester unexpectedly', shortText:'the campus rumor' },
  custom:    { text:'Breaking news...', shortText:'this' },
};

// Lightweight main-thread RNG (copy of Mulberry32 core)
class MainRNG {
  constructor(seed) { this._state = seed >>> 0 || 1; }
  _next() {
    let t = (this._state += 0x6D2B79F5);
    t = Math.imul(t ^ (t >>> 15), t | 1);
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  }
  random() { return this._next(); }
  choice(arr) { return arr[Math.floor(this._next() * arr.length)]; }
  weightedChoice(arr, weights) {
    let total = 0;
    for (let i = 0; i < weights.length; i++) total += weights[i];
    let r = this._next() * total;
    for (let i = 0; i < weights.length; i++) {
      r -= weights[i];
      if (r <= 0) return arr[i];
    }
    return arr[arr.length - 1];
  }
}
let mainRNG = new MainRNG(Date.now());

// --- Layer 1: Standalone micro-messages ---
const LAYER1_POOLS = {
  fear: [
    "omg", "I'm literally shaking", "this can't be real", "no way", "WHAT",
    "I refuse to believe this", "I'm scared ngl", "please tell me this isn't true",
    "nah this can't be happening", "I literally cannot", "WAIT WHAT", "bro no",
    "someone please tell me this is fake", "I just got chills reading this",
    "this is NOT okay", "I feel sick reading this", "tell me this is photoshopped",
    "I'm not sleeping tonight", "genuinely terrified rn", "how is this not bigger news",
    "my stomach just dropped", "ok I'm panicking now"
  ],
  outrage: [
    "THIS IS INSANE", "how is nobody talking about this", "I'm so angry rn",
    "we need to do something", "absolute disgrace", "I can't believe they're getting away with this",
    "this is unacceptable", "WHERE IS THE MEDIA ON THIS", "I'm literally fuming",
    "how is this not front page news", "everyone needs to see this", "this is criminal",
    "this makes my blood boil", "I am DONE", "who approved this",
    "somebody needs to be fired", "justice system is a joke",
    "unfollowing anyone who defends this", "heads need to roll for this",
    "I have never been this angry at a post"
  ],
  humor: [
    "lmaooo no way", "this is the funniest thing", "I can't", "bro",
    "you can't make this up", "the timeline is unhinged today", "LMAO WHAT",
    "I'm crying", "this has to be satire right", "bro I'm DEAD",
    "ok but this is hilarious", "the memes write themselves",
    "this timeline never disappoints", "I needed this today", "peak internet moment",
    "whoever made this deserves an award", "tell me why this is trending",
    "I showed this to my roommate and they choked", "this is cinema",
    "the internet was a mistake lmaooo"
  ],
  curiosity: [
    "wait is this actually real?", "hold on what", "huh???",
    "has anyone confirmed this", "I need more info", "source?",
    "ok wait I need to know more", "is there any proof?", "someone explain this",
    "I keep seeing this everywhere", "anyone else seeing this??",
    "ok but WHERE did this start", "following this thread",
    "can someone fact check this", "bookmarking for later",
    "wait there's more to this", "I have questions", "the plot thickens",
    "ok I went down the rabbit hole and"
  ],
  urgency: [
    "RIGHT NOW", "hurry", "don't wait", "this is happening TODAY",
    "CHECK YOUR ACCOUNT", "move fast", "PLEASE SHARE THIS",
    "TIME IS RUNNING OUT", "do this NOW before it's too late",
    "drop everything and read this", "this is urgent",
    "BREAKING", "WE NEED TO TALK ABOUT THIS", "don't ignore this",
    "this affects YOU", "this is not a drill", "set your alarms",
    "before midnight", "I'm not kidding this is happening RIGHT NOW"
  ]
};

// --- Layer 2: Sentence-level building blocks ---
const LAYER2_POOLS = {
  personal_frames: [
    "my cousin works at {relevant_place} and confirmed this",
    "someone I trust just told me", "I didn't want to believe it but",
    "so apparently", "I just heard from a friend that",
    "a guy at work was saying", "my {family_member} just sent me this",
    "ok so I've been reading about this and",
    "not gonna lie I was skeptical at first but",
    "a reliable source told me", "I know someone who works there and",
    "you won't believe what I just heard", "my neighbor was telling me",
    "I was at {relevant_place} and overheard something",
    "someone in my group chat sent this", "I just got off the phone and",
    "ok don't quote me on this but", "apparently this has been going on for a while",
    "this person I follow posted about it", "my classmate's parent works there and",
    "I saw this on another platform too", "just got a text about this"
  ],
  claim_details: {
    celebrity: [
      "they said it happened last night",
      "the family hasn't made a statement yet",
      "there are photos from the hospital",
      "their last post was 6 hours ago, nothing since",
      "the manager's phone is going straight to voicemail",
      "sources close to them confirmed it",
      "their publicist just released a statement",
      "the paparazzi photos are all over",
      "they were spotted at the ER entrance",
      "their co-star just posted a cryptic story",
      "fans are gathering outside",
      "their label cancelled upcoming appearances",
      "their spotify activity went silent",
      "there's a video from a fan outside the venue",
      "security was seen rushing in",
      "their ex just tweeted something vague",
      "TMZ hasn't confirmed yet but it's looking real",
      "their latest collab partner just unfollowed them"
    ],
    financial: [
      "the bank's website is down",
      "ATMs aren't dispensing cash",
      "employees were told not to come in tomorrow",
      "there's a line outside the branch already",
      "the stock is crashing as we speak",
      "they froze all wire transfers",
      "people are panic-selling", "the CEO just resigned without explanation",
      "the app is showing error codes",
      "international transfers are being blocked",
      "the regulators called an emergency meeting",
      "my financial advisor told me to move everything",
      "there are armored trucks outside the branch",
      "the after-hours trading is insane right now",
      "credit cards from that bank are declining",
      "their customer service line is just dead air",
      "insider trading alerts are going off",
      "the stock halted twice already today"
    ],
    health: [
      "a doctor posted about it on Twitter",
      "the WHO hasn't denied it",
      "my neighbor tried it and said it worked",
      "the government is hiding the real numbers",
      "hospitals are overwhelmed right now",
      "they're trying to suppress this information",
      "people in the comments are reporting symptoms",
      "the recall notice just went out",
      "my doctor friend said to avoid it completely",
      "the FDA page was updated quietly last night",
      "emergency rooms are seeing a spike",
      "the study was funded by their competitor though",
      "pharmacies are pulling it from shelves",
      "the original researcher just retracted their paper",
      "insurance companies are flagging claims related to it",
      "there's a class action forming already",
      "local news picked it up but national is silent",
      "the symptoms match what my friend had last month"
    ],
    campus: [
      "someone from admin told my friend",
      "there's a notice going around",
      "check the university portal",
      "the professors were told this morning",
      "it's on the dean's schedule apparently",
      "the student union confirmed it",
      "campus security sent an alert",
      "the email chain is wild right now",
      "someone leaked the internal memo",
      "the TA confirmed it in discussion section",
      "the course catalog just got updated",
      "alumni are freaking out too",
      "the parking lot was blocked off this morning",
      "the library closed early with no explanation",
      "there's a petition going around with 500 signatures",
      "the campus newspaper is running a story on it",
      "professor hasn't responded to emails in days",
      "the discord server is going crazy about this"
    ]
  },
  amplifiers: [
    "and nobody is talking about it", "the media is covering it up",
    "this is being deleted everywhere", "they don't want you to know",
    "share this before it gets taken down", "wake up people",
    "why isn't anyone reporting this", "do your own research",
    "THEY are trying to bury this", "screenshot before it gets removed",
    "funny how the timing works out huh", "follow the money",
    "mainstream media won't touch this", "this is just the tip of the iceberg",
    "connecting some dots here"
  ],
  skeptic_hedges: [
    "I don't know if this is true but",
    "take this with a grain of salt",
    "can anyone verify this?",
    "this seems off but",
    "not sure I believe this however",
    "I'm skeptical but",
    "this could be fake but",
    "I want to believe this is fake but",
    "normally I'd dismiss this kind of thing but",
    "I really hope this isn't true",
    "someone please debunk this",
    "not usually one to share stuff like this but"
  ],
  call_to_actions: [
    "stay safe everyone", "check your accounts NOW",
    "tell your family", "spread the word",
    "be careful out there", "pass this on",
    "everyone needs to hear this",
    "look out for each other", "keep your eyes open",
    "don't let them bury this", "screenshot and save",
    "tell everyone you know"
  ]
};

// --- Layer 3: Word-level swaps ---
const LAYER3_SWAPS_SIMPLE = {
  'my cousin': ['my friend', 'someone I know', 'a guy at work', 'my coworker', 'my neighbor'],
  'confirmed': ['verified', 'said', 'swore', 'told me', 'guaranteed'],
  'look at this': ['check this out', 'have you seen this', 'you need to see this'],
  'just told me': ['just messaged me', 'just called me about this', 'texted me'],
  'going around': ['spreading', 'making the rounds', 'blowing up', 'circulating'],
  'apparently': ['supposedly', 'allegedly', 'I heard that', 'word is'],
};
const LAYER3_FAMILY = ['mom', 'dad', 'uncle', 'aunt', 'brother', 'sister', 'grandma', 'roommate', 'partner'];
const LAYER3_PLACES = {
  celebrity: ['the hospital', 'the studio', 'their agency', 'the venue', 'their management company', 'the after-party', 'the private jet terminal'],
  financial: ['the bank', 'the head office', 'the trading floor', 'corporate', 'the call center', 'the downtown branch', 'the investor meeting'],
  health: ['the hospital', 'the clinic', 'the research lab', 'the pharmacy', 'the testing center', 'the urgent care', 'the health department'],
  campus: ['the registrar', 'admin', "the dean's office", 'the department', 'student affairs', 'the provost office', 'the campus clinic']
};

function applySwaps(text, scenario) {
  let result = text;
  for (const [pattern, replacements] of Object.entries(LAYER3_SWAPS_SIMPLE)) {
    if (result.includes(pattern)) result = result.replace(pattern, mainRNG.choice(replacements));
  }
  if (result.includes('{family_member}')) result = result.replace('{family_member}', mainRNG.choice(LAYER3_FAMILY));
  if (result.includes('{relevant_place}')) {
    const places = LAYER3_PLACES[scenario] || LAYER3_PLACES.celebrity;
    result = result.replace('{relevant_place}', mainRNG.choice(places));
  }
  return result;
}

// --- Correction pools ---
const CORRECTION_POOLS = {
  debunk: [
    "FACT CHECK: The claim about {topic} is FALSE. Here's what actually happened...",
    "DEBUNKED: There is no evidence for {topic}. Original source was fabricated.",
    "This is misinformation. {topic} has been thoroughly fact-checked and found false.",
    "Official statement confirms {topic} claim is completely unfounded.",
    "FALSE. The original claim about {topic} has no credible source.",
    "Nope. {topic} has been debunked by multiple fact-checkers.",
    "Stop sharing this. The {topic} story is completely made up.",
    "Just checked \u2014 {topic} is false. Here's the actual source..."
  ],
  relay: [
    "turns out that thing about {topic} was fake, someone debunked it",
    "PSA: the {topic} story is false. Fact-checkers confirmed.",
    "heads up -- that {topic} thing going around is fake",
    "so apparently the {topic} story was debunked",
    "update: {topic} was debunked, passing it along",
    "just saw that {topic} was fake, FYI",
    "the {topic} thing is false apparently, just letting people know",
    "saw a fact-check on {topic}, it's not real"
  ],
  told_you_so: [
    "called it. knew this was fake from the start",
    "I said this was fake and I was right",
    "surprise surprise... it was fake all along",
    "not to say I told you so but... I told you so",
    "I KNEW IT. fake from day one.",
    "yeah no. I wasn't buying {topic} for a second",
    "this is exactly what I said. nobody listens.",
    "and there it is. {topic} was fake. shocking."
  ],
  reluctant_walkback: [
    "ok apparently I was wrong about that... my bad for spreading it",
    "turns out I fell for it too. sorry for sharing",
    "well this is embarrassing. it was fake. deleting my post.",
    "I take back what I said earlier... it's been debunked",
    "ugh I shared the {topic} thing and it's fake. sorry everyone",
    "I need to correct myself on {topic}... it's not true",
    "feel pretty dumb for sharing that {topic} post ngl",
    "ok so {topic} turned out to be fake. I apologize for spreading it"
  ]
};

// --- Media type references ---
const MEDIA_REFS = {
  text: [],
  image: ['look at this screenshot', 'check this photo', 'the image is going around', 'someone posted a picture'],
  video: ['did you see that video of...', 'watch this', "there's a video going around"],
  reel: ['that reel about {topic} is everywhere', 'someone made a reel about this', 'this reel is blowing up']
};

// --- Emotion helpers ---
const EMOTION_NAMES = ['fear', 'outrage', 'humor', 'curiosity', 'urgency'];
const EMOTION_COLORS_MAP = { fear:'#E05252', outrage:'#D4644A', humor:'#52B788', curiosity:'#5294CC', urgency:'#E8C547' };

function getDominantEmotion(emotions) {
  if (!emotions) return 'curiosity';
  // emotions can be array [f,o,h,c,u] or object {fear,outrage,...}
  let vals, keys;
  if (Array.isArray(emotions)) {
    vals = emotions;
    keys = EMOTION_NAMES;
  } else {
    keys = Object.keys(emotions);
    vals = keys.map(k => emotions[k]);
  }
  let maxI = 0;
  for (let i = 1; i < vals.length; i++) { if (vals[i] > vals[maxI]) maxI = i; }
  return keys[maxI] || 'curiosity';
}

function emotionDotProduct(a, b) {
  if (!a || !b) return 0;
  const av = Array.isArray(a) ? a : EMOTION_NAMES.map(k => a[k] || 0);
  const bv = Array.isArray(b) ? b : EMOTION_NAMES.map(k => b[k] || 0);
  let s = 0;
  for (let i = 0; i < Math.min(av.length, bv.length); i++) s += av[i] * bv[i];
  return s;
}

// --- Shape selection ---
function selectRumorShape(senderType, emotionalIntensity, timesExposed, effectiveThreshold, edgeStrength) {
  if (senderType === MT_AgentType.BOT) return MT_RumorShape.BARE_FORWARD;
  if (emotionalIntensity > 0.7 && timesExposed <= 2) return MT_RumorShape.REACTION;
  if (senderType === MT_AgentType.INFLUENCER) return MT_RumorShape.ELABORATOR;
  if (effectiveThreshold > 0.6) return MT_RumorShape.SKEPTIC_SHARER;
  if (edgeStrength > 0.7) return MT_RumorShape.PERSONAL_FRAME;
  return mainRNG.weightedChoice(
    [MT_RumorShape.BARE_FORWARD, MT_RumorShape.REACTION, MT_RumorShape.PERSONAL_FRAME, MT_RumorShape.ELABORATOR, MT_RumorShape.SKEPTIC_SHARER],
    [0.3, 0.2, 0.25, 0.1, 0.15]
  );
}

function selectCorrectionShape(senderType, wasBeliever, senderStatus) {
  if (senderType === MT_AgentType.FACT_CHECKER) return MT_CorrectionShape.DEBUNK;
  if (wasBeliever) return MT_CorrectionShape.RELUCTANT_WALKBACK;
  if (senderStatus === MT_NodeStatus.CORRECTED) return MT_CorrectionShape.RELAY;
  return MT_CorrectionShape.TOLD_YOU_SO;
}

// --- Main message assembly ---
function generateMessage(shape, scenario, emotions, scenarioText, platform) {
  const dominantEmotion = getDominantEmotion(emotions);
  const pool1 = LAYER1_POOLS[dominantEmotion] || LAYER1_POOLS.curiosity;
  const claims = LAYER2_POOLS.claim_details[scenario] || LAYER2_POOLS.claim_details.celebrity;

  switch (shape) {
    case MT_RumorShape.BARE_FORWARD: {
      if (mainRNG.random() < 0.5) return mainRNG.choice(pool1);
      return scenarioText || (MT_SCENARIOS[scenario]?.text || 'Breaking news...');
    }
    case MT_RumorShape.REACTION: {
      const msg = mainRNG.choice(pool1);
      if (mainRNG.random() < 0.3) return msg + ' ' + mainRNG.choice(pool1);
      return msg;
    }
    case MT_RumorShape.PERSONAL_FRAME: {
      let msg = mainRNG.choice(LAYER2_POOLS.personal_frames);
      msg += '. ' + mainRNG.choice(claims);
      if (mainRNG.random() < 0.4) msg += '. ' + mainRNG.choice(LAYER2_POOLS.call_to_actions);
      return applySwaps(msg, scenario);
    }
    case MT_RumorShape.ELABORATOR: {
      let msg = mainRNG.choice([
        "Ok so I've been reading about this for an hour and here's what I think...",
        'Thread: why this is bigger than you think',
        'Let me break this down for you all',
        "I've been looking into this and it's worse than we thought",
        "Storytime. So this whole thing goes deeper than you think.",
        "I spent the last hour looking into this and wow",
        "LONG POST but please read the whole thing",
        "Hear me out because this is actually wild",
        "Nobody is putting the pieces together so let me do it",
        "This is going to sound crazy but stay with me"
      ]);
      msg += '\n\n' + mainRNG.choice(claims) + '. ' + mainRNG.choice(LAYER2_POOLS.amplifiers);
      if (mainRNG.random() < 0.5) msg += '\n\n' + mainRNG.choice(claims);
      return applySwaps(msg, scenario);
    }
    case MT_RumorShape.SKEPTIC_SHARER: {
      let msg = mainRNG.choice(LAYER2_POOLS.skeptic_hedges);
      msg += ' ' + mainRNG.choice(claims);
      msg += '. ' + mainRNG.choice(['can anyone verify?', 'anyone else hearing this?', "I'm not sure about this one", 'thoughts?', 'does this seem legit to anyone?', 'waiting for an official source', 'something feels off about this', 'idk what to believe anymore']);
      return applySwaps(msg, scenario);
    }
    default:
      return mainRNG.choice(pool1);
  }
}

function generateCorrectionMessage(corrShape, scenario) {
  const topicText = MT_SCENARIOS[scenario]?.shortText || 'this';
  const pool = CORRECTION_POOLS[corrShape] || CORRECTION_POOLS.relay;
  return mainRNG.choice(pool).replace(/\{topic\}/g, topicText);
}

// --- Platform tone modifiers ---
function applyPlatformTone(message, platform, shape, senderType) {
  switch (platform) {
    case 'whatsapp':
      if (shape === MT_RumorShape.ELABORATOR && mainRNG.random() < 0.3)
        message = mainRNG.choice(['Good morning\n', 'Urgent message\n', 'Please read\n', 'FYI\n']) + message;
      if (senderType === MT_AgentType.BOT || shape === MT_RumorShape.BARE_FORWARD)
        message = 'Forwarded\n' + message;
      break;
    case 'twitter':
      message = message.substring(0, 280);
      if (shape === MT_RumorShape.ELABORATOR) message = '1/ ' + message;
      if (mainRNG.random() < 0.3) message += ' ' + mainRNG.choice(['#breaking', '#thread', '#viral', '#developing']);
      break;
    case 'instagram':
      if (mainRNG.random() < 0.3) message += mainRNG.choice([' (link in bio)', ' \u{1F517} in bio', ' swipe up']);
      break;
    case 'reddit':
      if (shape === MT_RumorShape.ELABORATOR) message = mainRNG.choice(['Edit: adding more context\n\n', 'UPDATE:\n\n', 'Edit 2: more info below\n\n']) + message;
      if (shape === MT_RumorShape.SKEPTIC_SHARER) message += mainRNG.choice([' [citation needed]', ' [UNVERIFIED]', ' [Developing Story]', ' [Take with grain of salt]']);
      break;
  }
  return message;
}

// --- Media reference ---
function addMediaReference(message, mediaType, scenario) {
  if (mediaType === 'text' || mainRNG.random() > 0.6) return message;
  const refs = MEDIA_REFS[mediaType];
  if (!refs || refs.length === 0) return message;
  const topicText = MT_SCENARIOS[scenario]?.shortText || 'this';
  return message + '\n\n' + mainRNG.choice(refs).replace(/\{topic\}/g, topicText);
}

// --- Media card HTML generation ---
const EMOTION_GRADIENTS = {
  fear: 'linear-gradient(135deg, #8B2020 0%, #4a1a1a 100%)',
  outrage: 'linear-gradient(135deg, #8B4020 0%, #4a2a1a 100%)',
  humor: 'linear-gradient(135deg, #206B20 0%, #1a3a1a 100%)',
  curiosity: 'linear-gradient(135deg, #20508B 0%, #1a2a4a 100%)',
  urgency: 'linear-gradient(135deg, #8B6B20 0%, #4a3a1a 100%)'
};

function generateMediaCard(mediaType, scenario, dominantEmotion) {
  if (!mediaType || mediaType === 'text') return '';
  const gradient = EMOTION_GRADIENTS[dominantEmotion] || EMOTION_GRADIENTS.fear;
  const claimText = MT_SCENARIOS[scenario]?.text || 'Breaking news...';

  switch (mediaType) {
    case 'image':
      return '<div class="media-card" style="background:' + gradient + '">' +
        '<i class="ph ph-image" style="font-size:18px;color:white"></i>' +
        '<span style="color:white;font-weight:600;font-size:11px">' + claimText + '</span></div>';
    case 'video':
      return '<div class="media-card" style="background:' + gradient + '">' +
        '<i class="ph ph-play-circle" style="font-size:24px;color:white"></i>' +
        '<div><span style="color:white;font-weight:600;font-size:11px">' + claimText + '</span>' +
        '<span style="color:rgba(255,255,255,0.6);font-size:10px;display:block">0:47</span></div></div>';
    case 'reel':
      return '<div class="media-card media-card-reel" style="background:' + gradient + '">' +
        '<i class="ph ph-film-reel" style="font-size:18px;color:white"></i>' +
        '<span style="color:white;font-size:10px">12.4K views</span></div>';
    default:
      return '';
  }
}

function generateScreenshotCard(sourcePlatform, message) {
  const icons = { twitter:'ph-twitter-logo', whatsapp:'ph-whatsapp-logo', instagram:'ph-instagram-logo', reddit:'ph-reddit-logo' };
  return '<div class="media-card media-card-screenshot">' +
    '<div class="source-platform"><i class="ph ' + (icons[sourcePlatform] || 'ph-globe') + '"></i> from ' + (sourcePlatform || '?') + '</div>' +
    '<div style="font-size:12px;margin-top:4px">' + (message || '').substring(0, 80) + '</div></div>';
}

// --- Generate a feed-level message for an event ---
// --- Static event variant pools ---
const MUTATION_MSGS = [
  'Rumor mutated to v{ver} \u2014 emotional tone shifted',
  'v{ver}: the story changed as it spread, new emotional angle',
  'Mutation spotted \u2014 version {ver} has a different vibe now',
  'The rumor evolved into v{ver}, sentiment drifted during forwarding',
  'v{ver} detected \u2014 the message morphed as people retold it',
  'New variant v{ver} emerged with altered emotional framing',
  'Story mutated at v{ver} \u2014 the narrative shifted slightly',
  'v{ver}: telephone effect kicked in, message changed tone'
];
const AMP_MSGS = [
  'Algorithm boosted this on {platform} \u2014 {count} new accounts reached',
  '{platform} algorithm picked it up, pushed to {count} extra users',
  'Trending boost on {platform}: +{count} non-follower reach',
  'Algo kicked in on {platform}, {count} people outside the bubble saw this',
  '{platform} amplification triggered \u2014 {count} additional reach',
  'The {platform} algorithm is spreading this to {count} new users now'
];
const CRISIS_MSGS = [
  'Crisis event triggered \u2014 spread dynamics intensifying',
  'External crisis started, people are more susceptible now',
  'Crisis mode active \u2014 correction delays doubled',
  'A real-world crisis event just made everyone more anxious',
  'Crisis event: heightened emotional state across the network',
  'Breaking crisis \u2014 the network is on edge, sharing accelerates'
];
const BOT_MSGS = [
  'Bot Node {id} flagged and removed from the network',
  'Suspicious activity \u2014 Node {id} identified as bot, removed',
  'Node {id} caught as a bot account, pulled from circulation',
  'Bot detected: Node {id} was spreading too fast, now removed',
  'Automated account Node {id} spotted and taken down',
  'Node {id} removed \u2014 behavior pattern matched known bot signatures'
];
const COMMUNITY_NOTE_MSGS = [
  'Community note added on Twitter \u2014 context provided',
  'Twitter users flagged this, community note now attached',
  'A community note was added with fact-check context',
  'Readers added context to this tweet via community notes',
  'Community note: multiple users flagged this as misleading',
  'This tweet now has a community note with corrections'
];
const SSE_MSGS = [
  'Super-spreader event \u2014 a high-reach node just blasted this out',
  'SSE triggered: one account just reached thousands',
  'Viral moment \u2014 this hit a super-spreader node',
  'A major account just amplified this to their entire following',
  'Super-spreader cascade: engagement spike detected',
  'This just went viral through a high-influence node'
];

function generateFeedMessage(evt) {
  const scenario = evt.details?.scenario || appState.lastConfig?.scenario || 'celebrity';
  const platform = evt.platform || appState.lastConfig?.seed_platform || 'twitter';
  const mediaType = evt.details?.media_type || appState.lastConfig?.media_type || 'text';

  // For custom scenarios, update MT_SCENARIOS with current UI values and resolve the topic tag for claim_details
  let claimScenario = scenario;
  if (scenario === 'custom') {
    MT_SCENARIOS.custom.text = document.getElementById('in-custom-text')?.value || 'Breaking news...';
    MT_SCENARIOS.custom.shortText = document.getElementById('in-custom-short')?.value || 'this';
    claimScenario = document.getElementById('sel-custom-tag')?.value || 'campus';
  }

  // For rumor-like events: generate a shaped message
  if (evt.type === 'node_infected' || evt.type === 'rumor_seeded') {
    const senderType = evt.details?.sender_type || MT_AgentType.REGULAR;
    const edgeStrength = evt.details?.edge_strength || 0.5;
    const emotions = evt.details?.emotions;
    const shape = selectRumorShape(senderType, 0.5, 1, 0.5, edgeStrength);
    let msg = generateMessage(shape, claimScenario, emotions, null, platform);
    msg = applyPlatformTone(msg, platform, shape, senderType);
    msg = addMediaReference(msg, mediaType, claimScenario);
    return { text: msg, shape, mediaCard: generateMediaCard(mediaType, claimScenario, getDominantEmotion(emotions)) };
  }

  // For correction events
  if (evt.type === 'correction_generated' || evt.type === 'node_corrected') {
    const corrShape = (evt.details?.sender_type === MT_AgentType.FACT_CHECKER)
      ? MT_CorrectionShape.DEBUNK : MT_CorrectionShape.RELAY;
    const msg = generateCorrectionMessage(corrShape, scenario);
    return { text: msg, shape: corrShape, mediaCard: '' };
  }

  // For platform hops
  if (evt.type === 'platform_hop') {
    const srcPlat = evt.details?.source_platform || '?';
    const dstPlat = evt.details?.dest_platform || '?';
    const shape = MT_RumorShape.BARE_FORWARD;
    const msg = generateMessage(shape, claimScenario, null, null, dstPlat);
    const screenshot = generateScreenshotCard(srcPlat, MT_SCENARIOS[scenario]?.text || 'Breaking...');
    return { text: msg, shape, mediaCard: screenshot };
  }

  // For mutations
  if (evt.type === 'mutation') {
    const ver = (evt.details || {}).new_version || '?';
    return { text: mainRNG.choice(MUTATION_MSGS).replace(/\{ver\}/g, ver), shape: null, mediaCard: '' };
  }

  // For super-spreader events
  if (evt.type === 'super_spreader_event') {
    return { text: mainRNG.choice(SSE_MSGS), shape: null, mediaCard: '' };
  }

  // For algorithmic amplification
  if (evt.type === 'algorithmic_amplification') {
    const plat = evt.platform || '?';
    const count = (evt.details || {}).boost_count || 0;
    return { text: mainRNG.choice(AMP_MSGS).replace(/\{platform\}/g, plat).replace(/\{count\}/g, count), shape: null, mediaCard: '' };
  }

  // For crisis start
  if (evt.type === 'crisis_start') {
    return { text: mainRNG.choice(CRISIS_MSGS), shape: null, mediaCard: '' };
  }

  // For bot detected
  if (evt.type === 'bot_detected') {
    const id = evt.nodeId != null ? evt.nodeId : '?';
    return { text: mainRNG.choice(BOT_MSGS).replace(/\{id\}/g, id), shape: null, mediaCard: '' };
  }

  // For community notes
  if (evt.type === 'twitter_community_note') {
    return { text: mainRNG.choice(COMMUNITY_NOTE_MSGS), shape: null, mediaCard: '' };
  }

  return null; // non-message events use default
}

// ============================================================
// Step 6: Feed Panel
// ============================================================

const feedContainer = document.getElementById('feed-container');
let feedEvents = [];
let feedAutoScroll = true;
const MAX_FEED = 500;
const majorEventTypes = new Set(['rumor_seeded','mutation','super_spreader_event','correction_generated','platform_hop','algorithmic_amplification','crisis_start','bot_detected','whatsapp_self_correction','twitter_community_note']);
const feedIcons = {
  rumor_seeded:'ph-bold ph-megaphone', mutation:'ph-bold ph-dna', correction_generated:'ph-bold ph-shield-check',
  platform_hop:'ph-bold ph-arrows-left-right', algorithmic_amplification:'ph-bold ph-trend-up',
  super_spreader_event:'ph-bold ph-lightning', crisis_start:'ph-bold ph-warning',
  bot_detected:'ph-bold ph-robot', node_infected:'ph ph-user-plus', node_corrected:'ph ph-check-circle',
  rumor_rejected:'ph ph-x-circle', whatsapp_self_correction:'ph-bold ph-magnifying-glass',
  twitter_community_note:'ph-bold ph-note',
  termination:'ph-bold ph-flag-checkered',
};
const feedTypeClass = {
  rumor_seeded:'type-rumor', mutation:'type-mutation', correction_generated:'type-correction',
  platform_hop:'type-hop', algorithmic_amplification:'type-amp', crisis_start:'type-crisis',
};

function resetFeed() {
  feedEvents = [];
  seenEventTimes = new Set();
  feedContainer.innerHTML = '<div class="feed-event major type-rumor" style="opacity:0.4;text-align:center;padding:32px;"><i class="ph ph-play-circle" style="font-size:32px;display:block;margin-bottom:8px;"></i>Run a simulation to see events</div>';
  document.getElementById('timeline-markers').innerHTML = '';
}

// Feed filter state (Phase 5 Step 4)
const feedFilters = { type: 'all', platform: 'all' };
const feedFilterTypeMap = {
  rumor: ['rumor_seeded', 'node_infected', 'super_spreader_event', 'algorithmic_amplification'],
  correction: ['correction_generated', 'node_corrected', 'whatsapp_self_correction', 'twitter_community_note'],
  mutation: ['mutation'],
  hop: ['platform_hop']
};

function matchesFeedFilter(evt) {
  if (feedFilters.type !== 'all') {
    const allowed = feedFilterTypeMap[feedFilters.type];
    if (allowed && !allowed.includes(evt.type)) return false;
  }
  if (feedFilters.platform !== 'all') {
    if (evt.platform && evt.platform !== feedFilters.platform) return false;
  }
  return true;
}

function renderFeedCardHTML(evt) {
  const isMajor = majorEventTypes.has(evt.type);
  const icon = feedIcons[evt.type] || 'ph ph-circle';
  const timeStr = formatTime(evt.time);
  const platformBadge = evt.platform ? `<span class="feed-platform-badge">${evt.platform}</span>` : '';

  // Try to generate a rich message for major events
  let richMsg = null;
  if (isMajor) richMsg = generateFeedMessage(evt);

  if (richMsg && richMsg.text) {
    const typeClass = feedTypeClass[evt.type] || '';
    const cardColor = { rumor_seeded:'card-pink', mutation:'card-green', correction_generated:'card-blue',
      platform_hop:'card-lavender', algorithmic_amplification:'card-yellow', crisis_start:'card-yellow',
      bot_detected:'card-lavender', whatsapp_self_correction:'card-blue', twitter_community_note:'card-blue',
      super_spreader_event:'card-pink' }[evt.type] || '';
    return `<div class="feed-event major ${typeClass} ${cardColor}" data-time="${evt.time}">
      <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;">
        <i class="feed-icon ${icon}"></i>
        <span style="font-weight:600;font-size:11px;text-transform:uppercase;letter-spacing:0.3px">${evt.type.replace(/_/g, ' ')}</span>
        <span class="feed-time" style="margin-left:auto">${timeStr}</span>
        ${platformBadge}
      </div>
      <div class="feed-card-message">${richMsg.text}</div>
      ${richMsg.mediaCard || ''}
      <div class="feed-card-meta">Node #${evt.nodeId != null ? evt.nodeId : '?'}${evt.targetId != null ? ' from #' + evt.targetId : ''}</div>
    </div>`;
  }

  // Fallback: simple format for non-major or events without rich messages
  let msg = evt.type.replace(/_/g, ' ');
  if (evt.type === 'node_infected') msg = `Node ${evt.nodeId} believed (from ${evt.targetId})`;
  else if (evt.type === 'node_corrected') msg = `Node ${evt.nodeId} corrected`;
  else if (evt.type === 'rumor_seeded') msg = `Rumor seeded at Node ${evt.nodeId}`;
  else if (evt.type === 'mutation') msg = mainRNG.choice(MUTATION_MSGS).replace(/\{ver\}/g, (evt.details||{}).new_version||'?');
  else if (evt.type === 'platform_hop') msg = `Hop: ${(evt.details||{}).source_platform||'?'} -> ${(evt.details||{}).dest_platform||'?'}`;
  else if (evt.type === 'algorithmic_amplification') msg = mainRNG.choice(AMP_MSGS).replace(/\{platform\}/g, evt.platform||'?').replace(/\{count\}/g, (evt.details||{}).boost_count||0);
  else if (evt.type === 'correction_generated') msg = `FC Node ${evt.nodeId} generated correction`;
  else if (evt.type === 'bot_detected') msg = mainRNG.choice(BOT_MSGS).replace(/\{id\}/g, evt.nodeId);
  else if (evt.type === 'crisis_start') msg = mainRNG.choice(CRISIS_MSGS);
  else if (evt.type === 'twitter_community_note') msg = mainRNG.choice(COMMUNITY_NOTE_MSGS);
  else if (evt.type === 'super_spreader_event') msg = mainRNG.choice(SSE_MSGS);
  else if (evt.type === 'termination') msg = `Simulation ended: ${(evt.details||{}).reason||'unknown'}`;

  const cls = isMajor ? 'major' : 'compact';
  const typeC = feedTypeClass[evt.type] || '';
  return `<div class="feed-event ${cls} ${typeC}" data-time="${evt.time}"><span class="feed-time">${timeStr}</span><i class="feed-icon ${icon}"></i> ${msg} ${platformBadge}</div>`;
}

function addFeedEvent(evt) {
  if (feedEvents.length === 0) feedContainer.innerHTML = '';
  feedEvents.push(evt);
  if (feedEvents.length > MAX_FEED) { feedEvents.shift(); if (feedContainer.firstChild) feedContainer.removeChild(feedContainer.firstChild); }

  // Only render if it passes current filter
  if (matchesFeedFilter(evt)) {
    feedContainer.insertAdjacentHTML('beforeend', renderFeedCardHTML(evt));
  }

  // Add timeline marker for major events
  const isMajor = majorEventTypes.has(evt.type);
  if (isMajor || evt.type === 'termination') addTimelineMarker(evt.time, evt.type);

  // Auto-scroll
  if (feedAutoScroll) {
    const rp = document.querySelector('.rp-content');
    if (rp) rp.scrollTop = rp.scrollHeight;
  }
}

// Re-render feed from stored events (used by filters and timeline scrub)
function rerenderFeed(maxTime) {
  feedContainer.innerHTML = '';
  const evts = maxTime != null ? feedEvents.filter(e => e.time <= maxTime) : feedEvents;
  for (const evt of evts) {
    if (matchesFeedFilter(evt)) {
      feedContainer.insertAdjacentHTML('beforeend', renderFeedCardHTML(evt));
    }
  }
  if (feedAutoScroll) {
    const rp = document.querySelector('.rp-content');
    if (rp) rp.scrollTop = rp.scrollHeight;
  }
}

// Wire up filter buttons (Phase 5 Step 4)
document.querySelectorAll('#feed-filters .filter-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('#feed-filters .filter-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    feedFilters.type = btn.dataset.filter;
    rerenderFeed();
  });
});
document.getElementById('feed-platform-filter').addEventListener('change', (e) => {
  feedFilters.platform = e.target.value;
  rerenderFeed();
});

// Feed jump button
document.getElementById('feed-jump').addEventListener('click', () => {
  feedAutoScroll = true;
  const rp = document.querySelector('.rp-content');
  if (rp) rp.scrollTop = rp.scrollHeight;
  document.getElementById('feed-jump').style.display = 'none';
});

document.querySelector('.rp-content').addEventListener('scroll', (e) => {
  const el = e.target;
  const atBottom = el.scrollHeight - el.scrollTop - el.clientHeight < 50;
  feedAutoScroll = atBottom;
  document.getElementById('feed-jump').style.display = atBottom ? 'none' : 'block';
});

// ============================================================
// Step 7: Analytics Dashboard + Concepts Panel
// ============================================================

let spreadChart = null;
const spreadData = { labels: [], believing: [], corrected: [], silent: [] };

function resetCharts() {
  spreadData.labels = [];
  spreadData.believing = [];
  spreadData.corrected = [];
  spreadData.silent = [];
  if (spreadChart) { spreadChart.destroy(); spreadChart = null; }
  document.getElementById('stat-believing').textContent = '--';
  document.getElementById('stat-corrected').textContent = '--';
  document.getElementById('stat-silent').textContent = '--';
  document.getElementById('stat-bots').textContent = '--';
  document.getElementById('r0-value').textContent = '--';
  document.getElementById('r0-value').className = 'r0-value';
  for (const id of ['cv-poisson','cv-service','cv-bernoulli','cv-decay','cv-emotion','cv-bias','cv-queue','cv-r0','cv-cred','cv-framing','cv-attention']) {
    document.getElementById(id).textContent = '--';
  }
}

function initSpreadChart() {
  const ctx = document.getElementById('chart-spread').getContext('2d');
  spreadChart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: spreadData.labels,
      datasets: [
        { label: 'Believing', data: spreadData.believing, borderColor: '#E05252', backgroundColor: 'rgba(224,82,82,0.1)', fill: true, tension: 0.3, pointRadius: 0, borderWidth: 2 },
        { label: 'Corrected', data: spreadData.corrected, borderColor: '#5294CC', backgroundColor: 'rgba(82,148,204,0.1)', fill: true, tension: 0.3, pointRadius: 0, borderWidth: 2 },
        { label: 'Silent', data: spreadData.silent, borderColor: '#D4A04A', backgroundColor: 'rgba(212,160,74,0.1)', fill: true, tension: 0.3, pointRadius: 0, borderWidth: 2 },
      ]
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      plugins: { legend: { labels: { font: { family: "'Satoshi'", size: 10 }, boxWidth: 12 } } },
      scales: {
        x: { display: true, ticks: { font: { family: "'JetBrains Mono'", size: 9 }, maxTicksLimit: 6 }, grid: { display: false } },
        y: { display: true, min: 0, max: 100, ticks: { font: { family: "'JetBrains Mono'", size: 9 }, callback: v => v + '%' }, grid: { color: 'rgba(0,0,0,0.05)' } }
      },
      animation: { duration: 0 }
    }
  });
}

function updateAnalytics(snapshot) {
  if (!snapshot || !snapshot.stats) return;
  const s = snapshot.stats;
  const n = snapshot.status.length;
  document.getElementById('stat-believing').textContent = Math.round(s.believing / n * 100) + '%';
  document.getElementById('stat-corrected').textContent = Math.round(s.corrected / n * 100) + '%';
  document.getElementById('stat-silent').textContent = Math.round(s.silent / n * 100) + '%';
  document.getElementById('stat-bots').textContent = s.botsDetected;
  const r0El = document.getElementById('r0-value');
  // Show peak R0 if current is 0 but peak exists (sim ended)
  const displayR0 = (s.r0 < 0.01 && s.r0Peak > 0) ? s.r0Peak : s.r0;
  const isPeak = (s.r0 < 0.01 && s.r0Peak > 0);
  r0El.textContent = displayR0.toFixed(2);
  r0El.className = 'r0-value ' + (displayR0 > 1 ? 'high' : 'low');
  document.getElementById('r0-label-title').textContent = isPeak ? 'Peak R0' : 'Effective R0';
  document.getElementById('r0-label-sub').textContent = isPeak ? 'Maximum reached during sim' : 'Reproduction number';
  // Graph stats overlay
  document.getElementById('gs-believing').textContent = Math.round(s.infectionRate * 100) + '% believing';
  document.getElementById('gs-corrected').textContent = Math.round(s.corrected / n * 100) + '% corrected';
  document.getElementById('gs-r0').textContent = (isPeak ? 'Peak R0: ' : 'R0: ') + displayR0.toFixed(1);
  // Spread chart
  const timeLabel = formatTime(snapshot.time);
  spreadData.labels.push(timeLabel);
  spreadData.believing.push(Math.round(s.believing / n * 100));
  spreadData.corrected.push(Math.round(s.corrected / n * 100));
  spreadData.silent.push(Math.round(s.silent / n * 100));
  // Limit data points
  if (spreadData.labels.length > 200) {
    spreadData.labels.shift(); spreadData.believing.shift(); spreadData.corrected.shift(); spreadData.silent.shift();
  }
  // Only create/update chart when Analytics section is visible
  const analyticsVisible = document.getElementById('sec-analytics').classList.contains('active');
  if (analyticsVisible) {
    if (!spreadChart) initSpreadChart();
    else spreadChart.update();
  }
}

function updateConcepts(snapshot) {
  if (!snapshot || !snapshot.concepts) return;
  const c = snapshot.concepts;
  document.getElementById('cv-poisson').textContent = c.poisson.toFixed(1) + '/min';
  document.getElementById('cv-service').textContent = c.service.toFixed(0) + 's';
  document.getElementById('cv-bernoulli').textContent = (c.bernoulli * 100).toFixed(1) + '%';
  document.getElementById('cv-decay').textContent = c.decay.toFixed(2);
  document.getElementById('cv-emotion').textContent = c.emotion.toFixed(2);
  document.getElementById('cv-bias').textContent = c.bias.toFixed(2);
  document.getElementById('cv-queue').textContent = c.queue.toFixed(3);
  const cvR0 = (c.r0 < 0.01 && snapshot.stats.r0Peak > 0) ? snapshot.stats.r0Peak : c.r0;
  document.getElementById('cv-r0').textContent = cvR0.toFixed(2) + ((c.r0 < 0.01 && snapshot.stats.r0Peak > 0) ? ' pk' : '');
  document.getElementById('cv-cred').textContent = c.cred.toFixed(2);
  document.getElementById('cv-framing').textContent = '+' + (c.framing * 100).toFixed(0) + '%';
  document.getElementById('cv-attention').textContent = c.attention.toFixed(2);
  // Flash recently changed concepts
  document.querySelectorAll('.concept-item').forEach(el => {
    el.classList.remove('flash');
    const val = el.querySelector('.concept-value');
    if (val && val.textContent !== '--' && val._prev !== val.textContent) {
      el.classList.add('flash');
      setTimeout(() => el.classList.remove('flash'), 600);
    }
    if (val) val._prev = val.textContent;
  });
}

// ============================================================
// Step 8: Monte Carlo Mode
// ============================================================

let mcHistChart = null, mcConvergenceChart = null, mcDeathChart = null, mcR0Chart = null;

// Retro CRT chart styling — theme-aware palettes
const retroPalettes = {
  dark: {
    grid: 'rgba(5,217,232,0.06)',
    tick: 'rgba(209,247,255,0.5)',
    pink: '#ff2a6d',
    cyan: '#05d9e8',
    amber: '#ff9e00',
    green: '#01ff89',
    ice: '#d1f7ff',
    tooltipBg: '#0f0f1a',
    tooltipBorder: 'rgba(5,217,232,0.3)',
    barGradTop: 'rgba(255,42,109,0.85)',
    barGradBottom: 'rgba(255,42,109,0.15)',
    r0GradTop: 'rgba(255,158,0,0.35)',
    r0GradBottom: 'rgba(255,158,0,0.02)',
    r0Glow: 'rgba(255,158,0,0.15)',
    convGlow: 'rgba(255,42,109,0.2)',
    convCIBorder: 'rgba(255,42,109,0.25)',
    convCIFill: 'rgba(255,42,109,0.06)',
    stackedLabelColor: '#0a0a12',
    deathStarved: '#6a6a8a',
    deathDecayed: '#9b5de5',
  },
  light: {
    grid: 'rgba(10,124,140,0.08)',
    tick: '#5a5a72',
    pink: '#d42257',
    cyan: '#0a7c8c',
    amber: '#c47800',
    green: '#0d8a50',
    ice: '#1a1a2e',
    tooltipBg: '#fffdf8',
    tooltipBorder: 'rgba(10,124,140,0.3)',
    barGradTop: 'rgba(212,34,87,0.75)',
    barGradBottom: 'rgba(212,34,87,0.12)',
    r0GradTop: 'rgba(196,120,0,0.3)',
    r0GradBottom: 'rgba(196,120,0,0.03)',
    r0Glow: 'rgba(196,120,0,0.12)',
    convGlow: 'rgba(212,34,87,0.12)',
    convCIBorder: 'rgba(212,34,87,0.2)',
    convCIFill: 'rgba(212,34,87,0.06)',
    stackedLabelColor: '#fffdf8',
    deathStarved: '#8a8a9e',
    deathDecayed: '#7b4db8',
  }
};

function getRetroTheme() {
  const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
  return isDark ? retroPalettes.dark : retroPalettes.light;
}

// Shared font config (same for both themes)
const retroFonts = {
  tickFont: { family: "'JetBrains Mono', monospace", size: 9 },
  titleFont: { family: "'JetBrains Mono', monospace", size: 10, weight: '600' },
};

// Backwards-compatible accessor (reads current theme)
Object.defineProperty(window, 'retroChart', { get() {
  const t = getRetroTheme();
  return { ...t, tickFont: retroFonts.tickFont, titleFont: retroFonts.titleFont };
}});

// Shared retro tooltip config (theme-aware)
function getRetroTooltip() {
  const t = getRetroTheme();
  return {
    backgroundColor: t.tooltipBg,
    borderColor: t.tooltipBorder,
    borderWidth: 1,
    titleFont: { family: "'JetBrains Mono', monospace", size: 11, weight: '600' },
    bodyFont: { family: "'JetBrains Mono', monospace", size: 10 },
    titleColor: t.cyan,
    bodyColor: t.ice,
    padding: 10,
    cornerRadius: 3,
    displayColors: true,
    boxPadding: 3,
  };
}

// Shared retro scale config (reads current theme)
function retroScales(opts) {
  const t = getRetroTheme();
  const base = {
    x: {
      ticks: { color: t.tick, font: retroFonts.tickFont },
      grid: { color: t.grid, drawBorder: false },
    },
    y: {
      ticks: { color: t.tick, font: retroFonts.tickFont },
      grid: { color: t.grid, drawBorder: false, borderDash: [1, 4] },
    }
  };
  if (opts) {
    if (opts.xTitle) base.x.title = { display: true, text: opts.xTitle, color: t.tick, font: retroFonts.titleFont };
    if (opts.yTitle) base.y.title = { display: true, text: opts.yTitle, color: t.tick, font: retroFonts.titleFont };
    if (opts.yMax !== undefined) base.y.max = opts.yMax;
    if (opts.yBeginAtZero) base.y.beginAtZero = true;
    if (opts.xGrid === false) base.x.grid = { display: false };
    if (opts.yGrid === false) base.y.grid = { display: false };
    if (opts.stacked) { base.x.stacked = true; base.y.stacked = true; }
    if (opts.indexAxis === 'y') {
      const tmp = base.x; base.x = base.y; base.y = tmp;
    }
  }
  return base;
}

// Gaussian KDE for smooth density curves
function kernelDensityEstimate(data, nPoints, bandwidth) {
  if (!data.length) return [];
  const min = Math.min(...data), max = Math.max(...data);
  const range = max - min || 1;
  const step = range / (nPoints - 1);
  const points = [];
  for (let i = 0; i < nPoints; i++) {
    const x = min - range * 0.05 + i * (range * 1.1) / (nPoints - 1);
    let density = 0;
    for (const d of data) {
      const z = (x - d) / bandwidth;
      density += Math.exp(-0.5 * z * z);
    }
    density /= (data.length * bandwidth * Math.sqrt(2 * Math.PI));
    points.push({ x: parseFloat(x.toFixed(3)), y: density });
  }
  return points;
}

// Chart.js plugin: sparkline annotation markers (vertical dashed lines)
const retroSparklinePlugin = {
  id: 'retroSparklines',
  afterDraw(chart) {
    const markers = chart.options.plugins?.retroSparklines?.markers;
    if (!markers || !markers.length) return;
    const { ctx } = chart;
    const xScale = chart.scales.x;
    const yScale = chart.scales.y;
    for (const m of markers) {
      const xPixel = xScale.getPixelForValue(m.value);
      if (xPixel < xScale.left || xPixel > xScale.right) continue;
      ctx.save();
      ctx.strokeStyle = m.color || getRetroTheme().cyan;
      ctx.lineWidth = 1.5;
      ctx.setLineDash(m.dash || [4, 3]);
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.moveTo(xPixel, yScale.top);
      ctx.lineTo(xPixel, yScale.bottom);
      ctx.stroke();
      // Label
      if (m.label) {
        ctx.setLineDash([]);
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = m.color || getRetroTheme().cyan;
        ctx.font = "9px 'JetBrains Mono', monospace";
        ctx.textAlign = 'center';
        ctx.fillText(m.label, xPixel, yScale.top - 4);
      }
      ctx.restore();
    }
  }
};

// Chart.js plugin: inline labels for stacked bar segments
const retroStackedLabelsPlugin = {
  id: 'retroStackedLabels',
  afterDraw(chart) {
    if (!chart.options.plugins?.retroStackedLabels?.enabled) return;
    const { ctx } = chart;
    chart.data.datasets.forEach((ds, dsIdx) => {
      const meta = chart.getDatasetMeta(dsIdx);
      meta.data.forEach((bar, idx) => {
        const value = ds.data[idx];
        if (value < 3) return; // skip tiny segments
        const { x, y, width, height } = bar.getProps(['x', 'y', 'width', 'height']);
        const barW = bar.width;
        if (barW < 28) return; // too narrow for text
        ctx.save();
        ctx.fillStyle = getRetroTheme().stackedLabelColor;
        ctx.font = "bold 9px 'JetBrains Mono', monospace";
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(value.toFixed(0) + '%', bar.x, bar.y);
        ctx.restore();
      });
    });
  }
};

document.querySelectorAll('.mc-count-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.mc-count-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
  });
});

let mcBatchStartTime = 0;
document.getElementById('btn-mc-run').addEventListener('click', () => {
  createWorker();
  const config = buildConfig();
  const nRuns = parseInt(document.querySelector('.mc-count-btn.active').dataset.count) || 100;
  document.getElementById('mc-progress').style.display = 'block';
  document.getElementById('mc-progress').textContent = 'Starting batch...';
  mcBatchStartTime = performance.now();
  worker.postMessage({ type: 'monte_carlo', config, nRuns });
});

function updateMCProgress(data) {
  const pct = Math.round(data.run / data.total * 100);
  const elapsed = (performance.now() - mcBatchStartTime) / 1000;
  const eta = data.run > 10 ? Math.round((data.total - data.run) * (elapsed / data.run)) : '?';
  document.getElementById('mc-progress').textContent = `Run ${data.run}/${data.total} -- Mean: ${(data.mean*100).toFixed(1)}% +/- ${(data.ci*100).toFixed(1)}% -- ~${eta}s remaining`;
  document.getElementById('mc-mean').textContent = (data.mean * 100).toFixed(1) + '%';
  document.getElementById('mc-ci').textContent = (data.ciLow * 100).toFixed(1) + '-' + (data.ciHigh * 100).toFixed(1) + '%';
}

let _lastMCData = null;
function updateMCResults(data) {
  _lastMCData = data;
  document.getElementById('mc-progress').textContent = `Complete: ${data.nRuns} runs`;
  document.getElementById('mc-mean').textContent = (data.mean * 100).toFixed(1) + '%';
  document.getElementById('mc-ci').textContent = (data.ciLow * 100).toFixed(1) + '-' + (data.ciHigh * 100).toFixed(1) + '%';
  document.getElementById('mc-median').textContent = (data.median * 100).toFixed(1) + '%';
  document.getElementById('mc-r0').textContent = data.meanR0.toFixed(2);

  // Theme-aware palette
  const t = getRetroTheme();
  const tip = getRetroTooltip();

  // ---- A. Infection Rate Histogram (gradient bars + sparkline markers) ----
  if (mcHistChart) mcHistChart.destroy();
  const bins = 20;
  const binCounts = new Array(bins).fill(0);
  for (const r of data.rates) { const idx = Math.min(bins - 1, Math.floor(r * bins)); binCounts[idx]++; }
  const binLabels = Array.from({length: bins}, (_, i) => (i * 100 / bins).toFixed(0) + '%');
  const histCtx = document.getElementById('mc-chart-hist').getContext('2d');
  const histGrad = histCtx.createLinearGradient(0, 0, 0, 220);
  histGrad.addColorStop(0, t.barGradTop);
  histGrad.addColorStop(1, t.barGradBottom);
  const histMeanBin = Math.min(bins - 1, Math.floor(data.mean * bins));
  const histMedianBin = Math.min(bins - 1, Math.floor(data.median * bins));
  mcHistChart = new Chart(histCtx, {
    type: 'bar',
    data: { labels: binLabels, datasets: [{
      label: 'Frequency', data: binCounts,
      backgroundColor: histGrad, borderColor: t.pink, borderWidth: 1, borderRadius: 3,
    }] },
    plugins: [retroSparklinePlugin],
    options: {
      responsive: true, maintainAspectRatio: false,
      animation: {
        duration: 900,
        easing: 'easeOutQuart',
        delay(ctx) { return ctx.type === 'data' ? ctx.dataIndex * 40 : 0; },
      },
      plugins: {
        legend: { display: false },
        tooltip: tip,
        retroSparklines: {
          markers: [
            { value: histMeanBin, color: t.cyan, label: 'MEAN', dash: [4, 3] },
            { value: histMedianBin, color: t.amber, label: 'MED', dash: [2, 2] },
          ]
        }
      },
      scales: retroScales({ yBeginAtZero: true, xGrid: false }),
    }
  });

  // ---- B. Death Type — Horizontal Stacked Bar ----
  if (mcDeathChart) mcDeathChart.destroy();
  const deathLabels = Object.keys(data.deaths);
  const deathValues = Object.values(data.deaths);
  const totalDeaths = deathValues.reduce((s, v) => s + v, 0) || 1;
  const deathPcts = deathValues.map(v => (v / totalDeaths * 100));
  const neonDeathColors = {
    starved: t.deathStarved, corrected: t.cyan, saturated: t.pink,
    mutated_away: t.amber, time_decayed: t.deathDecayed, still_alive: t.green,
  };
  const deathDatasets = deathLabels.map((label, i) => ({
    label: label.replace(/_/g, ' '),
    data: [deathPcts[i]],
    backgroundColor: neonDeathColors[label] || '#666',
    borderWidth: 0,
    borderRadius: i === 0 ? { topLeft: 4, bottomLeft: 4 } : (i === deathLabels.length - 1 ? { topRight: 4, bottomRight: 4 } : 0),
    borderSkipped: false,
  }));
  mcDeathChart = new Chart(document.getElementById('mc-chart-death').getContext('2d'), {
    type: 'bar',
    data: { labels: [''], datasets: deathDatasets },
    plugins: [retroStackedLabelsPlugin],
    options: {
      indexAxis: 'y', responsive: true, maintainAspectRatio: false,
      animation: {
        duration: 800,
        easing: 'easeOutCubic',
        delay(ctx) { return ctx.type === 'data' ? ctx.datasetIndex * 80 : 0; },
      },
      plugins: {
        legend: {
          position: 'bottom',
          labels: { color: t.tick, font: retroFonts.tickFont, boxWidth: 12, padding: 12 },
        },
        tooltip: { ...tip, callbacks: { label: (ctx) => ctx.dataset.label + ': ' + ctx.raw.toFixed(1) + '%' } },
        retroStackedLabels: { enabled: true },
      },
      scales: {
        x: { stacked: true, max: 100, display: false },
        y: { stacked: true, display: false },
      },
      barPercentage: 0.6,
    }
  });

  // ---- C. R0 Distribution — Density Curve ----
  if (mcR0Chart) mcR0Chart.destroy();
  const r0Bandwidth = 0.15;
  const kdePoints = kernelDensityEstimate(data.r0s, 60, r0Bandwidth);
  const r0Ctx = document.getElementById('mc-chart-r0').getContext('2d');
  const r0Grad = r0Ctx.createLinearGradient(0, 0, 0, 220);
  r0Grad.addColorStop(0, t.r0GradTop);
  r0Grad.addColorStop(1, t.r0GradBottom);
  const glowData = kdePoints.map(p => ({ x: p.x, y: p.y * 1.05 }));
  const meanR0Val = data.meanR0;
  mcR0Chart = new Chart(r0Ctx, {
    type: 'scatter',
    data: {
      datasets: [
        { label: 'Glow', data: glowData, showLine: true, borderColor: t.r0Glow, borderWidth: 6, pointRadius: 0, tension: 0.4, fill: false, order: 2 },
        { label: 'R0 Density', data: kdePoints, showLine: true, borderColor: t.amber, borderWidth: 2, pointRadius: 0, tension: 0.4, fill: true, backgroundColor: r0Grad, order: 1 },
      ]
    },
    plugins: [retroSparklinePlugin],
    options: {
      responsive: true, maintainAspectRatio: false,
      animation: {
        duration: 1200,
        easing: 'easeOutQuart',
        x: { duration: 1200, from: NaN },
        y: { duration: 1200, from: (ctx) => ctx.chart.scales.y.getPixelForValue(0) },
      },
      plugins: {
        legend: { display: false },
        tooltip: { ...tip, callbacks: { label: (ctx) => 'R0: ' + ctx.parsed.x.toFixed(2) + '  Density: ' + ctx.parsed.y.toFixed(4) } },
        retroSparklines: {
          markers: [
            { value: meanR0Val, color: t.cyan, label: 'MEAN R0', dash: [4, 3] },
          ]
        }
      },
      scales: {
        x: {
          type: 'linear',
          title: { display: true, text: 'R0', color: t.tick, font: retroFonts.titleFont },
          ticks: { color: t.tick, font: retroFonts.tickFont },
          grid: { color: t.grid, borderDash: [1, 4] },
        },
        y: {
          title: { display: true, text: 'Density', color: t.tick, font: retroFonts.titleFont },
          ticks: { color: t.tick, font: retroFonts.tickFont },
          grid: { color: t.grid, borderDash: [1, 4] },
          beginAtZero: true,
        }
      }
    }
  });

  // ---- D. Convergence Plot — Phosphor Glow + Angular Line ----
  if (mcConvergenceChart) mcConvergenceChart.destroy();
  const convLabels = [], convMeans = [], convUpper = [], convLower = [], convGlow = [];
  for (let i = 10; i <= data.nRuns; i += Math.max(1, Math.floor(data.nRuns / 50))) {
    const subset = data.rates.slice(0, i);
    const m = subset.reduce((s, v) => s + v, 0) / subset.length;
    let v = 0; for (const r of subset) v += (r - m) ** 2;
    v /= Math.max(subset.length - 1, 1);
    const ci = 1.96 * Math.sqrt(v) / Math.sqrt(subset.length);
    convLabels.push(i);
    convMeans.push(m * 100);
    convGlow.push(m * 100 + 0.3);
    convUpper.push((m + ci) * 100);
    convLower.push((m - ci) * 100);
  }
  mcConvergenceChart = new Chart(document.getElementById('mc-chart-convergence').getContext('2d'), {
    type: 'line',
    data: {
      labels: convLabels,
      datasets: [
        { label: 'Glow', data: convGlow, borderColor: t.convGlow, borderWidth: 8, pointRadius: 0, tension: 0.1, fill: false, order: 3 },
        { label: 'Mean', data: convMeans, borderColor: t.pink, borderWidth: 2.5, pointRadius: 0, pointStyle: 'rect', tension: 0.1, fill: false, order: 1 },
        { label: 'CI Upper', data: convUpper, borderColor: t.convCIBorder, borderWidth: 1, pointRadius: 0, fill: '+1', backgroundColor: t.convCIFill, tension: 0.1, order: 2 },
        { label: 'CI Lower', data: convLower, borderColor: t.convCIBorder, borderWidth: 1, pointRadius: 0, fill: false, tension: 0.1, order: 2 },
      ]
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      animation: {
        duration: 1400,
        easing: 'easeOutQuart',
        x: { duration: 1400 },
        y: { duration: 800, delay: 400 },
      },
      plugins: {
        legend: {
          labels: {
            color: t.tick, font: retroFonts.tickFont,
            filter: (item) => item.text !== 'Glow',
          }
        },
        tooltip: tip,
      },
      scales: retroScales({ xTitle: 'Runs', yTitle: 'Infection %' }),
    }
  });

  // Phase 5 Step 7: Notable Run Detection
  const mcResults = data.rates.map((r, i) => ({ finalInfectionRate: r, duration: data.durations ? data.durations[i] : null }));
  const notable = detectNotableRuns(mcResults);
  if (notable.length > 0) {
    const notableEl = document.getElementById('notable-runs');
    if (notableEl) {
      notableEl.innerHTML = '';
      notableEl.classList.remove('hidden');
      const header = document.createElement('div');
      header.style.cssText = 'font-weight:600;font-size:11px;text-transform:uppercase;letter-spacing:0.3px;color:var(--text-muted);margin-bottom:8px';
      header.innerHTML = '<i class="ph ph-star"></i> Notable Runs';
      notableEl.appendChild(header);
      for (const n of notable) {
        const card = document.createElement('div');
        card.className = 'notable-run-card';
        card.innerHTML = '<span class="notable-seed">Run #' + (n.runIndex + 1) + '</span> <span class="notable-reasons">' + n.reasons.join(', ') + '</span>';
        notableEl.appendChild(card);
      }
    }
  }
}

// ============================================================
// Master Update — called on each snapshot
// ============================================================

let seenEventTimes = new Set();

function updateVisualization(snapshot) {
  if (!snapshot) return;
  // Update node colors
  updateNodeColors(snapshot.status);
  // Edge pulses + cache edge events for tooltips (Phase 5)
  if (snapshot.edges) updateEdgeEvents(snapshot.edges);
  animateEdgePulse(snapshot.edges || []);
  // Timeline scrubber
  const pct = Math.min(1000, (snapshot.time / appState.maxTime) * 1000);
  document.getElementById('scrubber').value = pct;
  document.getElementById('time-display').textContent = formatTime(snapshot.time) + ' / ' + formatTime(appState.maxTime);
  // Feed events + Phase 5 advanced visualizations
  if (snapshot.recentEvents) {
    for (const evt of snapshot.recentEvents) {
      const key = evt.time + '_' + evt.type + '_' + evt.nodeId + '_' + (evt.targetId || '');
      if (!seenEventTimes.has(key)) {
        seenEventTimes.add(key);
        addFeedEvent(evt);
        if (seenEventTimes.size > 2000) {
          const iter = seenEventTimes.values();
          for (let i = 0; i < 500; i++) { const v = iter.next().value; seenEventTimes.delete(v); }
        }
        // Phase 5 Step 7: Trigger advanced visualizations
        if (evt.type === 'bot_detected') visualizeBotDetection(evt.nodeId);
        if (evt.type === 'unfollow') visualizeUnfollow(evt.nodeId, evt.targetId);
        if (evt.type === 'seek_connection') visualizeSeek(evt.nodeId, evt.targetId);
      }
    }
  }
  // Analytics (throttle to every 5th update)
  if (!updateVisualization._counter) updateVisualization._counter = 0;
  updateVisualization._counter++;
  if (updateVisualization._counter % 5 === 0) {
    updateAnalytics(snapshot);
    updateConcepts(snapshot);
    // Phase 5: Update overview panels if in overview mode
    if (appState.layoutMode === 'overview') renderOverviewPanels(snapshot);
    if (appState.layoutMode === 'compare') renderCompareChart();
    if (appState.layoutMode === 'enhanced') updateEnhancedHulls();
  }
}

// ============================================================
// Phase 5: Post-Sim Analysis Buttons
// ============================================================

function addSimAnalysisButtons() {
  const container = document.getElementById('feed-container');
  if (!container) return;
  // Check if analysis buttons already exist
  if (container.querySelector('.sim-analysis-buttons')) return;
  const btnRow = document.createElement('div');
  btnRow.className = 'sim-analysis-buttons';
  btnRow.style.cssText = 'display:flex;gap:8px;padding:8px 12px;border-top:1px solid var(--border-light)';
  btnRow.innerHTML = '<button class="filter-btn" id="btn-critical-path" style="flex:1"><i class="ph ph-path"></i> Critical Path</button>' +
    '<button class="filter-btn" id="btn-mutation-chain" style="flex:1"><i class="ph ph-dna"></i> Mutation Chain</button>';
  container.appendChild(btnRow);
  document.getElementById('btn-critical-path').addEventListener('click', () => {
    if (worker) worker.postMessage({ type: 'requestCriticalPath' });
  });
  document.getElementById('btn-mutation-chain').addEventListener('click', () => {
    if (worker) worker.postMessage({ type: 'requestMutationChain' });
  });
}

// ============================================================
// Phase 5 Step 2: Node Inspection Popup
// ============================================================

const nodePopup = document.getElementById('node-popup');
const nodePopupBody = document.getElementById('np-body');

function hideNodePopup() {
  nodePopup.classList.add('hidden');
}

document.getElementById('np-close').addEventListener('click', hideNodePopup);
document.addEventListener('click', (e) => {
  if (!e.target.closest('.node-popup') && !e.target.closest('circle') && !e.target.closest('.popup-value.clickable')) {
    hideNodePopup();
  }
});

function handleNodeData(msg) {
  const { nodeId, nodeState, events } = msg;
  if (!nodeState) return;
  const ns = nodeState;
  const typeIcons = { regular:'ph-user', influencer:'ph-star', fact_checker:'ph-shield-check', bot:'ph-robot', lurker:'ph-eye-slash' };
  const typeLabels = { regular:'Regular User', influencer:'Influencer', fact_checker:'Fact-Checker', bot:'Bot', lurker:'Lurker' };

  document.getElementById('np-icon').className = 'ph ' + (typeIcons[ns.agent_type] || 'ph-user');
  document.getElementById('np-title').textContent = 'Node #' + nodeId;
  const badge = document.getElementById('np-badge');
  badge.textContent = typeLabels[ns.agent_type] || ns.agent_type;
  badge.className = 'agent-type-badge badge-' + ns.agent_type;

  // Build body HTML
  let html = '';

  // Identity section
  html += '<div class="popup-section">';
  html += '<div class="popup-row"><span class="popup-label">Echo Chamber</span><span class="popup-value">Bubble #' + ns.echo_chamber_idx + '</span></div>';
  html += '<div class="popup-row"><span class="popup-label">Connections</span><span class="popup-value">' + ns.connections + (ns.rewiring_events > 0 ? ' <span style="color:var(--text-muted)">(rewired: ' + ns.rewiring_events + ')</span>' : '') + '</span></div>';
  html += '<div class="popup-row"><span class="popup-label">Demographic</span><span class="popup-value">' + ns.age_group + ' &middot; DN: ' + ns.digital_nativity.toFixed(2) + '</span></div>';
  html += '<div class="popup-row"><span class="popup-label">Platforms</span><span class="popup-value">' + (ns.platforms || []).join(', ') + '</span></div>';
  html += '</div>';

  // Worldview section (4D bars)
  const wvLabels = ['Political', 'Health Trust', 'Tech Trust', 'Auth. Trust'];
  html += '<div class="popup-section"><div class="popup-section-title">Worldview</div><div class="worldview-bars">';
  for (let i = 0; i < 4; i++) {
    const val = ns.worldview_vector[i] || 0;
    // For political: range -1 to 1, map to 0-100% with midpoint
    // For others: range 0 to 1
    let pct;
    if (i === 0) {
      pct = ((val + 1) / 2 * 100).toFixed(0);
    } else {
      pct = (val * 100).toFixed(0);
    }
    html += '<div class="bar-row"><span class="bar-label">' + wvLabels[i] + '</span>';
    html += '<div class="bar-track"><div class="bar-fill" style="width:' + pct + '%"></div></div>';
    html += '<span class="bar-val">' + val.toFixed(2) + '</span></div>';
  }
  html += '</div></div>';

  // Emotional susceptibility
  html += '<div class="popup-section"><div class="popup-section-title">Emotional Susceptibility</div>';
  for (let i = 0; i < 5; i++) {
    const orig = ns.original_susceptibility[i] || 0;
    const curr = ns.susceptibility[i] || 0;
    const diff = curr - orig;
    const annotation = Math.abs(diff) < 0.01 ? '(stable)' : (diff > 0 ? '(primed +' + diff.toFixed(2) + ')' : '(fatigued ' + diff.toFixed(2) + ')');
    html += '<div class="emotion-row"><span class="emotion-name" style="color:' + (EMOTION_COLORS_MAP[EMOTION_NAMES[i]] || 'inherit') + '">' + EMOTION_NAMES[i] + '</span>';
    html += '<span class="emotion-vals">' + orig.toFixed(2) + (Math.abs(diff) >= 0.01 ? ' &rarr; ' + curr.toFixed(2) : '') + '</span>';
    html += '<span class="emotion-annotation">' + annotation + '</span></div>';
  }
  html += '</div>';

  // Threshold & Modifiers
  html += '<div class="popup-section"><div class="popup-section-title">Belief State</div>';
  html += '<div class="popup-row"><span class="popup-label">Base Threshold</span><span class="popup-value mono">' + ns.credibility_threshold.toFixed(3) + '</span></div>';
  html += '<div class="popup-row"><span class="popup-label">Effective Threshold</span><span class="popup-value mono">' + ns.effective_threshold.toFixed(3) + '</span></div>';
  html += '<div class="popup-row"><span class="popup-label">Trust Decay</span><span class="popup-value mono">x0.90^' + ns.times_exposed + ' (' + ns.times_exposed + ' exposures)</span></div>';
  html += '</div>';

  // Attention & Queue
  const attPct = (ns.attention_budget * 100).toFixed(0);
  const attColor = ns.attention_budget > 0.5 ? '#52B788' : ns.attention_budget > 0.3 ? '#E8C547' : '#E05252';
  html += '<div class="popup-section">';
  html += '<div class="popup-row"><span class="popup-label">Attention Budget</span><div class="attention-bar"><div class="attention-track"><div class="attention-fill" style="width:' + attPct + '%;background:' + attColor + '"></div></div><span class="attention-value">' + ns.attention_budget.toFixed(2) + '</span></div></div>';
  html += '<div class="popup-row"><span class="popup-label">Corrections Seen</span><span class="popup-value mono">' + ns.times_correction_seen + '</span></div>';
  html += '</div>';

  // Status
  html += '<div class="popup-section">';
  html += '<div class="popup-row"><span class="popup-label">Status</span><span class="status-indicator ' + ns.status + '">' + ns.status.replace(/_/g, ' ') + '</span></div>';
  if (ns.rumor_version != null && ns.status !== 'unaware') {
    html += '<div class="popup-row"><span class="popup-label">Rumor Version</span><span class="popup-value">v' + ns.rumor_version + '</span></div>';
  }
  if (ns.infected_by !== null) {
    html += '<div class="popup-row"><span class="popup-label">Infected by</span><span class="popup-value clickable" data-node="' + ns.infected_by + '">Node #' + ns.infected_by + '</span></div>';
  }
  html += '<div class="popup-row"><span class="popup-label">Downstream</span><span class="popup-value">' + ns.downstream_infections + ' infections</span></div>';
  html += '</div>';

  // Message Inbox
  html += '<div class="popup-section popup-inbox"><div class="popup-section-title">Message Inbox (' + events.length + ')</div><div class="inbox-messages">';
  if (events.length === 0) {
    html += '<div style="color:var(--text-muted);font-size:11px;padding:8px">No messages received yet</div>';
  } else {
    const scenario = appState.lastConfig?.scenario || 'celebrity';
    for (const evt of events) {
      const tieLabel = evt.edgeStrength > 0.7 ? 'strong tie' : evt.edgeStrength > 0.3 ? 'weak tie' : 'stranger';
      // Generate message text
      const shape = selectRumorShape(evt.senderType || 'regular', 0.5, 1, evt.effectiveThreshold || 0.5, evt.edgeStrength);
      const msgText = generateMessage(shape, evt.rumor?.scenario || scenario, evt.rumor?.emotions, null, evt.platform);
      const platformMsg = applyPlatformTone(msgText, evt.platform, shape, evt.senderType || 'regular');

      const outcomeClass = evt.outcome === 'believed' ? 'believed' : 'rejected';
      const outcomeIcon = evt.outcome === 'believed' ? '<i class="ph ph-check-circle"></i> BELIEVED' : '<i class="ph ph-x-circle"></i> REJECTED';
      const outcomeDetail = evt.outcome === 'believed' ? '' : ' (thresh: ' + (evt.thresholdAtTime || 0).toFixed(3) + ')';

      html += '<div class="inbox-msg ' + outcomeClass + '">';
      html += '<div class="inbox-msg-header"><span class="mono">[t=' + formatTime(evt.time) + ']</span><span>Node #' + evt.senderId + ' (' + tieLabel + ')</span></div>';
      html += '<div class="inbox-msg-text">' + platformMsg + '</div>';
      html += '<div class="inbox-msg-outcome">' + outcomeIcon + outcomeDetail + '</div>';
      html += '</div>';
    }

    // Decision math for the decisive message
    const decisive = events.find(e => e.outcome === 'believed');
    if (decisive) {
      html += '<div class="decision-math card-yellow">';
      html += '<div class="popup-section-title">Decision Math (Decisive Message)</div>';
      html += '<div class="math-row"><span>Base threshold:</span><span class="mono">' + (ns.credibility_threshold || 0).toFixed(3) + '</span></div>';
      html += '<div class="math-row"><span>Trust decay (' + ns.times_exposed + 'x):</span><span class="mono">x' + Math.pow(0.90, ns.times_exposed).toFixed(3) + '</span></div>';
      html += '<div class="math-row"><span>Conf. bias:</span><span class="mono">' + (decisive.confirmationBias || 0).toFixed(3) + '</span></div>';
      html += '<div class="math-row"><span>Source trust:</span><span class="mono">' + (decisive.sourceTrust || 0).toFixed(2) + '</span></div>';
      html += '<div class="math-row"><span>Effective threshold:</span><span class="mono highlight">' + (decisive.effectiveThreshold || 0).toFixed(3) + '</span></div>';
      html += '<hr style="border-color:rgba(0,0,0,0.1);margin:4px 0">';
      html += '<div class="math-row"><span>Rumor credibility:</span><span class="mono">' + (decisive.rumorCredibility || 0).toFixed(3) + '</span></div>';
      html += '<div class="math-row"><span>Framing (' + (decisive.shapeName || '?') + '):</span><span class="mono">+' + ((decisive.framingModifier || 0) * 100).toFixed(0) + '%</span></div>';
      html += '<div class="math-row"><span>Effective credibility:</span><span class="mono">' + (decisive.effectiveCredibility || 0).toFixed(3) + '</span></div>';
      html += '<hr style="border-color:rgba(0,0,0,0.1);margin:4px 0">';
      const passed = (decisive.effectiveCredibility || 0) > (decisive.effectiveThreshold || 0);
      html += '<div class="math-row result"><span>' + (decisive.effectiveCredibility || 0).toFixed(3) + (passed ? ' > ' : ' < ') + (decisive.effectiveThreshold || 0).toFixed(3) + '</span><span class="mono">&rarr; ' + (passed ? 'BELIEVED' : 'REJECTED') + '</span></div>';
      html += '</div>';
    }
  }
  html += '</div></div>';

  nodePopupBody.innerHTML = html;
  nodePopup.classList.remove('hidden');

  // Wire up "Infected by" links
  nodePopupBody.querySelectorAll('.popup-value.clickable').forEach(el => {
    el.addEventListener('click', () => {
      const targetNode = parseInt(el.dataset.node);
      if (!isNaN(targetNode) && worker) {
        worker.postMessage({ type: 'requestNodeData', nodeId: targetNode });
        highlightNode(targetNode);
      }
    });
  });
}

function highlightNode(nodeId) {
  if (!nodeElements) return;
  nodeElements.attr('stroke-width', d => d.id === nodeId ? 3 : (typeStroke[d.type] !== 'transparent' ? 1.5 : 0))
    .attr('stroke', d => d.id === nodeId ? '#E8C547' : (typeStroke[d.type] || 'transparent'));
}

// ============================================================
// Phase 5 Step 3: Edge Tooltip
// ============================================================

const edgeTooltip = document.getElementById('edge-tooltip');
const recentEdgeEvents = new Map();
const MAX_EDGE_EVENTS = 200;
let _edgeTooltipVisible = false;

function updateEdgeEvents(activeEdges) {
  for (const edge of activeEdges) {
    recentEdgeEvents.set(edge.source + '-' + edge.target, edge);
  }
  // Evict oldest if over limit
  while (recentEdgeEvents.size > MAX_EDGE_EVENTS) {
    const oldest = recentEdgeEvents.keys().next().value;
    recentEdgeEvents.delete(oldest);
  }
}

function showEdgeTooltip(x, y, data) {
  _edgeTooltipVisible = true;
  document.getElementById('et-source').textContent = 'Node #' + data.source;
  document.getElementById('et-target').textContent = 'Node #' + data.target;
  const badge = document.getElementById('et-badge');
  if (data.isCorrection) {
    badge.textContent = 'CORR.';
    badge.className = 'edge-type-badge corr-badge';
    edgeTooltip.className = 'edge-tooltip correction';
  } else {
    badge.textContent = 'RUMOR';
    badge.className = 'edge-type-badge rumor-badge';
    edgeTooltip.className = 'edge-tooltip rumor';
  }
  document.getElementById('et-message').textContent = data.message || '';
  const tieLabel = data.edgeStrength > 0.7 ? 'Strong tie' : data.edgeStrength > 0.3 ? 'Weak tie' : 'Stranger';
  document.getElementById('et-meta').innerHTML = '<span><i class="ph ph-link"></i> ' + tieLabel + ' (' + (data.edgeStrength || 0).toFixed(2) + ')</span><span><i class="ph ph-clock"></i> t=' + formatTime(data.time || 0) + '</span>';
  document.getElementById('et-details').innerHTML = (data.rumorVersion != null ? 'Rumor v' + data.rumorVersion + ' &middot; ' : '') + (data.dominantEmotion || '') + ': ' + (data.emotionValue || 0).toFixed(2) + (data.mediaType && data.mediaType !== 'text' ? ' &middot; <i class="ph ph-' + (data.mediaType === 'video' ? 'play-circle' : data.mediaType === 'reel' ? 'film-reel' : 'image') + '"></i> ' + data.mediaType : '');

  // Position near cursor
  const maxX = window.innerWidth - 340;
  const maxY = window.innerHeight - 120;
  edgeTooltip.style.left = Math.min(x + 16, maxX) + 'px';
  edgeTooltip.style.top = Math.min(y - 20, maxY) + 'px';
}

function hideEdgeTooltip() {
  _edgeTooltipVisible = false;
  edgeTooltip.className = 'edge-tooltip hidden';
}

// Document-level mousemove: if tooltip is visible, check distance to all live pulse hit-lines.
// If cursor is not near any pulse line, hide the tooltip.
document.addEventListener('mousemove', function(event) {
  if (!_edgeTooltipVisible) return;
  const graphPanel = document.getElementById('graph-panel');
  if (!graphPanel) return;
  const svgEl = graphPanel.querySelector('svg');
  if (!svgEl) return;
  // Get all live hit-area pulse lines
  const hitLines = svgEl.querySelectorAll('line.pulse-line');
  if (hitLines.length === 0) { hideEdgeTooltip(); return; }
  // Check if cursor is near any hit line using SVG coordinate math
  const pt = svgEl.createSVGPoint();
  pt.x = event.clientX;
  pt.y = event.clientY;
  let ctm;
  try { ctm = svgEl.getScreenCTM().inverse(); } catch(e) { return; }
  const svgPt = pt.matrixTransform(ctm);
  // Also account for zoom transform on the zoom container
  const zoomG = svgEl.querySelector('g.zoom-container');
  let finalPt = svgPt;
  if (zoomG) {
    try {
      const zCtm = zoomG.getScreenCTM().inverse();
      const zPt = pt.matrixTransform(zCtm);
      finalPt = zPt;
    } catch(e) { /* use svgPt */ }
  }
  const mx = finalPt.x, my = finalPt.y;
  let nearAny = false;
  for (const line of hitLines) {
    const x1 = +line.getAttribute('x1'), y1 = +line.getAttribute('y1');
    const x2 = +line.getAttribute('x2'), y2 = +line.getAttribute('y2');
    // Point-to-line-segment distance
    const dx = x2 - x1, dy = y2 - y1;
    const lenSq = dx * dx + dy * dy;
    if (lenSq === 0) continue;
    const t = Math.max(0, Math.min(1, ((mx - x1) * dx + (my - y1) * dy) / lenSq));
    const px = x1 + t * dx, py = y1 + t * dy;
    const dist = Math.sqrt((mx - px) * (mx - px) + (my - py) * (my - py));
    if (dist < 15) { nearAny = true; break; }
  }
  if (!nearAny) hideEdgeTooltip();
});

// ============================================================
// Phase 5 Step 5: Layout Modes (Compare/Overview)
// ============================================================

document.querySelectorAll('#layout-toggle .layout-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const mode = btn.dataset.layout;
    document.querySelectorAll('#layout-toggle .layout-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    appState.layoutMode = mode;

    // Reset all modes
    const graphPanel = document.getElementById('graph-panel');
    const overviewGrid = document.getElementById('overview-grid');
    const compareContainer = document.getElementById('compare-container');
    const rightPanel = document.getElementById('right-panel');

    // Always move SVG back to graph-panel if it was relocated by compare mode
    const svgGraph = document.getElementById('main-graph');
    if (svgGraph && svgGraph.parentElement.id !== 'graph-panel') {
      const statsDiv = graphPanel.querySelector('.graph-stats');
      if (statsDiv) statsDiv.insertAdjacentElement('afterend', document.getElementById('zoom-controls'));
      document.getElementById('zoom-controls').insertAdjacentElement('afterend', svgGraph);
    }

    graphPanel.style.display = '';
    overviewGrid.classList.add('hidden');
    compareContainer.classList.add('hidden');
    rightPanel.style.display = '';

    switch (mode) {
      case 'focus':
        // If returning from enhanced mode, re-init normal graph
        if (appState._wasEnhanced && appState.topology) {
          initD3Graph(appState.topology);
          if (appState.lastSnapshot) updateNodeColors(appState.lastSnapshot.status);
          appState._wasEnhanced = false;
        }
        break;
      case 'compare': {
        // Hide graph-panel, show compare-container with graph on left + chart on right
        graphPanel.style.display = 'none';
        compareContainer.classList.remove('hidden');
        // Reset panel sizes to 50/50
        document.getElementById('compare-left').style.flexBasis = '50%';
        // If coming from enhanced, re-init normal graph first
        if (appState._wasEnhanced && appState.topology) {
          initD3Graph(appState.topology);
          if (appState.lastSnapshot) updateNodeColors(appState.lastSnapshot.status);
          appState._wasEnhanced = false;
        }
        // Move the SVG into the compare-left panel
        const svgEl = document.getElementById('main-graph');
        const zoomCtrl = document.getElementById('zoom-controls');
        const compLeft = document.getElementById('compare-left');
        compLeft.appendChild(zoomCtrl);
        compLeft.appendChild(svgEl);
        // Render comparison chart
        renderCompareChart();
        break;
      }
      case 'overview':
        // Show 4-panel grid, hide main graph
        graphPanel.style.display = 'none';
        overviewGrid.classList.remove('hidden');
        if (appState._wasEnhanced && appState.topology) {
          initD3Graph(appState.topology);
          if (appState.lastSnapshot) updateNodeColors(appState.lastSnapshot.status);
          appState._wasEnhanced = false;
        }
        if (appState.lastSnapshot) renderOverviewPanels(appState.lastSnapshot);
        break;
      case 'enhanced':
        // Re-initialize graph with enhanced force parameters
        if (appState.topology) {
          initEnhancedGraph(appState.topology);
          if (appState.lastSnapshot) updateNodeColors(appState.lastSnapshot.status);
        }
        appState._wasEnhanced = true;
        break;
    }
  });
});

function renderOverviewPanels(snapshot) {
  const platforms = ['twitter', 'whatsapp', 'instagram', 'reddit'];
  const statusCols = ['#A0A0B0', '#E05252', '#D4A04A', '#5294CC', '#52B788', '#4A4A5A'];

  // Compute cell size from the grid container once (avoids feedback loop)
  const gridEl = document.getElementById('overview-grid');
  const gridRect = gridEl.getBoundingClientRect();
  const cellW = Math.floor((gridRect.width - 2) / 2);
  const cellH = Math.floor((gridRect.height - 2) / 2);

  // Use original graph dimensions for scale (graph-panel is hidden in overview mode)
  const gpW = svg ? parseFloat(svg.attr('width')) || 800 : 800;
  const gpH = svg ? parseFloat(svg.attr('height')) || 600 : 600;

  for (const plat of platforms) {
    const canvas = document.getElementById('overview-' + plat);
    if (!canvas) continue;
    canvas.width = cellW || 200;
    canvas.height = cellH || 150;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    if (!graphNodes || !snapshot.status) continue;

    const w = canvas.width, h = canvas.height;
    const sx = w / gpW, sy = h / gpH;

    let believing = 0, corrected = 0, total = 0;
    for (let i = 0; i < graphNodes.length; i++) {
      const n = graphNodes[i];
      // Filter: only show nodes that belong to this platform
      if (!n.platforms || !n.platforms.includes(plat)) continue;
      const status = snapshot.status[i] || 0;
      ctx.fillStyle = statusCols[status] || statusCols[0];
      ctx.globalAlpha = 0.7;
      ctx.beginPath();
      ctx.arc(n.x * sx, n.y * sy, 2, 0, Math.PI * 2);
      ctx.fill();
      total++;
      if (status === 1 || status === 2) believing++;
      if (status === 3) corrected++;
    }
    ctx.globalAlpha = 1;

    // Stats overlay
    const statsEl = document.getElementById('ovs-' + plat);
    if (statsEl) {
      const bPct = total > 0 ? (believing / total * 100).toFixed(0) : 0;
      const cPct = total > 0 ? (corrected / total * 100).toFixed(0) : 0;
      statsEl.innerHTML = '<span style="color:#E05252">' + bPct + '% inf</span> <span style="color:#5294CC">' + cPct + '% cor</span> <span style="color:rgba(255,255,255,0.4)">' + total + ' nodes</span>';
    }
  }
}

// ============================================================
// Phase 5: Compare Mode Chart
let compareChart = null;
function renderCompareChart() {
  const snap = appState.lastSnapshot;
  const topo = appState.topology;
  if (!snap || !topo || !topo.nodes) return;

  const platforms = ['twitter', 'whatsapp', 'instagram', 'reddit'];
  const platStats = {};
  for (const p of platforms) platStats[p] = { believing: 0, corrected: 0, unaware: 0, total: 0 };

  for (let i = 0; i < topo.nodes.length; i++) {
    const s = snap.status[i] || 0;
    const nodePlats = topo.nodes[i].platforms || [];
    for (const p of nodePlats) {
      if (!platStats[p]) continue;
      platStats[p].total++;
      if (s === 1 || s === 2) platStats[p].believing++;
      else if (s === 3) platStats[p].corrected++;
      else platStats[p].unaware++;
    }
  }

  const canvas = document.getElementById('compare-chart');
  if (!canvas) return;
  if (compareChart) compareChart.destroy();

  const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
  const textColor = isDark ? 'rgba(255,255,255,0.7)' : 'rgba(0,0,0,0.7)';

  compareChart = new Chart(canvas.getContext('2d'), {
    type: 'bar',
    data: {
      labels: platforms.map(p => p.charAt(0).toUpperCase() + p.slice(1)),
      datasets: [
        { label: 'Believing %', data: platforms.map(p => platStats[p].total ? (platStats[p].believing / platStats[p].total * 100) : 0), backgroundColor: '#E05252' },
        { label: 'Corrected %', data: platforms.map(p => platStats[p].total ? (platStats[p].corrected / platStats[p].total * 100) : 0), backgroundColor: '#5294CC' },
        { label: 'Unaware %', data: platforms.map(p => platStats[p].total ? (platStats[p].unaware / platStats[p].total * 100) : 0), backgroundColor: '#A0A0B0' },
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      animation: { duration: 0 },
      scales: {
        y: { beginAtZero: true, max: 100, ticks: { color: textColor, font: { size: 10 } }, grid: { color: 'rgba(128,128,128,0.15)' } },
        x: { ticks: { color: textColor, font: { size: 11, weight: '600' } }, grid: { display: false } }
      },
      plugins: {
        legend: { labels: { color: textColor, font: { size: 10 } } }
      }
    }
  });
}

// Compare mode resizable panels
(function() {
  const divider = document.getElementById('compare-divider');
  let resizing = false;
  divider.addEventListener('mousedown', function(e) {
    e.preventDefault();
    resizing = true;
    divider.classList.add('dragging');
    document.body.style.cursor = 'col-resize';
    document.body.style.userSelect = 'none';
  });
  document.addEventListener('mousemove', function(e) {
    if (!resizing) return;
    const container = document.getElementById('compare-container');
    const rect = container.getBoundingClientRect();
    const offset = e.clientX - rect.left;
    const pct = (offset / rect.width) * 100;
    const clamped = Math.max(20, Math.min(80, pct));
    document.getElementById('compare-left').style.flexBasis = clamped + '%';
    // Trigger Chart.js resize
    if (compareChart) compareChart.resize();
  });
  document.addEventListener('mouseup', function() {
    if (!resizing) return;
    resizing = false;
    divider.classList.remove('dragging');
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  });
})();

// Phase 5 Step 7: Advanced Visualizations
// ============================================================

// 7.1 Bot Detection Visualization
function visualizeBotDetection(nodeId) {
  if (!nodeElements) return;
  nodeElements.filter(d => d.id === nodeId)
    .transition().duration(500)
    .attr('r', d => (typeRadius[d.type] || 3) * 0.5)
    .style('fill', '#333333')
    .style('stroke', '#666')
    .style('stroke-dasharray', '2,2');
}

// 7.2 Rewiring Visualization
function visualizeUnfollow(sourceId, targetId) {
  if (!linkGroup) return;
  const pulseGroup = linkGroup._pulseGroup;
  if (!pulseGroup) return;
  const src = graphNodes.find(n => n.id === sourceId);
  const tgt = graphNodes.find(n => n.id === targetId);
  if (!src || !tgt) return;
  pulseGroup.append('line')
    .attr('x1', src.x).attr('y1', src.y)
    .attr('x2', tgt.x).attr('y2', tgt.y)
    .attr('stroke', '#E05252').attr('stroke-width', 2).attr('opacity', 0.9)
    .transition().duration(200).attr('stroke-width', 3)
    .transition().duration(800).attr('opacity', 0).remove();
}

function visualizeSeek(sourceId, targetId) {
  if (!linkGroup) return;
  const pulseGroup = linkGroup._pulseGroup;
  if (!pulseGroup) return;
  const src = graphNodes.find(n => n.id === sourceId);
  const tgt = graphNodes.find(n => n.id === targetId);
  if (!src || !tgt) return;
  pulseGroup.append('line')
    .attr('x1', src.x).attr('y1', src.y)
    .attr('x2', tgt.x).attr('y2', tgt.y)
    .attr('stroke', '#52B788').attr('stroke-width', 2).attr('opacity', 0)
    .transition().duration(200).attr('opacity', 0.8)
    .transition().duration(600).attr('opacity', 0.15).attr('stroke-width', 0.5);
}

// 7.3 Mutation Chain Visualization
function showMutationChain(mutations) {
  if (!mutations || mutations.length === 0) return;
  const overlay = document.getElementById('mutation-overlay');
  overlay.innerHTML = '<button class="close-overlay" id="mutation-close"><i class="ph ph-x"></i></button>';
  overlay.classList.remove('hidden');

  const width = overlay.clientWidth || 400;
  const height = 180;

  const svgEl = d3.select(overlay).append('svg').attr('width', width).attr('height', height);

  const xScale = d3.scaleLinear().domain([0, Math.max(1, mutations.length - 1)]).range([40, width - 20]);
  const yScale = d3.scaleLinear().domain([0, 1]).range([height - 20, 20]);

  // Lines
  for (let i = 0; i < mutations.length - 1; i++) {
    svgEl.append('line')
      .attr('x1', xScale(i)).attr('y1', yScale(mutations[i].dominantValue))
      .attr('x2', xScale(i + 1)).attr('y2', yScale(mutations[i + 1].dominantValue))
      .style('stroke', 'rgba(255,255,255,0.3)').style('stroke-width', 1);
  }

  // Dots
  svgEl.selectAll('circle.mutation-dot').data(mutations).join('circle')
    .attr('cx', (d, i) => xScale(i))
    .attr('cy', d => yScale(d.dominantValue))
    .attr('r', d => 3 + (d.contentQuality || 0.5) * 5)
    .style('fill', d => EMOTION_COLORS_MAP[d.dominantEmotion] || '#999')
    .style('stroke', 'white').style('stroke-width', 1);

  // Labels
  svgEl.selectAll('text.mutation-label').data(mutations).join('text')
    .attr('x', (d, i) => xScale(i))
    .attr('y', d => yScale(d.dominantValue) - 12)
    .attr('text-anchor', 'middle')
    .attr('font-size', '10px')
    .attr('fill', 'rgba(255,255,255,0.6)')
    .text(d => 'v' + d.version);

  document.getElementById('mutation-close').addEventListener('click', () => {
    overlay.classList.add('hidden');
    overlay.innerHTML = '<button class="close-overlay" id="mutation-close"><i class="ph ph-x"></i></button>';
  });
}

// 7.4 Critical Path Highlighting
function renderCriticalPath(data) {
  if (!data || !data.path || data.path.length === 0) return;
  const { path, bridgeNodes, stats } = data;

  // Highlight path nodes
  if (nodeElements) {
    const pathSet = new Set(path);
    const bridgeSet = new Set(bridgeNodes || []);
    nodeElements
      .style('stroke', d => {
        if (bridgeSet.has(d.id)) return '#E8C547';
        if (pathSet.has(d.id)) return '#E05252';
        return typeStroke[d.type] || 'transparent';
      })
      .style('stroke-width', d => {
        if (pathSet.has(d.id) || bridgeSet.has(d.id)) return 3;
        return typeStroke[d.type] !== 'transparent' ? 1.5 : 0;
      })
      .style('filter', d => pathSet.has(d.id) ? 'drop-shadow(0 0 4px rgba(224,82,82,0.6))' : 'none');
  }

  // Show autopsy card in feed
  const autopsyHTML = '<div class="feed-event major card-pink" style="margin:8px 0">' +
    '<div style="display:flex;align-items:center;gap:6px;margin-bottom:6px"><i class="ph-bold ph-magnifying-glass"></i><span style="font-weight:600;text-transform:uppercase;font-size:11px;letter-spacing:0.3px">Network Autopsy</span></div>' +
    '<div class="autopsy-row"><span>Critical path length:</span><span class="mono">' + path.length + ' nodes</span></div>' +
    (bridgeNodes && bridgeNodes.length > 0 ? '<div class="autopsy-row"><span>Key bridge node:</span><span class="mono popup-value clickable" data-node="' + bridgeNodes[0] + '">Node #' + bridgeNodes[0] + '</span></div>' : '') +
    '<div class="autopsy-row"><span>Responsible for:</span><span class="mono">' + (stats?.spreadPct || '?') + '% of spread</span></div>' +
    '</div>';
  feedContainer.insertAdjacentHTML('beforeend', autopsyHTML);
}

// 7.5 Notable Run Detector
function detectNotableRuns(results) {
  if (!results || results.length < 10) return [];
  const rates = results.map(r => r.finalInfectionRate || 0);
  const mean = rates.reduce((s, v) => s + v, 0) / rates.length;
  const std = Math.sqrt(rates.reduce((s, v) => s + (v - mean) ** 2, 0) / rates.length);

  const notable = [];
  const maxRate = Math.max(...rates);
  const minRate = Math.min(...rates);

  for (let i = 0; i < results.length; i++) {
    const r = results[i];
    const rate = r.finalInfectionRate || 0;
    const reasons = [];
    if (rate === maxRate) reasons.push('highest infection (' + (rate * 100).toFixed(1) + '%)');
    if (rate === minRate) reasons.push('lowest infection (' + (rate * 100).toFixed(1) + '%)');
    if (Math.abs(rate - mean) > 2 * std && std > 0.01) reasons.push('statistical outlier');
    if (r.duration && r.duration < 3600) reasons.push('fast death (' + (r.duration / 60).toFixed(0) + 'min)');
    if (reasons.length > 0) {
      notable.push({ runIndex: i, seed: ((appState.lastConfig?.master_seed || 42) + i * 7 + i), reasons });
    }
  }
  return notable.slice(0, 5);
}

// ============================================================
// Phase 5 Step 6: Timeline Scrub
// ============================================================

document.getElementById('scrubber').addEventListener('input', (e) => {
  if (!worker) return;
  const pct = parseInt(e.target.value);
  const progress = pct / 1000;
  // Pause playback
  if (appState.playing) {
    appState.playing = false;
    updatePlayButton();
    pausePulseLines();
    worker.postMessage({ type: 'pause' });
  }
  // Rewind feed to this time and request state reconstruction from worker
  const targetTime = progress * appState.maxTime;
  rerenderFeed(targetTime);
  seenEventTimes.clear();
  worker.postMessage({ type: 'scrubTo', targetTime });
});

// Make timeline markers clickable
document.getElementById('timeline-markers').addEventListener('click', (e) => {
  const marker = e.target.closest('.t-marker');
  if (!marker || !marker.dataset.time) return;
  e.stopPropagation();
  const time = parseFloat(marker.dataset.time);
  const pct = Math.min(1000, (time / appState.maxTime) * 1000);
  document.getElementById('scrubber').value = pct;
  rerenderFeed(time);
  if (worker) worker.postMessage({ type: 'scrubTo', targetTime: time });
});

console.log('[Afwah] Full application loaded with Phase 5 features. Ready.');
})();
  </script>
</body>
</html>
